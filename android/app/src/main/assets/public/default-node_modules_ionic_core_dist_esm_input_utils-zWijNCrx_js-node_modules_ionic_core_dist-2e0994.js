"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ionic_core_dist_esm_input_utils-zWijNCrx_js-node_modules_ionic_core_dist-2e0994"],{

/***/ 1593:
/*!*******************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/input.utils-zWijNCrx.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createSlotMutationController),
/* harmony export */   g: () => (/* binding */ getCounterText)
/* harmony export */ });
/* harmony import */ var _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-ZjP4CjeZ.js */ 575);
/* harmony import */ var _helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-1O4D2b7y.js */ 450);
/* harmony import */ var _index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-B_U9CtaY.js */ 4917);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */




/**
 * Used to update a scoped component that uses emulated slots. This fires when
 * content is passed into the slot or when the content inside of a slot changes.
 * This is not needed for components using native slots in the Shadow DOM.
 * @internal
 * @param el The host element to observe
 * @param slotName mutationCallback will fire when nodes on these slot(s) change
 * @param mutationCallback The callback to fire whenever the slotted content changes
 */
const createSlotMutationController = (el, slotName, mutationCallback) => {
  let hostMutationObserver;
  let slottedContentMutationObserver;
  if (_index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_0__.w !== undefined && "MutationObserver" in _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_0__.w) {
    const slots = Array.isArray(slotName) ? slotName : [slotName];
    hostMutationObserver = new MutationObserver(entries => {
      for (const entry of entries) {
        for (const node of entry.addedNodes) {
          /**
           * Check to see if the added node
           *  is our slotted content.
           */
          if (node.nodeType === Node.ELEMENT_NODE && slots.includes(node.slot)) {
            /**
             * If so, we want to watch the slotted
             * content itself for changes. This lets us
             * detect when content inside of the slot changes.
             */
            mutationCallback();
            /**
             * Adding the listener in an raf
             * waits until Stencil moves the slotted element
             * into the correct place in the event that
             * slotted content is being added.
             */
            (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_1__.r)(() => watchForSlotChange(node));
            return;
          }
        }
      }
    });
    hostMutationObserver.observe(el, {
      childList: true,
      /**
       * This fixes an issue with the `ion-input` and
       * `ion-textarea` not re-rendering in some cases
       * when using the label slot functionality.
       *
       * HTML element patches in Stencil that are enabled
       * by the `experimentalSlotFixes` flag in Stencil v4
       * result in DOM manipulations that won't trigger
       * the current mutation observer configuration and
       * callback.
       */
      subtree: true
    });
  }
  /**
   * Listen for changes inside of the slotted content.
   * We can listen for subtree changes here to be
   * informed of text within the slotted content
   * changing. Doing this on the host is possible
   * but it is much more expensive to do because
   * it also listens for changes to the internals
   * of the component.
   */
  const watchForSlotChange = slottedEl => {
    var _a;
    if (slottedContentMutationObserver) {
      slottedContentMutationObserver.disconnect();
      slottedContentMutationObserver = undefined;
    }
    slottedContentMutationObserver = new MutationObserver(entries => {
      mutationCallback();
      for (const entry of entries) {
        for (const node of entry.removedNodes) {
          /**
           * If the element was removed then we
           * need to destroy the MutationObserver
           * so the element can be garbage collected.
           */
          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {
            destroySlottedContentObserver();
          }
        }
      }
    });
    /**
     * Listen for changes inside of the element
     * as well as anything deep in the tree.
     * We listen on the parentElement so that we can
     * detect when slotted element itself is removed.
     */
    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, {
      subtree: true,
      childList: true
    });
  };
  const destroy = () => {
    if (hostMutationObserver) {
      hostMutationObserver.disconnect();
      hostMutationObserver = undefined;
    }
    destroySlottedContentObserver();
  };
  const destroySlottedContentObserver = () => {
    if (slottedContentMutationObserver) {
      slottedContentMutationObserver.disconnect();
      slottedContentMutationObserver = undefined;
    }
  };
  return {
    destroy
  };
};
const getCounterText = (value, maxLength, counterFormatter) => {
  const valueLength = value == null ? 0 : value.toString().length;
  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);
  /**
   * If developers did not pass a custom formatter,
   * use the default one.
   */
  if (counterFormatter === undefined) {
    return defaultCounterText;
  }
  /**
   * Otherwise, try to use the custom formatter
   * and fallback to the default formatter if
   * there was an error.
   */
  try {
    return counterFormatter(valueLength, maxLength);
  } catch (e) {
    (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_2__.o)('[ion-input] - Exception in provided `counterFormatter`:', e);
    return defaultCounterText;
  }
};
const defaultCounterFormatter = (length, maxlength) => {
  return `${length} / ${maxlength}`;
};


/***/ }),

/***/ 3012:
/*!************************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/notch-controller-C5LPspO8.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createNotchController)
/* harmony export */ });
/* harmony import */ var _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-ZjP4CjeZ.js */ 575);
/* harmony import */ var _helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-1O4D2b7y.js */ 450);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */



/**
 * A utility to calculate the size of an outline notch
 * width relative to the content passed. This is used in
 * components such as `ion-select` with `fill="outline"`
 * where we need to pass slotted HTML content. This is not
 * needed when rendering plaintext content because we can
 * render the plaintext again hidden with `opacity: 0` inside
 * of the notch. As a result we can rely on the intrinsic size
 * of the element to correctly compute the notch width. We
 * cannot do this with slotted content because we cannot project
 * it into 2 places at once.
 *
 * @internal
 * @param el: The host element
 * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.
 * @param getLabelSlot: A function that returns a reference to the slotted content.
 */
const createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {
  let notchVisibilityIO;
  const needsExplicitNotchWidth = () => {
    const notchSpacerEl = getNotchSpacerEl();
    if (
    /**
     * If the notch is not being used
     * then we do not need to set the notch width.
     */
    notchSpacerEl === undefined ||
    /**
     * If either the label property is being
     * used or the label slot is not defined,
     * then we do not need to estimate the notch width.
     */
    el.label !== undefined || getLabelSlot() === null) {
      return false;
    }
    return true;
  };
  const calculateNotchWidth = () => {
    if (needsExplicitNotchWidth()) {
      /**
       * Run this the frame after
       * the browser has re-painted the host element.
       * Otherwise, the label element may have a width
       * of 0 and the IntersectionObserver will be used.
       */
      (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_1__.r)(() => {
        setNotchWidth();
      });
    }
  };
  /**
   * When using a label prop we can render
   * the label value inside of the notch and
   * let the browser calculate the size of the notch.
   * However, we cannot render the label slot in multiple
   * places so we need to manually calculate the notch dimension
   * based on the size of the slotted content.
   *
   * This function should only be used to set the notch width
   * on slotted label content. The notch width for label prop
   * content is automatically calculated based on the
   * intrinsic size of the label text.
   */
  const setNotchWidth = () => {
    const notchSpacerEl = getNotchSpacerEl();
    if (notchSpacerEl === undefined) {
      return;
    }
    if (!needsExplicitNotchWidth()) {
      notchSpacerEl.style.removeProperty('width');
      return;
    }
    const width = getLabelSlot().scrollWidth;
    if (
    /**
     * If the computed width of the label is 0
     * and notchSpacerEl's offsetParent is null
     * then that means the element is hidden.
     * As a result, we need to wait for the element
     * to become visible before setting the notch width.
     *
     * We do not check el.offsetParent because
     * that can be null if the host element has
     * position: fixed applied to it.
     * notchSpacerEl does not have position: fixed.
     */
    width === 0 && notchSpacerEl.offsetParent === null && _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_0__.w !== undefined && "IntersectionObserver" in _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_0__.w) {
      /**
       * If there is an IO already attached
       * then that will update the notch
       * once the element becomes visible.
       * As a result, there is no need to create
       * another one.
       */
      if (notchVisibilityIO !== undefined) {
        return;
      }
      const io = notchVisibilityIO = new IntersectionObserver(ev => {
        /**
         * If the element is visible then we
         * can try setting the notch width again.
         */
        if (ev[0].intersectionRatio === 1) {
          setNotchWidth();
          io.disconnect();
          notchVisibilityIO = undefined;
        }
      },
      /**
       * Set the root to be the host element
       * This causes the IO callback
       * to be fired in WebKit as soon as the element
       * is visible. If we used the default root value
       * then WebKit would only fire the IO callback
       * after any animations (such as a modal transition)
       * finished, and there would potentially be a flicker.
       */
      {
        threshold: 0.01,
        root: el
      });
      io.observe(notchSpacerEl);
      return;
    }
    /**
     * If the element is visible then we can set the notch width.
     * The notch is only visible when the label is scaled,
     * which is why we multiply the width by 0.75 as this is
     * the same amount the label element is scaled by in the host CSS.
     * (See $form-control-label-stacked-scale in ionic.globals.scss).
     */
    notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);
  };
  const destroy = () => {
    if (notchVisibilityIO) {
      notchVisibilityIO.disconnect();
      notchVisibilityIO = undefined;
    }
  };
  return {
    calculateNotchWidth,
    destroy
  };
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV9pbnB1dF91dGlscy16V2lqTkNyeF9qcy1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0LTJlMDk5NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUMrQztBQUNFO0FBQ1E7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1NLDRCQUE0QixHQUFHQSxDQUFDQyxFQUFFLEVBQUVDLFFBQVEsRUFBRUMsZ0JBQWdCLEtBQUs7RUFDckUsSUFBSUMsb0JBQW9CO0VBQ3hCLElBQUlDLDhCQUE4QjtFQUNsQyxJQUFJVixpREFBRyxLQUFLVyxTQUFTLElBQUksdUVBQXlCLEVBQUU7SUFDaEQsTUFBTUMsS0FBSyxHQUFHQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ1AsUUFBUSxDQUFDLEdBQUdBLFFBQVEsR0FBRyxDQUFDQSxRQUFRLENBQUM7SUFDN0RFLG9CQUFvQixHQUFHLElBQUlNLGdCQUFnQixDQUFFQyxPQUFPLElBQUs7TUFDckQsS0FBSyxNQUFNQyxLQUFLLElBQUlELE9BQU8sRUFBRTtRQUN6QixLQUFLLE1BQU1FLElBQUksSUFBSUQsS0FBSyxDQUFDRSxVQUFVLEVBQUU7VUFDakM7QUFDcEI7QUFDQTtBQUNBO1VBQ29CLElBQUlELElBQUksQ0FBQ0UsUUFBUSxLQUFLQyxJQUFJLENBQUNDLFlBQVksSUFBSVYsS0FBSyxDQUFDVyxRQUFRLENBQUNMLElBQUksQ0FBQ00sSUFBSSxDQUFDLEVBQUU7WUFDbEU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7WUFDd0JoQixnQkFBZ0IsQ0FBQyxDQUFDO1lBQ2xCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7WUFDd0JOLHVEQUFHLENBQUMsTUFBTXVCLGtCQUFrQixDQUFDUCxJQUFJLENBQUMsQ0FBQztZQUNuQztVQUNKO1FBQ0o7TUFDSjtJQUNKLENBQUMsQ0FB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LEtBQU07SUFDbEIsSUFBSWlCLGlCQUFpQixFQUFFO01BQ25CQSxpQkFBaUIsQ0FBQ3JCLFVBQVUsQ0FBQyxDQUFDO01BQzlCcUIsaUJBQWlCLEdBQUd6QyxTQUFTO0lBQ2pDO0VBQ0osQ0FBQztFQUNELE9BQU87SUFDSDZDLG1CQUFtQjtJQUNuQnJCO0VBQ0osQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzIjpbIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2lucHV0LnV0aWxzLXpXaWpOQ3J4LmpzIiwiLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vbm90Y2gtY29udHJvbGxlci1DNUxQc3BPOC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgdyBhcyB3aW4gfSBmcm9tICcuL2luZGV4LVpqUDRDamVaLmpzJztcbmltcG9ydCB7IHIgYXMgcmFmIH0gZnJvbSAnLi9oZWxwZXJzLTFPNEQyYjd5LmpzJztcbmltcG9ydCB7IG8gYXMgcHJpbnRJb25FcnJvciB9IGZyb20gJy4vaW5kZXgtQl9VOUN0YVkuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gdXBkYXRlIGEgc2NvcGVkIGNvbXBvbmVudCB0aGF0IHVzZXMgZW11bGF0ZWQgc2xvdHMuIFRoaXMgZmlyZXMgd2hlblxuICogY29udGVudCBpcyBwYXNzZWQgaW50byB0aGUgc2xvdCBvciB3aGVuIHRoZSBjb250ZW50IGluc2lkZSBvZiBhIHNsb3QgY2hhbmdlcy5cbiAqIFRoaXMgaXMgbm90IG5lZWRlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuYXRpdmUgc2xvdHMgaW4gdGhlIFNoYWRvdyBET00uXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBlbCBUaGUgaG9zdCBlbGVtZW50IHRvIG9ic2VydmVcbiAqIEBwYXJhbSBzbG90TmFtZSBtdXRhdGlvbkNhbGxiYWNrIHdpbGwgZmlyZSB3aGVuIG5vZGVzIG9uIHRoZXNlIHNsb3QocykgY2hhbmdlXG4gKiBAcGFyYW0gbXV0YXRpb25DYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZmlyZSB3aGVuZXZlciB0aGUgc2xvdHRlZCBjb250ZW50IGNoYW5nZXNcbiAqL1xuY29uc3QgY3JlYXRlU2xvdE11dGF0aW9uQ29udHJvbGxlciA9IChlbCwgc2xvdE5hbWUsIG11dGF0aW9uQ2FsbGJhY2spID0+IHtcbiAgICBsZXQgaG9zdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgbGV0IHNsb3R0ZWRDb250ZW50TXV0YXRpb25PYnNlcnZlcjtcbiAgICBpZiAod2luICE9PSB1bmRlZmluZWQgJiYgJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbikge1xuICAgICAgICBjb25zdCBzbG90cyA9IEFycmF5LmlzQXJyYXkoc2xvdE5hbWUpID8gc2xvdE5hbWUgOiBbc2xvdE5hbWVdO1xuICAgICAgICBob3N0TXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZW50cnkuYWRkZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBhZGRlZCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAqICBpcyBvdXIgc2xvdHRlZCBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHNsb3RzLmluY2x1ZGVzKG5vZGUuc2xvdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgc28sIHdlIHdhbnQgdG8gd2F0Y2ggdGhlIHNsb3R0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGNvbnRlbnQgaXRzZWxmIGZvciBjaGFuZ2VzLiBUaGlzIGxldHMgdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGRldGVjdCB3aGVuIGNvbnRlbnQgaW5zaWRlIG9mIHRoZSBzbG90IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQWRkaW5nIHRoZSBsaXN0ZW5lciBpbiBhbiByYWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdhaXRzIHVudGlsIFN0ZW5jaWwgbW92ZXMgdGhlIHNsb3R0ZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICogaW50byB0aGUgY29ycmVjdCBwbGFjZSBpbiB0aGUgZXZlbnQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2xvdHRlZCBjb250ZW50IGlzIGJlaW5nIGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICByYWYoKCkgPT4gd2F0Y2hGb3JTbG90Q2hhbmdlKG5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGhvc3RNdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZWwsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBmaXhlcyBhbiBpc3N1ZSB3aXRoIHRoZSBgaW9uLWlucHV0YCBhbmRcbiAgICAgICAgICAgICAqIGBpb24tdGV4dGFyZWFgIG5vdCByZS1yZW5kZXJpbmcgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgICogd2hlbiB1c2luZyB0aGUgbGFiZWwgc2xvdCBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEhUTUwgZWxlbWVudCBwYXRjaGVzIGluIFN0ZW5jaWwgdGhhdCBhcmUgZW5hYmxlZFxuICAgICAgICAgICAgICogYnkgdGhlIGBleHBlcmltZW50YWxTbG90Rml4ZXNgIGZsYWcgaW4gU3RlbmNpbCB2NFxuICAgICAgICAgICAgICogcmVzdWx0IGluIERPTSBtYW5pcHVsYXRpb25zIHRoYXQgd29uJ3QgdHJpZ2dlclxuICAgICAgICAgICAgICogdGhlIGN1cnJlbnQgbXV0YXRpb24gb2JzZXJ2ZXIgY29uZmlndXJhdGlvbiBhbmRcbiAgICAgICAgICAgICAqIGNhbGxiYWNrLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciBjaGFuZ2VzIGluc2lkZSBvZiB0aGUgc2xvdHRlZCBjb250ZW50LlxuICAgICAqIFdlIGNhbiBsaXN0ZW4gZm9yIHN1YnRyZWUgY2hhbmdlcyBoZXJlIHRvIGJlXG4gICAgICogaW5mb3JtZWQgb2YgdGV4dCB3aXRoaW4gdGhlIHNsb3R0ZWQgY29udGVudFxuICAgICAqIGNoYW5naW5nLiBEb2luZyB0aGlzIG9uIHRoZSBob3N0IGlzIHBvc3NpYmxlXG4gICAgICogYnV0IGl0IGlzIG11Y2ggbW9yZSBleHBlbnNpdmUgdG8gZG8gYmVjYXVzZVxuICAgICAqIGl0IGFsc28gbGlzdGVucyBmb3IgY2hhbmdlcyB0byB0aGUgaW50ZXJuYWxzXG4gICAgICogb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjb25zdCB3YXRjaEZvclNsb3RDaGFuZ2UgPSAoc2xvdHRlZEVsKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHNsb3R0ZWRDb250ZW50TXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgc2xvdHRlZENvbnRlbnRNdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHNsb3R0ZWRDb250ZW50TXV0YXRpb25PYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzbG90dGVkQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgbXV0YXRpb25DYWxsYmFjaygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGVudHJ5LnJlbW92ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQgdGhlbiB3ZVxuICAgICAgICAgICAgICAgICAgICAgKiBuZWVkIHRvIGRlc3Ryb3kgdGhlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICogc28gdGhlIGVsZW1lbnQgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG5vZGUuc2xvdCA9PT0gc2xvdE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3lTbG90dGVkQ29udGVudE9ic2VydmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdGVuIGZvciBjaGFuZ2VzIGluc2lkZSBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgKiBhcyB3ZWxsIGFzIGFueXRoaW5nIGRlZXAgaW4gdGhlIHRyZWUuXG4gICAgICAgICAqIFdlIGxpc3RlbiBvbiB0aGUgcGFyZW50RWxlbWVudCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgKiBkZXRlY3Qgd2hlbiBzbG90dGVkIGVsZW1lbnQgaXRzZWxmIGlzIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzbG90dGVkQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSgoX2EgPSBzbG90dGVkRWwucGFyZW50RWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2xvdHRlZEVsLCB7IHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGlmIChob3N0TXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaG9zdE11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgaG9zdE11dGF0aW9uT2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdHJveVNsb3R0ZWRDb250ZW50T2JzZXJ2ZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlc3Ryb3lTbG90dGVkQ29udGVudE9ic2VydmVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoc2xvdHRlZENvbnRlbnRNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICBzbG90dGVkQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgc2xvdHRlZENvbnRlbnRNdXRhdGlvbk9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59O1xuXG5jb25zdCBnZXRDb3VudGVyVGV4dCA9ICh2YWx1ZSwgbWF4TGVuZ3RoLCBjb3VudGVyRm9ybWF0dGVyKSA9PiB7XG4gICAgY29uc3QgdmFsdWVMZW5ndGggPSB2YWx1ZSA9PSBudWxsID8gMCA6IHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgIGNvbnN0IGRlZmF1bHRDb3VudGVyVGV4dCA9IGRlZmF1bHRDb3VudGVyRm9ybWF0dGVyKHZhbHVlTGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIElmIGRldmVsb3BlcnMgZGlkIG5vdCBwYXNzIGEgY3VzdG9tIGZvcm1hdHRlcixcbiAgICAgKiB1c2UgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqL1xuICAgIGlmIChjb3VudGVyRm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb3VudGVyVGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3RoZXJ3aXNlLCB0cnkgdG8gdXNlIHRoZSBjdXN0b20gZm9ybWF0dGVyXG4gICAgICogYW5kIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpZlxuICAgICAqIHRoZXJlIHdhcyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY291bnRlckZvcm1hdHRlcih2YWx1ZUxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJpbnRJb25FcnJvcignW2lvbi1pbnB1dF0gLSBFeGNlcHRpb24gaW4gcHJvdmlkZWQgYGNvdW50ZXJGb3JtYXR0ZXJgOicsIGUpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdENvdW50ZXJUZXh0O1xuICAgIH1cbn07XG5jb25zdCBkZWZhdWx0Q291bnRlckZvcm1hdHRlciA9IChsZW5ndGgsIG1heGxlbmd0aCkgPT4ge1xuICAgIHJldHVybiBgJHtsZW5ndGh9IC8gJHttYXhsZW5ndGh9YDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVNsb3RNdXRhdGlvbkNvbnRyb2xsZXIgYXMgYywgZ2V0Q291bnRlclRleHQgYXMgZyB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHcgYXMgd2luIH0gZnJvbSAnLi9pbmRleC1aalA0Q2plWi5qcyc7XG5pbXBvcnQgeyByIGFzIHJhZiB9IGZyb20gJy4vaGVscGVycy0xTzREMmI3eS5qcyc7XG5cbi8qKlxuICogQSB1dGlsaXR5IHRvIGNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBhbiBvdXRsaW5lIG5vdGNoXG4gKiB3aWR0aCByZWxhdGl2ZSB0byB0aGUgY29udGVudCBwYXNzZWQuIFRoaXMgaXMgdXNlZCBpblxuICogY29tcG9uZW50cyBzdWNoIGFzIGBpb24tc2VsZWN0YCB3aXRoIGBmaWxsPVwib3V0bGluZVwiYFxuICogd2hlcmUgd2UgbmVlZCB0byBwYXNzIHNsb3R0ZWQgSFRNTCBjb250ZW50LiBUaGlzIGlzIG5vdFxuICogbmVlZGVkIHdoZW4gcmVuZGVyaW5nIHBsYWludGV4dCBjb250ZW50IGJlY2F1c2Ugd2UgY2FuXG4gKiByZW5kZXIgdGhlIHBsYWludGV4dCBhZ2FpbiBoaWRkZW4gd2l0aCBgb3BhY2l0eTogMGAgaW5zaWRlXG4gKiBvZiB0aGUgbm90Y2guIEFzIGEgcmVzdWx0IHdlIGNhbiByZWx5IG9uIHRoZSBpbnRyaW5zaWMgc2l6ZVxuICogb2YgdGhlIGVsZW1lbnQgdG8gY29ycmVjdGx5IGNvbXB1dGUgdGhlIG5vdGNoIHdpZHRoLiBXZVxuICogY2Fubm90IGRvIHRoaXMgd2l0aCBzbG90dGVkIGNvbnRlbnQgYmVjYXVzZSB3ZSBjYW5ub3QgcHJvamVjdFxuICogaXQgaW50byAyIHBsYWNlcyBhdCBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGVsOiBUaGUgaG9zdCBlbGVtZW50XG4gKiBAcGFyYW0gZ2V0Tm90Y2hTcGFjZXJFbDogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIG5vdGNoIHNwYWNlciBlbGVtZW50IGluc2lkZSBvZiB0aGUgY29tcG9uZW50IHRlbXBsYXRlLlxuICogQHBhcmFtIGdldExhYmVsU2xvdDogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHNsb3R0ZWQgY29udGVudC5cbiAqL1xuY29uc3QgY3JlYXRlTm90Y2hDb250cm9sbGVyID0gKGVsLCBnZXROb3RjaFNwYWNlckVsLCBnZXRMYWJlbFNsb3QpID0+IHtcbiAgICBsZXQgbm90Y2hWaXNpYmlsaXR5SU87XG4gICAgY29uc3QgbmVlZHNFeHBsaWNpdE5vdGNoV2lkdGggPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vdGNoU3BhY2VyRWwgPSBnZXROb3RjaFNwYWNlckVsKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBub3RjaCBpcyBub3QgYmVpbmcgdXNlZFxuICAgICAgICAgKiB0aGVuIHdlIGRvIG5vdCBuZWVkIHRvIHNldCB0aGUgbm90Y2ggd2lkdGguXG4gICAgICAgICAqL1xuICAgICAgICBub3RjaFNwYWNlckVsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgZWl0aGVyIHRoZSBsYWJlbCBwcm9wZXJ0eSBpcyBiZWluZ1xuICAgICAgICAgICAgICogdXNlZCBvciB0aGUgbGFiZWwgc2xvdCBpcyBub3QgZGVmaW5lZCxcbiAgICAgICAgICAgICAqIHRoZW4gd2UgZG8gbm90IG5lZWQgdG8gZXN0aW1hdGUgdGhlIG5vdGNoIHdpZHRoLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbC5sYWJlbCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBnZXRMYWJlbFNsb3QoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgY2FsY3VsYXRlTm90Y2hXaWR0aCA9ICgpID0+IHtcbiAgICAgICAgaWYgKG5lZWRzRXhwbGljaXROb3RjaFdpZHRoKCkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUnVuIHRoaXMgdGhlIGZyYW1lIGFmdGVyXG4gICAgICAgICAgICAgKiB0aGUgYnJvd3NlciBoYXMgcmUtcGFpbnRlZCB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgbGFiZWwgZWxlbWVudCBtYXkgaGF2ZSBhIHdpZHRoXG4gICAgICAgICAgICAgKiBvZiAwIGFuZCB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByYWYoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldE5vdGNoV2lkdGgoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIGEgbGFiZWwgcHJvcCB3ZSBjYW4gcmVuZGVyXG4gICAgICogdGhlIGxhYmVsIHZhbHVlIGluc2lkZSBvZiB0aGUgbm90Y2ggYW5kXG4gICAgICogbGV0IHRoZSBicm93c2VyIGNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGUgbm90Y2guXG4gICAgICogSG93ZXZlciwgd2UgY2Fubm90IHJlbmRlciB0aGUgbGFiZWwgc2xvdCBpbiBtdWx0aXBsZVxuICAgICAqIHBsYWNlcyBzbyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGN1bGF0ZSB0aGUgbm90Y2ggZGltZW5zaW9uXG4gICAgICogYmFzZWQgb24gdGhlIHNpemUgb2YgdGhlIHNsb3R0ZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCB0byBzZXQgdGhlIG5vdGNoIHdpZHRoXG4gICAgICogb24gc2xvdHRlZCBsYWJlbCBjb250ZW50LiBUaGUgbm90Y2ggd2lkdGggZm9yIGxhYmVsIHByb3BcbiAgICAgKiBjb250ZW50IGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGVcbiAgICAgKiBpbnRyaW5zaWMgc2l6ZSBvZiB0aGUgbGFiZWwgdGV4dC5cbiAgICAgKi9cbiAgICBjb25zdCBzZXROb3RjaFdpZHRoID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBub3RjaFNwYWNlckVsID0gZ2V0Tm90Y2hTcGFjZXJFbCgpO1xuICAgICAgICBpZiAobm90Y2hTcGFjZXJFbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZWVkc0V4cGxpY2l0Tm90Y2hXaWR0aCgpKSB7XG4gICAgICAgICAgICBub3RjaFNwYWNlckVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd3aWR0aCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0TGFiZWxTbG90KCkuc2Nyb2xsV2lkdGg7XG4gICAgICAgIGlmIChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBjb21wdXRlZCB3aWR0aCBvZiB0aGUgbGFiZWwgaXMgMFxuICAgICAgICAgKiBhbmQgbm90Y2hTcGFjZXJFbCdzIG9mZnNldFBhcmVudCBpcyBudWxsXG4gICAgICAgICAqIHRoZW4gdGhhdCBtZWFucyB0aGUgZWxlbWVudCBpcyBoaWRkZW4uXG4gICAgICAgICAqIEFzIGEgcmVzdWx0LCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAqIHRvIGJlY29tZSB2aXNpYmxlIGJlZm9yZSBzZXR0aW5nIHRoZSBub3RjaCB3aWR0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2UgZG8gbm90IGNoZWNrIGVsLm9mZnNldFBhcmVudCBiZWNhdXNlXG4gICAgICAgICAqIHRoYXQgY2FuIGJlIG51bGwgaWYgdGhlIGhvc3QgZWxlbWVudCBoYXNcbiAgICAgICAgICogcG9zaXRpb246IGZpeGVkIGFwcGxpZWQgdG8gaXQuXG4gICAgICAgICAqIG5vdGNoU3BhY2VyRWwgZG9lcyBub3QgaGF2ZSBwb3NpdGlvbjogZml4ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aCA9PT0gMCAmJlxuICAgICAgICAgICAgbm90Y2hTcGFjZXJFbC5vZmZzZXRQYXJlbnQgPT09IG51bGwgJiZcbiAgICAgICAgICAgIHdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInIGluIHdpbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSBpcyBhbiBJTyBhbHJlYWR5IGF0dGFjaGVkXG4gICAgICAgICAgICAgKiB0aGVuIHRoYXQgd2lsbCB1cGRhdGUgdGhlIG5vdGNoXG4gICAgICAgICAgICAgKiBvbmNlIHRoZSBlbGVtZW50IGJlY29tZXMgdmlzaWJsZS5cbiAgICAgICAgICAgICAqIEFzIGEgcmVzdWx0LCB0aGVyZSBpcyBubyBuZWVkIHRvIGNyZWF0ZVxuICAgICAgICAgICAgICogYW5vdGhlciBvbmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChub3RjaFZpc2liaWxpdHlJTyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW8gPSAobm90Y2hWaXNpYmlsaXR5SU8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSB0aGVuIHdlXG4gICAgICAgICAgICAgICAgICogY2FuIHRyeSBzZXR0aW5nIHRoZSBub3RjaCB3aWR0aCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZXZbMF0uaW50ZXJzZWN0aW9uUmF0aW8gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Tm90Y2hXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBpby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIG5vdGNoVmlzaWJpbGl0eUlPID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdGhlIHJvb3QgdG8gYmUgdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICogVGhpcyBjYXVzZXMgdGhlIElPIGNhbGxiYWNrXG4gICAgICAgICAgICAgKiB0byBiZSBmaXJlZCBpbiBXZWJLaXQgYXMgc29vbiBhcyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICogaXMgdmlzaWJsZS4gSWYgd2UgdXNlZCB0aGUgZGVmYXVsdCByb290IHZhbHVlXG4gICAgICAgICAgICAgKiB0aGVuIFdlYktpdCB3b3VsZCBvbmx5IGZpcmUgdGhlIElPIGNhbGxiYWNrXG4gICAgICAgICAgICAgKiBhZnRlciBhbnkgYW5pbWF0aW9ucyAoc3VjaCBhcyBhIG1vZGFsIHRyYW5zaXRpb24pXG4gICAgICAgICAgICAgKiBmaW5pc2hlZCwgYW5kIHRoZXJlIHdvdWxkIHBvdGVudGlhbGx5IGJlIGEgZmxpY2tlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgeyB0aHJlc2hvbGQ6IDAuMDEsIHJvb3Q6IGVsIH0pKTtcbiAgICAgICAgICAgIGlvLm9ic2VydmUobm90Y2hTcGFjZXJFbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBlbGVtZW50IGlzIHZpc2libGUgdGhlbiB3ZSBjYW4gc2V0IHRoZSBub3RjaCB3aWR0aC5cbiAgICAgICAgICogVGhlIG5vdGNoIGlzIG9ubHkgdmlzaWJsZSB3aGVuIHRoZSBsYWJlbCBpcyBzY2FsZWQsXG4gICAgICAgICAqIHdoaWNoIGlzIHdoeSB3ZSBtdWx0aXBseSB0aGUgd2lkdGggYnkgMC43NSBhcyB0aGlzIGlzXG4gICAgICAgICAqIHRoZSBzYW1lIGFtb3VudCB0aGUgbGFiZWwgZWxlbWVudCBpcyBzY2FsZWQgYnkgaW4gdGhlIGhvc3QgQ1NTLlxuICAgICAgICAgKiAoU2VlICRmb3JtLWNvbnRyb2wtbGFiZWwtc3RhY2tlZC1zY2FsZSBpbiBpb25pYy5nbG9iYWxzLnNjc3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgbm90Y2hTcGFjZXJFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnd2lkdGgnLCBgJHt3aWR0aCAqIDAuNzV9cHhgKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGlmIChub3RjaFZpc2liaWxpdHlJTykge1xuICAgICAgICAgICAgbm90Y2hWaXNpYmlsaXR5SU8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgbm90Y2hWaXNpYmlsaXR5SU8gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhbGN1bGF0ZU5vdGNoV2lkdGgsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgfTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZU5vdGNoQ29udHJvbGxlciBhcyBjIH07XG4iXSwibmFtZXMiOlsidyIsIndpbiIsInIiLCJyYWYiLCJvIiwicHJpbnRJb25FcnJvciIsImNyZWF0ZVNsb3RNdXRhdGlvbkNvbnRyb2xsZXIiLCJlbCIsInNsb3ROYW1lIiwibXV0YXRpb25DYWxsYmFjayIsImhvc3RNdXRhdGlvbk9ic2VydmVyIiwic2xvdHRlZENvbnRlbnRNdXRhdGlvbk9ic2VydmVyIiwidW5kZWZpbmVkIiwic2xvdHMiLCJBcnJheSIsImlzQXJyYXkiLCJNdXRhdGlvbk9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5Iiwibm9kZSIsImFkZGVkTm9kZXMiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJpbmNsdWRlcyIsInNsb3QiLCJ3YXRjaEZvclNsb3RDaGFuZ2UiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsInNsb3R0ZWRFbCIsIl9hIiwiZGlzY29ubmVjdCIsInJlbW92ZWROb2RlcyIsImRlc3Ryb3lTbG90dGVkQ29udGVudE9ic2VydmVyIiwicGFyZW50RWxlbWVudCIsImRlc3Ryb3kiLCJnZXRDb3VudGVyVGV4dCIsInZhbHVlIiwibWF4TGVuZ3RoIiwiY291bnRlckZvcm1hdHRlciIsInZhbHVlTGVuZ3RoIiwidG9TdHJpbmciLCJsZW5ndGgiLCJkZWZhdWx0Q291bnRlclRleHQiLCJkZWZhdWx0Q291bnRlckZvcm1hdHRlciIsImUiLCJtYXhsZW5ndGgiLCJjIiwiZyIsImNyZWF0ZU5vdGNoQ29udHJvbGxlciIsImdldE5vdGNoU3BhY2VyRWwiLCJnZXRMYWJlbFNsb3QiLCJub3RjaFZpc2liaWxpdHlJTyIsIm5lZWRzRXhwbGljaXROb3RjaFdpZHRoIiwibm90Y2hTcGFjZXJFbCIsImxhYmVsIiwiY2FsY3VsYXRlTm90Y2hXaWR0aCIsInNldE5vdGNoV2lkdGgiLCJzdHlsZSIsInJlbW92ZVByb3BlcnR5Iiwid2lkdGgiLCJzY3JvbGxXaWR0aCIsIm9mZnNldFBhcmVudCIsImlvIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJldiIsImludGVyc2VjdGlvblJhdGlvIiwidGhyZXNob2xkIiwicm9vdCIsInNldFByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiJ3ZWJwYWNrOi8vLyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDFdfQ==