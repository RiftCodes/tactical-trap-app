"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ionic_core_dist_esm_input_utils-28bf4ef0_js-node_modules_ionic_core_dist-c72fbc"],{

/***/ 7351:
/*!*******************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/input.utils-28bf4ef0.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createSlotMutationController),
/* harmony export */   g: () => (/* binding */ getCounterText)
/* harmony export */ });
/* harmony import */ var _index_a5d50daf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-a5d50daf.js */ 6639);
/* harmony import */ var _helpers_78efeec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-78efeec3.js */ 9522);
/* harmony import */ var _index_738d7504_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-738d7504.js */ 7243);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */




/**
 * Used to update a scoped component that uses emulated slots. This fires when
 * content is passed into the slot or when the content inside of a slot changes.
 * This is not needed for components using native slots in the Shadow DOM.
 * @internal
 * @param el The host element to observe
 * @param slotName mutationCallback will fire when nodes on these slot(s) change
 * @param mutationCallback The callback to fire whenever the slotted content changes
 */
const createSlotMutationController = (el, slotName, mutationCallback) => {
  let hostMutationObserver;
  let slottedContentMutationObserver;
  if (_index_a5d50daf_js__WEBPACK_IMPORTED_MODULE_0__.w !== undefined && "MutationObserver" in _index_a5d50daf_js__WEBPACK_IMPORTED_MODULE_0__.w) {
    const slots = Array.isArray(slotName) ? slotName : [slotName];
    hostMutationObserver = new MutationObserver(entries => {
      for (const entry of entries) {
        for (const node of entry.addedNodes) {
          /**
           * Check to see if the added node
           *  is our slotted content.
           */
          if (node.nodeType === Node.ELEMENT_NODE && slots.includes(node.slot)) {
            /**
             * If so, we want to watch the slotted
             * content itself for changes. This lets us
             * detect when content inside of the slot changes.
             */
            mutationCallback();
            /**
             * Adding the listener in an raf
             * waits until Stencil moves the slotted element
             * into the correct place in the event that
             * slotted content is being added.
             */
            (0,_helpers_78efeec3_js__WEBPACK_IMPORTED_MODULE_1__.r)(() => watchForSlotChange(node));
            return;
          }
        }
      }
    });
    hostMutationObserver.observe(el, {
      childList: true,
      /**
       * This fixes an issue with the `ion-input` and
       * `ion-textarea` not re-rendering in some cases
       * when using the label slot functionality.
       *
       * HTML element patches in Stencil that are enabled
       * by the `experimentalSlotFixes` flag in Stencil v4
       * result in DOM manipulations that won't trigger
       * the current mutation observer configuration and
       * callback.
       */
      subtree: true
    });
  }
  /**
   * Listen for changes inside of the slotted content.
   * We can listen for subtree changes here to be
   * informed of text within the slotted content
   * changing. Doing this on the host is possible
   * but it is much more expensive to do because
   * it also listens for changes to the internals
   * of the component.
   */
  const watchForSlotChange = slottedEl => {
    var _a;
    if (slottedContentMutationObserver) {
      slottedContentMutationObserver.disconnect();
      slottedContentMutationObserver = undefined;
    }
    slottedContentMutationObserver = new MutationObserver(entries => {
      mutationCallback();
      for (const entry of entries) {
        for (const node of entry.removedNodes) {
          /**
           * If the element was removed then we
           * need to destroy the MutationObserver
           * so the element can be garbage collected.
           */
          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {
            destroySlottedContentObserver();
          }
        }
      }
    });
    /**
     * Listen for changes inside of the element
     * as well as anything deep in the tree.
     * We listen on the parentElement so that we can
     * detect when slotted element itself is removed.
     */
    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, {
      subtree: true,
      childList: true
    });
  };
  const destroy = () => {
    if (hostMutationObserver) {
      hostMutationObserver.disconnect();
      hostMutationObserver = undefined;
    }
    destroySlottedContentObserver();
  };
  const destroySlottedContentObserver = () => {
    if (slottedContentMutationObserver) {
      slottedContentMutationObserver.disconnect();
      slottedContentMutationObserver = undefined;
    }
  };
  return {
    destroy
  };
};
const getCounterText = (value, maxLength, counterFormatter) => {
  const valueLength = value == null ? 0 : value.toString().length;
  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);
  /**
   * If developers did not pass a custom formatter,
   * use the default one.
   */
  if (counterFormatter === undefined) {
    return defaultCounterText;
  }
  /**
   * Otherwise, try to use the custom formatter
   * and fallback to the default formatter if
   * there was an error.
   */
  try {
    return counterFormatter(valueLength, maxLength);
  } catch (e) {
    (0,_index_738d7504_js__WEBPACK_IMPORTED_MODULE_2__.a)('Exception in provided `counterFormatter`.', e);
    return defaultCounterText;
  }
};
const defaultCounterFormatter = (length, maxlength) => {
  return `${length} / ${maxlength}`;
};


/***/ }),

/***/ 3405:
/*!************************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/notch-controller-00d92e89.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createNotchController)
/* harmony export */ });
/* harmony import */ var _index_a5d50daf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-a5d50daf.js */ 6639);
/* harmony import */ var _helpers_78efeec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-78efeec3.js */ 9522);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */



/**
 * A utility to calculate the size of an outline notch
 * width relative to the content passed. This is used in
 * components such as `ion-select` with `fill="outline"`
 * where we need to pass slotted HTML content. This is not
 * needed when rendering plaintext content because we can
 * render the plaintext again hidden with `opacity: 0` inside
 * of the notch. As a result we can rely on the intrinsic size
 * of the element to correctly compute the notch width. We
 * cannot do this with slotted content because we cannot project
 * it into 2 places at once.
 *
 * @internal
 * @param el: The host element
 * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.
 * @param getLabelSlot: A function that returns a reference to the slotted content.
 */
const createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {
  let notchVisibilityIO;
  const needsExplicitNotchWidth = () => {
    const notchSpacerEl = getNotchSpacerEl();
    if (
    /**
     * If the notch is not being used
     * then we do not need to set the notch width.
     */
    notchSpacerEl === undefined ||
    /**
     * If either the label property is being
     * used or the label slot is not defined,
     * then we do not need to estimate the notch width.
     */
    el.label !== undefined || getLabelSlot() === null) {
      return false;
    }
    return true;
  };
  const calculateNotchWidth = () => {
    if (needsExplicitNotchWidth()) {
      /**
       * Run this the frame after
       * the browser has re-painted the host element.
       * Otherwise, the label element may have a width
       * of 0 and the IntersectionObserver will be used.
       */
      (0,_helpers_78efeec3_js__WEBPACK_IMPORTED_MODULE_1__.r)(() => {
        setNotchWidth();
      });
    }
  };
  /**
   * When using a label prop we can render
   * the label value inside of the notch and
   * let the browser calculate the size of the notch.
   * However, we cannot render the label slot in multiple
   * places so we need to manually calculate the notch dimension
   * based on the size of the slotted content.
   *
   * This function should only be used to set the notch width
   * on slotted label content. The notch width for label prop
   * content is automatically calculated based on the
   * intrinsic size of the label text.
   */
  const setNotchWidth = () => {
    const notchSpacerEl = getNotchSpacerEl();
    if (notchSpacerEl === undefined) {
      return;
    }
    if (!needsExplicitNotchWidth()) {
      notchSpacerEl.style.removeProperty('width');
      return;
    }
    const width = getLabelSlot().scrollWidth;
    if (
    /**
     * If the computed width of the label is 0
     * and notchSpacerEl's offsetParent is null
     * then that means the element is hidden.
     * As a result, we need to wait for the element
     * to become visible before setting the notch width.
     *
     * We do not check el.offsetParent because
     * that can be null if the host element has
     * position: fixed applied to it.
     * notchSpacerEl does not have position: fixed.
     */
    width === 0 && notchSpacerEl.offsetParent === null && _index_a5d50daf_js__WEBPACK_IMPORTED_MODULE_0__.w !== undefined && "IntersectionObserver" in _index_a5d50daf_js__WEBPACK_IMPORTED_MODULE_0__.w) {
      /**
       * If there is an IO already attached
       * then that will update the notch
       * once the element becomes visible.
       * As a result, there is no need to create
       * another one.
       */
      if (notchVisibilityIO !== undefined) {
        return;
      }
      const io = notchVisibilityIO = new IntersectionObserver(ev => {
        /**
         * If the element is visible then we
         * can try setting the notch width again.
         */
        if (ev[0].intersectionRatio === 1) {
          setNotchWidth();
          io.disconnect();
          notchVisibilityIO = undefined;
        }
      },
      /**
       * Set the root to be the host element
       * This causes the IO callback
       * to be fired in WebKit as soon as the element
       * is visible. If we used the default root value
       * then WebKit would only fire the IO callback
       * after any animations (such as a modal transition)
       * finished, and there would potentially be a flicker.
       */
      {
        threshold: 0.01,
        root: el
      });
      io.observe(notchSpacerEl);
      return;
    }
    /**
     * If the element is visible then we can set the notch width.
     * The notch is only visible when the label is scaled,
     * which is why we multiply the width by 0.75 as this is
     * the same amount the label element is scaled by in the host CSS.
     * (See $form-control-label-stacked-scale in ionic.globals.scss).
     */
    notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);
  };
  const destroy = () => {
    if (notchVisibilityIO) {
      notchVisibilityIO.disconnect();
      notchVisibilityIO = undefined;
    }
  };
  return {
    calculateNotchWidth,
    destroy
  };
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV9pbnB1dF91dGlscy0yOGJmNGVmMF9qcy1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0LWM3MmZiYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUMrQztBQUNFO0FBQ1E7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1NLDRCQUE0QixHQUFHQSxDQUFDQyxFQUFFLEVBQUVDLFFBQVEsRUFBRUMsZ0JBQWdCLEtBQUs7RUFDckUsSUFBSUMsb0JBQW9CO0VBQ3hCLElBQUlDLDhCQUE4QjtFQUNsQyxJQUFJVixpREFBRyxLQUFLVyxTQUFTLElBQUksdUVBQXlCLEVBQUU7SUFDaEQsTUFBTUMsS0FBSyxHQUFHQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ1AsUUFBUSxDQUFDLEdBQUdBLFFBQVEsR0FBRyxDQUFDQSxRQUFRLENBQUM7SUFDN0RFLG9CQUFvQixHQUFHLElBQUlNLGdCQUFnQixDQUFFQyxPQUFPLElBQUs7TUFDckQsS0FBSyxNQUFNQyxLQUFLLElBQUlELE9BQU8sRUFBRTtRQUN6QixLQUFLLE1BQU1FLElBQUksSUFBSUQsS0FBSyxDQUFDRSxVQUFVLEVBQUU7VUFDakM7QUFDcEI7QUFDQTtBQUNBO1VBQ29CLElBQUlELElBQUksQ0FBQ0UsUUFBUSxLQUFLQyxJQUFJLENBQUNDLFlBQVksSUFBSVYsS0FBSyxDQUFDVyxRQUFRLENBQUNMLElBQUksQ0FBQ00sSUFBSSxDQUFDLEVBQUU7WUFDbEU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7WUFDd0JoQixnQkFBZ0IsQ0FBQyxDQUFDO1lBQ2xCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7WUFDd0JOLHVEQUFHLENBQUMsTUFBTXVCLGtCQUFrQixDQUFDUCxJQUFJLENBQUMsQ0FBQztZQUNuQztVQUNKO1FBQ0o7TUFDSjtJQUNKLENBQUMsQ0FB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LEtBQU07SUFDbEIsSUFBSWlCLGlCQUFpQixFQUFFO01BQ25CQSxpQkFBaUIsQ0FBQ3JCLFVBQVUsQ0FBQyxDQUFDO01BQzlCcUIsaUJBQWlCLEdBQUd6QyxTQUFTO0lBQ2pDO0VBQ0osQ0FBQztFQUNELE9BQU87SUFDSDZDLG1CQUFtQjtJQUNuQnJCO0VBQ0osQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzIjpbIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2lucHV0LnV0aWxzLTI4YmY0ZWYwLmpzIiwiLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vbm90Y2gtY29udHJvbGxlci0wMGQ5MmU4OS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgdyBhcyB3aW4gfSBmcm9tICcuL2luZGV4LWE1ZDUwZGFmLmpzJztcbmltcG9ydCB7IHIgYXMgcmFmIH0gZnJvbSAnLi9oZWxwZXJzLTc4ZWZlZWMzLmpzJztcbmltcG9ydCB7IGEgYXMgcHJpbnRJb25FcnJvciB9IGZyb20gJy4vaW5kZXgtNzM4ZDc1MDQuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gdXBkYXRlIGEgc2NvcGVkIGNvbXBvbmVudCB0aGF0IHVzZXMgZW11bGF0ZWQgc2xvdHMuIFRoaXMgZmlyZXMgd2hlblxuICogY29udGVudCBpcyBwYXNzZWQgaW50byB0aGUgc2xvdCBvciB3aGVuIHRoZSBjb250ZW50IGluc2lkZSBvZiBhIHNsb3QgY2hhbmdlcy5cbiAqIFRoaXMgaXMgbm90IG5lZWRlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuYXRpdmUgc2xvdHMgaW4gdGhlIFNoYWRvdyBET00uXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBlbCBUaGUgaG9zdCBlbGVtZW50IHRvIG9ic2VydmVcbiAqIEBwYXJhbSBzbG90TmFtZSBtdXRhdGlvbkNhbGxiYWNrIHdpbGwgZmlyZSB3aGVuIG5vZGVzIG9uIHRoZXNlIHNsb3QocykgY2hhbmdlXG4gKiBAcGFyYW0gbXV0YXRpb25DYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZmlyZSB3aGVuZXZlciB0aGUgc2xvdHRlZCBjb250ZW50IGNoYW5nZXNcbiAqL1xuY29uc3QgY3JlYXRlU2xvdE11dGF0aW9uQ29udHJvbGxlciA9IChlbCwgc2xvdE5hbWUsIG11dGF0aW9uQ2FsbGJhY2spID0+IHtcbiAgICBsZXQgaG9zdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgbGV0IHNsb3R0ZWRDb250ZW50TXV0YXRpb25PYnNlcnZlcjtcbiAgICBpZiAod2luICE9PSB1bmRlZmluZWQgJiYgJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbikge1xuICAgICAgICBjb25zdCBzbG90cyA9IEFycmF5LmlzQXJyYXkoc2xvdE5hbWUpID8gc2xvdE5hbWUgOiBbc2xvdE5hbWVdO1xuICAgICAgICBob3N0TXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZW50cnkuYWRkZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBhZGRlZCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAqICBpcyBvdXIgc2xvdHRlZCBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHNsb3RzLmluY2x1ZGVzKG5vZGUuc2xvdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgc28sIHdlIHdhbnQgdG8gd2F0Y2ggdGhlIHNsb3R0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGNvbnRlbnQgaXRzZWxmIGZvciBjaGFuZ2VzLiBUaGlzIGxldHMgdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGRldGVjdCB3aGVuIGNvbnRlbnQgaW5zaWRlIG9mIHRoZSBzbG90IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQWRkaW5nIHRoZSBsaXN0ZW5lciBpbiBhbiByYWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdhaXRzIHVudGlsIFN0ZW5jaWwgbW92ZXMgdGhlIHNsb3R0ZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICogaW50byB0aGUgY29ycmVjdCBwbGFjZSBpbiB0aGUgZXZlbnQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2xvdHRlZCBjb250ZW50IGlzIGJlaW5nIGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICByYWYoKCkgPT4gd2F0Y2hGb3JTbG90Q2hhbmdlKG5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGhvc3RNdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZWwsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBmaXhlcyBhbiBpc3N1ZSB3aXRoIHRoZSBgaW9uLWlucHV0YCBhbmRcbiAgICAgICAgICAgICAqIGBpb24tdGV4dGFyZWFgIG5vdCByZS1yZW5kZXJpbmcgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgICogd2hlbiB1c2luZyB0aGUgbGFiZWwgc2xvdCBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEhUTUwgZWxlbWVudCBwYXRjaGVzIGluIFN0ZW5jaWwgdGhhdCBhcmUgZW5hYmxlZFxuICAgICAgICAgICAgICogYnkgdGhlIGBleHBlcmltZW50YWxTbG90Rml4ZXNgIGZsYWcgaW4gU3RlbmNpbCB2NFxuICAgICAgICAgICAgICogcmVzdWx0IGluIERPTSBtYW5pcHVsYXRpb25zIHRoYXQgd29uJ3QgdHJpZ2dlclxuICAgICAgICAgICAgICogdGhlIGN1cnJlbnQgbXV0YXRpb24gb2JzZXJ2ZXIgY29uZmlndXJhdGlvbiBhbmRcbiAgICAgICAgICAgICAqIGNhbGxiYWNrLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciBjaGFuZ2VzIGluc2lkZSBvZiB0aGUgc2xvdHRlZCBjb250ZW50LlxuICAgICAqIFdlIGNhbiBsaXN0ZW4gZm9yIHN1YnRyZWUgY2hhbmdlcyBoZXJlIHRvIGJlXG4gICAgICogaW5mb3JtZWQgb2YgdGV4dCB3aXRoaW4gdGhlIHNsb3R0ZWQgY29udGVudFxuICAgICAqIGNoYW5naW5nLiBEb2luZyB0aGlzIG9uIHRoZSBob3N0IGlzIHBvc3NpYmxlXG4gICAgICogYnV0IGl0IGlzIG11Y2ggbW9yZSBleHBlbnNpdmUgdG8gZG8gYmVjYXVzZVxuICAgICAqIGl0IGFsc28gbGlzdGVucyBmb3IgY2hhbmdlcyB0byB0aGUgaW50ZXJuYWxzXG4gICAgICogb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjb25zdCB3YXRjaEZvclNsb3RDaGFuZ2UgPSAoc2xvdHRlZEVsKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHNsb3R0ZWRDb250ZW50TXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgc2xvdHRlZENvbnRlbnRNdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHNsb3R0ZWRDb250ZW50TXV0YXRpb25PYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzbG90dGVkQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgbXV0YXRpb25DYWxsYmFjaygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGVudHJ5LnJlbW92ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQgdGhlbiB3ZVxuICAgICAgICAgICAgICAgICAgICAgKiBuZWVkIHRvIGRlc3Ryb3kgdGhlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICogc28gdGhlIGVsZW1lbnQgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG5vZGUuc2xvdCA9PT0gc2xvdE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3lTbG90dGVkQ29udGVudE9ic2VydmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdGVuIGZvciBjaGFuZ2VzIGluc2lkZSBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgKiBhcyB3ZWxsIGFzIGFueXRoaW5nIGRlZXAgaW4gdGhlIHRyZWUuXG4gICAgICAgICAqIFdlIGxpc3RlbiBvbiB0aGUgcGFyZW50RWxlbWVudCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgKiBkZXRlY3Qgd2hlbiBzbG90dGVkIGVsZW1lbnQgaXRzZWxmIGlzIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzbG90dGVkQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSgoX2EgPSBzbG90dGVkRWwucGFyZW50RWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2xvdHRlZEVsLCB7IHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGlmIChob3N0TXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaG9zdE11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgaG9zdE11dGF0aW9uT2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdHJveVNsb3R0ZWRDb250ZW50T2JzZXJ2ZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlc3Ryb3lTbG90dGVkQ29udGVudE9ic2VydmVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoc2xvdHRlZENvbnRlbnRNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICBzbG90dGVkQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgc2xvdHRlZENvbnRlbnRNdXRhdGlvbk9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59O1xuXG5jb25zdCBnZXRDb3VudGVyVGV4dCA9ICh2YWx1ZSwgbWF4TGVuZ3RoLCBjb3VudGVyRm9ybWF0dGVyKSA9PiB7XG4gICAgY29uc3QgdmFsdWVMZW5ndGggPSB2YWx1ZSA9PSBudWxsID8gMCA6IHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgIGNvbnN0IGRlZmF1bHRDb3VudGVyVGV4dCA9IGRlZmF1bHRDb3VudGVyRm9ybWF0dGVyKHZhbHVlTGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIElmIGRldmVsb3BlcnMgZGlkIG5vdCBwYXNzIGEgY3VzdG9tIGZvcm1hdHRlcixcbiAgICAgKiB1c2UgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqL1xuICAgIGlmIChjb3VudGVyRm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb3VudGVyVGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3RoZXJ3aXNlLCB0cnkgdG8gdXNlIHRoZSBjdXN0b20gZm9ybWF0dGVyXG4gICAgICogYW5kIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpZlxuICAgICAqIHRoZXJlIHdhcyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY291bnRlckZvcm1hdHRlcih2YWx1ZUxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJpbnRJb25FcnJvcignRXhjZXB0aW9uIGluIHByb3ZpZGVkIGBjb3VudGVyRm9ybWF0dGVyYC4nLCBlKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb3VudGVyVGV4dDtcbiAgICB9XG59O1xuY29uc3QgZGVmYXVsdENvdW50ZXJGb3JtYXR0ZXIgPSAobGVuZ3RoLCBtYXhsZW5ndGgpID0+IHtcbiAgICByZXR1cm4gYCR7bGVuZ3RofSAvICR7bWF4bGVuZ3RofWA7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVTbG90TXV0YXRpb25Db250cm9sbGVyIGFzIGMsIGdldENvdW50ZXJUZXh0IGFzIGcgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyB3IGFzIHdpbiB9IGZyb20gJy4vaW5kZXgtYTVkNTBkYWYuanMnO1xuaW1wb3J0IHsgciBhcyByYWYgfSBmcm9tICcuL2hlbHBlcnMtNzhlZmVlYzMuanMnO1xuXG4vKipcbiAqIEEgdXRpbGl0eSB0byBjYWxjdWxhdGUgdGhlIHNpemUgb2YgYW4gb3V0bGluZSBub3RjaFxuICogd2lkdGggcmVsYXRpdmUgdG8gdGhlIGNvbnRlbnQgcGFzc2VkLiBUaGlzIGlzIHVzZWQgaW5cbiAqIGNvbXBvbmVudHMgc3VjaCBhcyBgaW9uLXNlbGVjdGAgd2l0aCBgZmlsbD1cIm91dGxpbmVcImBcbiAqIHdoZXJlIHdlIG5lZWQgdG8gcGFzcyBzbG90dGVkIEhUTUwgY29udGVudC4gVGhpcyBpcyBub3RcbiAqIG5lZWRlZCB3aGVuIHJlbmRlcmluZyBwbGFpbnRleHQgY29udGVudCBiZWNhdXNlIHdlIGNhblxuICogcmVuZGVyIHRoZSBwbGFpbnRleHQgYWdhaW4gaGlkZGVuIHdpdGggYG9wYWNpdHk6IDBgIGluc2lkZVxuICogb2YgdGhlIG5vdGNoLiBBcyBhIHJlc3VsdCB3ZSBjYW4gcmVseSBvbiB0aGUgaW50cmluc2ljIHNpemVcbiAqIG9mIHRoZSBlbGVtZW50IHRvIGNvcnJlY3RseSBjb21wdXRlIHRoZSBub3RjaCB3aWR0aC4gV2VcbiAqIGNhbm5vdCBkbyB0aGlzIHdpdGggc2xvdHRlZCBjb250ZW50IGJlY2F1c2Ugd2UgY2Fubm90IHByb2plY3RcbiAqIGl0IGludG8gMiBwbGFjZXMgYXQgb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBlbDogVGhlIGhvc3QgZWxlbWVudFxuICogQHBhcmFtIGdldE5vdGNoU3BhY2VyRWw6IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBub3RjaCBzcGFjZXIgZWxlbWVudCBpbnNpZGUgb2YgdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSBnZXRMYWJlbFNsb3Q6IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzbG90dGVkIGNvbnRlbnQuXG4gKi9cbmNvbnN0IGNyZWF0ZU5vdGNoQ29udHJvbGxlciA9IChlbCwgZ2V0Tm90Y2hTcGFjZXJFbCwgZ2V0TGFiZWxTbG90KSA9PiB7XG4gICAgbGV0IG5vdGNoVmlzaWJpbGl0eUlPO1xuICAgIGNvbnN0IG5lZWRzRXhwbGljaXROb3RjaFdpZHRoID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBub3RjaFNwYWNlckVsID0gZ2V0Tm90Y2hTcGFjZXJFbCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgbm90Y2ggaXMgbm90IGJlaW5nIHVzZWRcbiAgICAgICAgICogdGhlbiB3ZSBkbyBub3QgbmVlZCB0byBzZXQgdGhlIG5vdGNoIHdpZHRoLlxuICAgICAgICAgKi9cbiAgICAgICAgbm90Y2hTcGFjZXJFbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIGVpdGhlciB0aGUgbGFiZWwgcHJvcGVydHkgaXMgYmVpbmdcbiAgICAgICAgICAgICAqIHVzZWQgb3IgdGhlIGxhYmVsIHNsb3QgaXMgbm90IGRlZmluZWQsXG4gICAgICAgICAgICAgKiB0aGVuIHdlIGRvIG5vdCBuZWVkIHRvIGVzdGltYXRlIHRoZSBub3RjaCB3aWR0aC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWwubGFiZWwgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgZ2V0TGFiZWxTbG90KCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbGN1bGF0ZU5vdGNoV2lkdGggPSAoKSA9PiB7XG4gICAgICAgIGlmIChuZWVkc0V4cGxpY2l0Tm90Y2hXaWR0aCgpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJ1biB0aGlzIHRoZSBmcmFtZSBhZnRlclxuICAgICAgICAgICAgICogdGhlIGJyb3dzZXIgaGFzIHJlLXBhaW50ZWQgdGhlIGhvc3QgZWxlbWVudC5cbiAgICAgICAgICAgICAqIE90aGVyd2lzZSwgdGhlIGxhYmVsIGVsZW1lbnQgbWF5IGhhdmUgYSB3aWR0aFxuICAgICAgICAgICAgICogb2YgMCBhbmQgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmFmKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXROb3RjaFdpZHRoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyBhIGxhYmVsIHByb3Agd2UgY2FuIHJlbmRlclxuICAgICAqIHRoZSBsYWJlbCB2YWx1ZSBpbnNpZGUgb2YgdGhlIG5vdGNoIGFuZFxuICAgICAqIGxldCB0aGUgYnJvd3NlciBjYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhlIG5vdGNoLlxuICAgICAqIEhvd2V2ZXIsIHdlIGNhbm5vdCByZW5kZXIgdGhlIGxhYmVsIHNsb3QgaW4gbXVsdGlwbGVcbiAgICAgKiBwbGFjZXMgc28gd2UgbmVlZCB0byBtYW51YWxseSBjYWxjdWxhdGUgdGhlIG5vdGNoIGRpbWVuc2lvblxuICAgICAqIGJhc2VkIG9uIHRoZSBzaXplIG9mIHRoZSBzbG90dGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gc2V0IHRoZSBub3RjaCB3aWR0aFxuICAgICAqIG9uIHNsb3R0ZWQgbGFiZWwgY29udGVudC4gVGhlIG5vdGNoIHdpZHRoIGZvciBsYWJlbCBwcm9wXG4gICAgICogY29udGVudCBpcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlXG4gICAgICogaW50cmluc2ljIHNpemUgb2YgdGhlIGxhYmVsIHRleHQuXG4gICAgICovXG4gICAgY29uc3Qgc2V0Tm90Y2hXaWR0aCA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm90Y2hTcGFjZXJFbCA9IGdldE5vdGNoU3BhY2VyRWwoKTtcbiAgICAgICAgaWYgKG5vdGNoU3BhY2VyRWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmVlZHNFeHBsaWNpdE5vdGNoV2lkdGgoKSkge1xuICAgICAgICAgICAgbm90Y2hTcGFjZXJFbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnd2lkdGgnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aCA9IGdldExhYmVsU2xvdCgpLnNjcm9sbFdpZHRoO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgY29tcHV0ZWQgd2lkdGggb2YgdGhlIGxhYmVsIGlzIDBcbiAgICAgICAgICogYW5kIG5vdGNoU3BhY2VyRWwncyBvZmZzZXRQYXJlbnQgaXMgbnVsbFxuICAgICAgICAgKiB0aGVuIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXMgaGlkZGVuLlxuICAgICAgICAgKiBBcyBhIHJlc3VsdCwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgZWxlbWVudFxuICAgICAgICAgKiB0byBiZWNvbWUgdmlzaWJsZSBiZWZvcmUgc2V0dGluZyB0aGUgbm90Y2ggd2lkdGguXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIGRvIG5vdCBjaGVjayBlbC5vZmZzZXRQYXJlbnQgYmVjYXVzZVxuICAgICAgICAgKiB0aGF0IGNhbiBiZSBudWxsIGlmIHRoZSBob3N0IGVsZW1lbnQgaGFzXG4gICAgICAgICAqIHBvc2l0aW9uOiBmaXhlZCBhcHBsaWVkIHRvIGl0LlxuICAgICAgICAgKiBub3RjaFNwYWNlckVsIGRvZXMgbm90IGhhdmUgcG9zaXRpb246IGZpeGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgd2lkdGggPT09IDAgJiZcbiAgICAgICAgICAgIG5vdGNoU3BhY2VyRWwub2Zmc2V0UGFyZW50ID09PSBudWxsICYmXG4gICAgICAgICAgICB3aW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBpbiB3aW4pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUgaXMgYW4gSU8gYWxyZWFkeSBhdHRhY2hlZFxuICAgICAgICAgICAgICogdGhlbiB0aGF0IHdpbGwgdXBkYXRlIHRoZSBub3RjaFxuICAgICAgICAgICAgICogb25jZSB0aGUgZWxlbWVudCBiZWNvbWVzIHZpc2libGUuXG4gICAgICAgICAgICAgKiBBcyBhIHJlc3VsdCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGVcbiAgICAgICAgICAgICAqIGFub3RoZXIgb25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobm90Y2hWaXNpYmlsaXR5SU8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlvID0gKG5vdGNoVmlzaWJpbGl0eUlPID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChldikgPT4ge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBlbGVtZW50IGlzIHZpc2libGUgdGhlbiB3ZVxuICAgICAgICAgICAgICAgICAqIGNhbiB0cnkgc2V0dGluZyB0aGUgbm90Y2ggd2lkdGggYWdhaW4uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGV2WzBdLmludGVyc2VjdGlvblJhdGlvID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE5vdGNoV2lkdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgaW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBub3RjaFZpc2liaWxpdHlJTyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSByb290IHRvIGJlIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAqIFRoaXMgY2F1c2VzIHRoZSBJTyBjYWxsYmFja1xuICAgICAgICAgICAgICogdG8gYmUgZmlyZWQgaW4gV2ViS2l0IGFzIHNvb24gYXMgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAqIGlzIHZpc2libGUuIElmIHdlIHVzZWQgdGhlIGRlZmF1bHQgcm9vdCB2YWx1ZVxuICAgICAgICAgICAgICogdGhlbiBXZWJLaXQgd291bGQgb25seSBmaXJlIHRoZSBJTyBjYWxsYmFja1xuICAgICAgICAgICAgICogYWZ0ZXIgYW55IGFuaW1hdGlvbnMgKHN1Y2ggYXMgYSBtb2RhbCB0cmFuc2l0aW9uKVxuICAgICAgICAgICAgICogZmluaXNoZWQsIGFuZCB0aGVyZSB3b3VsZCBwb3RlbnRpYWxseSBiZSBhIGZsaWNrZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHsgdGhyZXNob2xkOiAwLjAxLCByb290OiBlbCB9KSk7XG4gICAgICAgICAgICBpby5vYnNlcnZlKG5vdGNoU3BhY2VyRWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIHRoZW4gd2UgY2FuIHNldCB0aGUgbm90Y2ggd2lkdGguXG4gICAgICAgICAqIFRoZSBub3RjaCBpcyBvbmx5IHZpc2libGUgd2hlbiB0aGUgbGFiZWwgaXMgc2NhbGVkLFxuICAgICAgICAgKiB3aGljaCBpcyB3aHkgd2UgbXVsdGlwbHkgdGhlIHdpZHRoIGJ5IDAuNzUgYXMgdGhpcyBpc1xuICAgICAgICAgKiB0aGUgc2FtZSBhbW91bnQgdGhlIGxhYmVsIGVsZW1lbnQgaXMgc2NhbGVkIGJ5IGluIHRoZSBob3N0IENTUy5cbiAgICAgICAgICogKFNlZSAkZm9ybS1jb250cm9sLWxhYmVsLXN0YWNrZWQtc2NhbGUgaW4gaW9uaWMuZ2xvYmFscy5zY3NzKS5cbiAgICAgICAgICovXG4gICAgICAgIG5vdGNoU3BhY2VyRWwuc3R5bGUuc2V0UHJvcGVydHkoJ3dpZHRoJywgYCR7d2lkdGggKiAwLjc1fXB4YCk7XG4gICAgfTtcbiAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICBpZiAobm90Y2hWaXNpYmlsaXR5SU8pIHtcbiAgICAgICAgICAgIG5vdGNoVmlzaWJpbGl0eUlPLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIG5vdGNoVmlzaWJpbGl0eUlPID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWxjdWxhdGVOb3RjaFdpZHRoLFxuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59O1xuXG5leHBvcnQgeyBjcmVhdGVOb3RjaENvbnRyb2xsZXIgYXMgYyB9O1xuIl0sIm5hbWVzIjpbInciLCJ3aW4iLCJyIiwicmFmIiwiYSIsInByaW50SW9uRXJyb3IiLCJjcmVhdGVTbG90TXV0YXRpb25Db250cm9sbGVyIiwiZWwiLCJzbG90TmFtZSIsIm11dGF0aW9uQ2FsbGJhY2siLCJob3N0TXV0YXRpb25PYnNlcnZlciIsInNsb3R0ZWRDb250ZW50TXV0YXRpb25PYnNlcnZlciIsInVuZGVmaW5lZCIsInNsb3RzIiwiQXJyYXkiLCJpc0FycmF5IiwiTXV0YXRpb25PYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsIm5vZGUiLCJhZGRlZE5vZGVzIiwibm9kZVR5cGUiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwiaW5jbHVkZXMiLCJzbG90Iiwid2F0Y2hGb3JTbG90Q2hhbmdlIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJzbG90dGVkRWwiLCJfYSIsImRpc2Nvbm5lY3QiLCJyZW1vdmVkTm9kZXMiLCJkZXN0cm95U2xvdHRlZENvbnRlbnRPYnNlcnZlciIsInBhcmVudEVsZW1lbnQiLCJkZXN0cm95IiwiZ2V0Q291bnRlclRleHQiLCJ2YWx1ZSIsIm1heExlbmd0aCIsImNvdW50ZXJGb3JtYXR0ZXIiLCJ2YWx1ZUxlbmd0aCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiZGVmYXVsdENvdW50ZXJUZXh0IiwiZGVmYXVsdENvdW50ZXJGb3JtYXR0ZXIiLCJlIiwibWF4bGVuZ3RoIiwiYyIsImciLCJjcmVhdGVOb3RjaENvbnRyb2xsZXIiLCJnZXROb3RjaFNwYWNlckVsIiwiZ2V0TGFiZWxTbG90Iiwibm90Y2hWaXNpYmlsaXR5SU8iLCJuZWVkc0V4cGxpY2l0Tm90Y2hXaWR0aCIsIm5vdGNoU3BhY2VyRWwiLCJsYWJlbCIsImNhbGN1bGF0ZU5vdGNoV2lkdGgiLCJzZXROb3RjaFdpZHRoIiwic3R5bGUiLCJyZW1vdmVQcm9wZXJ0eSIsIndpZHRoIiwic2Nyb2xsV2lkdGgiLCJvZmZzZXRQYXJlbnQiLCJpbyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZXYiLCJpbnRlcnNlY3Rpb25SYXRpbyIsInRocmVzaG9sZCIsInJvb3QiLCJzZXRQcm9wZXJ0eSJdLCJzb3VyY2VSb290Ijoid2VicGFjazovLy8iLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxXX0=