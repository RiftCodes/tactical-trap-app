"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ionic_core_dist_esm_input-shims-C3lNp93k_js"],{

/***/ 4953:
/*!*******************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/input-shims-C3lNp93k.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startInputShims: () => (/* binding */ startInputShims)
/* harmony export */ });
/* harmony import */ var C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 9204);
/* harmony import */ var _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-ZjP4CjeZ.js */ 575);
/* harmony import */ var _index_BlJTBdxG_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-BlJTBdxG.js */ 4898);
/* harmony import */ var _helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers-1O4D2b7y.js */ 450);
/* harmony import */ var _keyboard_CUw4ekVy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keyboard-CUw4ekVy.js */ 2954);
/* harmony import */ var _index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-B_U9CtaY.js */ 4917);
/* harmony import */ var _capacitor_CFERIeaU_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./capacitor-CFERIeaU.js */ 5051);

/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */






const cloneMap = new WeakMap();
const relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0, disabledClonedInput = false) => {
  if (cloneMap.has(componentEl) === shouldRelocate) {
    return;
  }
  if (shouldRelocate) {
    addClone(componentEl, inputEl, inputRelativeY, disabledClonedInput);
  } else {
    removeClone(componentEl, inputEl);
  }
};
const isFocused = input => {
  /**
   * https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode
   * Calling getRootNode on an element in standard web page will return HTMLDocument.
   * Calling getRootNode on an element inside of the Shadow DOM will return the associated ShadowRoot.
   * Calling getRootNode on an element that is not attached to a document/shadow tree will return
   * the root of the DOM tree it belongs to.
   * isFocused is used for the hide-caret utility which only considers input/textarea elements
   * that are present in the DOM, so we don't set types for that final case since it does not apply.
   */
  return input === input.getRootNode().activeElement;
};
const addClone = (componentEl, inputEl, inputRelativeY, disabledClonedInput = false) => {
  // this allows for the actual input to receive the focus from
  // the user's touch event, but before it receives focus, it
  // moves the actual input to a location that will not screw
  // up the app's layout, and does not allow the native browser
  // to attempt to scroll the input into place (messing up headers/footers)
  // the cloned input fills the area of where native input should be
  // while the native input fakes out the browser by relocating itself
  // before it receives the actual focus event
  // We hide the focused input (with the visible caret) invisible by making it scale(0),
  const parentEl = inputEl.parentNode;
  // DOM WRITES
  const clonedEl = inputEl.cloneNode(false);
  clonedEl.classList.add('cloned-input');
  clonedEl.tabIndex = -1;
  /**
   * Making the cloned input disabled prevents
   * Chrome for Android from still scrolling
   * the entire page since this cloned input
   * will briefly be hidden by the keyboard
   * even though it is not focused.
   *
   * This is not needed on iOS. While this
   * does not cause functional issues on iOS,
   * the input still appears slightly dimmed even
   * if we set opacity: 1.
   */
  if (disabledClonedInput) {
    clonedEl.disabled = true;
  }
  parentEl.appendChild(clonedEl);
  cloneMap.set(componentEl, clonedEl);
  const doc = componentEl.ownerDocument;
  const tx = doc.dir === 'rtl' ? 9999 : -9999;
  componentEl.style.pointerEvents = 'none';
  inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;
};
const removeClone = (componentEl, inputEl) => {
  const clone = cloneMap.get(componentEl);
  if (clone) {
    cloneMap.delete(componentEl);
    clone.remove();
  }
  componentEl.style.pointerEvents = '';
  inputEl.style.transform = '';
};
/**
 * Factoring in 50px gives us some room
 * in case the keyboard shows password/autofill bars
 * asynchronously.
 */
const SCROLL_AMOUNT_PADDING = 50;
const enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {
  if (!scrollEl || !inputEl) {
    return () => {
      return;
    };
  }
  const scrollHideCaret = shouldHideCaret => {
    if (isFocused(inputEl)) {
      relocateInput(componentEl, inputEl, shouldHideCaret);
    }
  };
  const onBlur = () => relocateInput(componentEl, inputEl, false);
  const hideCaret = () => scrollHideCaret(true);
  const showCaret = () => scrollHideCaret(false);
  (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.f)(scrollEl, 'ionScrollStart', hideCaret);
  (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.f)(scrollEl, 'ionScrollEnd', showCaret);
  inputEl.addEventListener('blur', onBlur);
  return () => {
    (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.m)(scrollEl, 'ionScrollStart', hideCaret);
    (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.m)(scrollEl, 'ionScrollEnd', showCaret);
    inputEl.removeEventListener('blur', onBlur);
  };
};
const SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';
const enableInputBlurring = () => {
  let focused = true;
  let didScroll = false;
  const doc = document;
  const onScroll = () => {
    didScroll = true;
  };
  const onFocusin = () => {
    focused = true;
  };
  const onTouchend = ev => {
    // if app did scroll return early
    if (didScroll) {
      didScroll = false;
      return;
    }
    const active = doc.activeElement;
    if (!active) {
      return;
    }
    // only blur if the active element is a text-input or a textarea
    if (active.matches(SKIP_SELECTOR)) {
      return;
    }
    // if the selected target is the active element, do not blur
    const tapped = ev.target;
    if (tapped === active) {
      return;
    }
    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {
      return;
    }
    focused = false;
    // TODO FW-2796: find a better way, why 50ms?
    setTimeout(() => {
      if (!focused) {
        active.blur();
      }
    }, 50);
  };
  (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.f)(doc, 'ionScrollStart', onScroll);
  doc.addEventListener('focusin', onFocusin, true);
  doc.addEventListener('touchend', onTouchend, false);
  return () => {
    (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.m)(doc, 'ionScrollStart', onScroll, true);
    doc.removeEventListener('focusin', onFocusin, true);
    doc.removeEventListener('touchend', onTouchend, false);
  };
};
const SCROLL_ASSIST_SPEED = 0.3;
const getScrollData = (componentEl, contentEl, keyboardHeight, platformHeight) => {
  var _a;
  const itemEl = (_a = componentEl.closest('ion-item,[ion-item]')) !== null && _a !== void 0 ? _a : componentEl;
  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, platformHeight);
};
const calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {
  // compute input's Y values relative to the body
  const inputTop = inputRect.top;
  const inputBottom = inputRect.bottom;
  // compute visible area
  const visibleAreaTop = contentRect.top;
  const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);
  // compute safe area
  const safeAreaTop = visibleAreaTop + 15;
  const safeAreaBottom = visibleAreaBottom - SCROLL_AMOUNT_PADDING;
  // figure out if each edge of the input is within the safe area
  const distanceToBottom = safeAreaBottom - inputBottom;
  const distanceToTop = safeAreaTop - inputTop;
  // desiredScrollAmount is the negated distance to the safe area according to our calculations.
  const desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0);
  // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input
  // gets focus, so make sure we don't scroll the input above the visible area
  const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);
  const distance = Math.abs(scrollAmount);
  const duration = distance / SCROLL_ASSIST_SPEED;
  const scrollDuration = Math.min(400, Math.max(150, duration));
  return {
    scrollAmount,
    scrollDuration,
    scrollPadding: keyboardHeight,
    inputSafeY: -(inputTop - safeAreaTop) + 4
  };
};
const PADDING_TIMER_KEY = '$ionPaddingTimer';
/**
 * Scroll padding adds additional padding to the bottom
 * of ion-content so that there is enough scroll space
 * for an input to be scrolled above the keyboard. This
 * is needed in environments where the webview does not
 * resize when the keyboard opens.
 *
 * Example: If an input at the bottom of ion-content is
 * focused, there is no additional scrolling space below
 * it, so the input cannot be scrolled above the keyboard.
 * Scroll padding fixes this by adding padding equal to the
 * height of the keyboard to the bottom of the content.
 *
 * Common environments where this is needed:
 * - Mobile Safari: The keyboard overlays the content
 * - Capacitor/Cordova on iOS: The keyboard overlays the content
 * when the KeyboardResize mode is set to 'none'.
 */
const setScrollPadding = (contentEl, paddingAmount, clearCallback) => {
  const timer = contentEl[PADDING_TIMER_KEY];
  if (timer) {
    clearTimeout(timer);
  }
  if (paddingAmount > 0) {
    contentEl.style.setProperty('--keyboard-offset', `${paddingAmount}px`);
  } else {
    contentEl[PADDING_TIMER_KEY] = setTimeout(() => {
      contentEl.style.setProperty('--keyboard-offset', '0px');
      if (clearCallback) {
        clearCallback();
      }
    }, 120);
  }
};
/**
 * When an input is about to be focused,
 * set a timeout to clear any scroll padding
 * on the content. Note: The clearing
 * is done on a timeout so that if users
 * are moving focus from one input to the next
 * then re-adding scroll padding to the new
 * input with cancel the timeout to clear the
 * scroll padding.
 */
const setClearScrollPaddingListener = (inputEl, contentEl, doneCallback) => {
  const clearScrollPadding = () => {
    if (contentEl) {
      setScrollPadding(contentEl, 0, doneCallback);
    }
  };
  inputEl.addEventListener('focusout', clearScrollPadding, {
    once: true
  });
};
let currentPadding = 0;
const SKIP_SCROLL_ASSIST = 'data-ionic-skip-scroll-assist';
const enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, keyboardResize, disableClonedInput = false) => {
  /**
   * Scroll padding should only be added if:
   * 1. The global scrollPadding config option
   * is set to true.
   * 2. The native keyboard resize mode is either "none"
   * (keyboard overlays webview) or undefined (resize
   * information unavailable)
   * Resize info is available on Capacitor 4+
   */
  const addScrollPadding = enableScrollPadding && (keyboardResize === undefined || keyboardResize.mode === _keyboard_CUw4ekVy_js__WEBPACK_IMPORTED_MODULE_4__.a.None);
  /**
   * This tracks whether or not the keyboard has been
   * presented for a single focused text field. Note
   * that it does not track if the keyboard is open
   * in general such as if the keyboard is open for
   * a different focused text field.
   */
  let hasKeyboardBeenPresentedForTextField = false;
  /**
   * When adding scroll padding we need to know
   * how much of the viewport the keyboard obscures.
   * We do this by subtracting the keyboard height
   * from the platform height.
   *
   * If we compute this value when switching between
   * inputs then the webview may already be resized.
   * At this point, `win.innerHeight` has already accounted
   * for the keyboard meaning we would then subtract
   * the keyboard height again. This will result in the input
   * being scrolled more than it needs to.
   */
  const platformHeight = _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w !== undefined ? _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w.innerHeight : 0;
  /**
   * Scroll assist is run when a text field
   * is focused. However, it may need to
   * re-run when the keyboard size changes
   * such that the text field is now hidden
   * underneath the keyboard.
   * This function re-runs scroll assist
   * when that happens.
   *
   * One limitation of this is on a web browser
   * where native keyboard APIs do not have cross-browser
   * support. `ionKeyboardDidShow` relies on the Visual Viewport API.
   * This means that if the keyboard changes but does not change
   * geometry, then scroll assist will not re-run even if
   * the user has scrolled the text field under the keyboard.
   * This is not a problem when running in Cordova/Capacitor
   * because `ionKeyboardDidShow` uses the native events
   * which fire every time the keyboard changes.
   */
  const keyboardShow = ev => {
    /**
     * If the keyboard has not yet been presented
     * for this text field then the text field has just
     * received focus. In that case, the focusin listener
     * will run scroll assist.
     */
    if (hasKeyboardBeenPresentedForTextField === false) {
      hasKeyboardBeenPresentedForTextField = true;
      return;
    }
    /**
     * Otherwise, the keyboard has already been presented
     * for the focused text field.
     * This means that the keyboard likely changed
     * geometry, and we need to re-run scroll assist.
     * This can happen when the user rotates their device
     * or when they switch keyboards.
     *
     * Make sure we pass in the computed keyboard height
     * rather than the estimated keyboard height.
     *
     * Since the keyboard is already open then we do not
     * need to wait for the webview to resize, so we pass
     * "waitForResize: false".
     */
    jsSetFocus(componentEl, inputEl, contentEl, footerEl, ev.detail.keyboardHeight, addScrollPadding, disableClonedInput, platformHeight, false);
  };
  /**
   * Reset the internal state when the text field loses focus.
   */
  const focusOut = () => {
    hasKeyboardBeenPresentedForTextField = false;
    _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w === null || _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w === void 0 ? void 0 : _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w.removeEventListener('ionKeyboardDidShow', keyboardShow);
    componentEl.removeEventListener('focusout', focusOut);
  };
  /**
   * When the input is about to receive
   * focus, we need to move it to prevent
   * mobile Safari from adjusting the viewport.
   */
  const focusIn = /*#__PURE__*/function () {
    var _ref = (0,C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      /**
       * Scroll assist should not run again
       * on inputs that have been manually
       * focused inside of the scroll assist
       * implementation.
       */
      if (inputEl.hasAttribute(SKIP_SCROLL_ASSIST)) {
        inputEl.removeAttribute(SKIP_SCROLL_ASSIST);
        return;
      }
      jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight, addScrollPadding, disableClonedInput, platformHeight);
      _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w === null || _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w === void 0 ? void 0 : _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w.addEventListener('ionKeyboardDidShow', keyboardShow);
      componentEl.addEventListener('focusout', focusOut);
    });
    return function focusIn() {
      return _ref.apply(this, arguments);
    };
  }();
  componentEl.addEventListener('focusin', focusIn);
  return () => {
    componentEl.removeEventListener('focusin', focusIn);
    _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w === null || _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w === void 0 ? void 0 : _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.w.removeEventListener('ionKeyboardDidShow', keyboardShow);
    componentEl.removeEventListener('focusout', focusOut);
  };
};
/**
 * Use this function when you want to manually
 * focus an input but not have scroll assist run again.
 */
const setManualFocus = el => {
  var _a;
  /**
   * If element is already focused then
   * a new focusin event will not be dispatched
   * to remove the SKIL_SCROLL_ASSIST attribute.
   */
  if (document.activeElement === el) {
    return;
  }
  /**
   * Optimization for scenarios where the currently focused element is a sibling
   * of the target element. In such cases, we avoid setting `SKIP_SCROLL_ASSIST`.
   *
   * This is crucial for accessibility: input elements can now contain focusable
   * siblings (e.g., clear buttons, slotted elements). If we didn't skip setting
   * the attribute here, screen readers would be unable to navigate to and interact
   * with these sibling elements.
   *
   * Without this check, we would need to call `ev.stopPropagation()` on the
   * 'focusin' event of each focusable sibling to prevent the scroll assist
   * listener from incorrectly moving focus back to the input. That approach
   * would be less maintainable and more error-prone.
   */
  const inputId = el.getAttribute('id');
  const label = el.closest(`label[for="${inputId}"]`);
  const activeElLabel = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest(`label[for="${inputId}"]`);
  if (label !== null && label === activeElLabel) {
    // If the label is the same as the active element label, then
    // we don't need to set the `SKIP_SCROLL_ASSIST` and reset focus.
    return;
  }
  el.setAttribute(SKIP_SCROLL_ASSIST, 'true');
  el.focus();
};
const jsSetFocus = /*#__PURE__*/function () {
  var _ref2 = (0,C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, disableClonedInput = false, platformHeight = 0, waitForResize = true) {
    if (!contentEl && !footerEl) {
      return;
    }
    const scrollData = getScrollData(componentEl, contentEl || footerEl, keyboardHeight, platformHeight);
    if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {
      // the text input is in a safe position that doesn't
      // require it to be scrolled into view, just set focus now
      setManualFocus(inputEl);
      /**
       * Even though the input does not need
       * scroll assist, we should preserve the
       * the scroll padding as users could be moving
       * focus from an input that needs scroll padding
       * to an input that does not need scroll padding.
       * If we remove the scroll padding now, users will
       * see the page jump.
       */
      if (enableScrollPadding && contentEl !== null) {
        setScrollPadding(contentEl, currentPadding);
        setClearScrollPaddingListener(inputEl, contentEl, () => currentPadding = 0);
      }
      return;
    }
    // temporarily move the focus to the focus holder so the browser
    // doesn't freak out while it's trying to get the input in place
    // at this point the native text input still does not have focus
    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY, disableClonedInput);
    setManualFocus(inputEl);
    /**
     * Relocating/Focusing input causes the
     * click event to be cancelled, so
     * manually fire one here.
     */
    (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.r)(() => componentEl.click());
    /**
     * If enabled, we can add scroll padding to
     * the bottom of the content so that scroll assist
     * has enough room to scroll the input above
     * the keyboard.
     */
    if (enableScrollPadding && contentEl) {
      currentPadding = scrollData.scrollPadding;
      setScrollPadding(contentEl, currentPadding);
    }
    if (typeof window !== 'undefined') {
      let scrollContentTimeout;
      const _scrollContent = /*#__PURE__*/function () {
        var _ref3 = (0,C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
          // clean up listeners and timeouts
          if (scrollContentTimeout !== undefined) {
            clearTimeout(scrollContentTimeout);
          }
          window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
          window.removeEventListener('ionKeyboardDidShow', _scrollContent);
          // scroll the input into place
          if (contentEl) {
            yield (0,_index_BlJTBdxG_js__WEBPACK_IMPORTED_MODULE_2__.c)(contentEl, 0, scrollData.scrollAmount, scrollData.scrollDuration);
          }
          // the scroll view is in the correct position now
          // give the native text input focus
          relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);
          // ensure this is the focused input
          setManualFocus(inputEl);
          /**
           * When the input is about to be blurred
           * we should set a timeout to remove
           * any scroll padding.
           */
          if (enableScrollPadding) {
            setClearScrollPaddingListener(inputEl, contentEl, () => currentPadding = 0);
          }
        });
        return function scrollContent() {
          return _ref3.apply(this, arguments);
        };
      }();
      const doubleKeyboardEventListener = () => {
        window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
        window.addEventListener('ionKeyboardDidShow', _scrollContent);
      };
      if (contentEl) {
        const scrollEl = yield (0,_index_BlJTBdxG_js__WEBPACK_IMPORTED_MODULE_2__.g)(contentEl);
        /**
         * scrollData will only consider the amount we need
         * to scroll in order to properly bring the input
         * into view. It will not consider the amount
         * we can scroll in the content element.
         * As a result, scrollData may request a greater
         * scroll position than is currently available
         * in the DOM. If this is the case, we need to
         * wait for the webview to resize/the keyboard
         * to show in order for additional scroll
         * bandwidth to become available.
         */
        const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;
        if (waitForResize && scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop) {
          /**
           * On iOS devices, the system will show a "Passwords" bar above the keyboard
           * after the initial keyboard is shown. This prevents the webview from resizing
           * until the "Passwords" bar is shown, so we need to wait for that to happen first.
           */
          if (inputEl.type === 'password') {
            // Add 50px to account for the "Passwords" bar
            scrollData.scrollAmount += SCROLL_AMOUNT_PADDING;
            window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
          } else {
            window.addEventListener('ionKeyboardDidShow', _scrollContent);
          }
          /**
           * This should only fire in 2 instances:
           * 1. The app is very slow.
           * 2. The app is running in a browser on an old OS
           * that does not support Ionic Keyboard Events
           */
          scrollContentTimeout = setTimeout(_scrollContent, 1000);
          return;
        }
      }
      _scrollContent();
    }
  });
  return function jsSetFocus(_x, _x2, _x3, _x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();
const INPUT_BLURRING = true;
const startInputShims = /*#__PURE__*/function () {
  var _ref4 = (0,C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (config, platform) {
    /**
     * If doc is undefined then we are in an SSR environment
     * where input shims do not apply.
     */
    if (_index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.d === undefined) {
      return;
    }
    const isIOS = platform === 'ios';
    const isAndroid = platform === 'android';
    /**
     * Hide Caret and Input Blurring are needed on iOS.
     * Scroll Assist and Scroll Padding are needed on iOS and Android
     * with Chrome web browser (not Chrome webview).
     */
    const keyboardHeight = config.getNumber('keyboardHeight', 290);
    const scrollAssist = config.getBoolean('scrollAssist', true);
    const hideCaret = config.getBoolean('hideCaretOnScroll', isIOS);
    /**
     * The team is evaluating if inputBlurring is still needed. As a result
     * this feature is disabled by default as of Ionic 8.0. Developers are
     * able to re-enable it temporarily. The team may remove this utility
     * if it is determined that doing so would not bring any adverse side effects.
     * TODO FW-6014 remove input blurring utility (including implementation)
     */
    const inputBlurring = config.getBoolean('inputBlurring', false);
    const scrollPadding = config.getBoolean('scrollPadding', true);
    const inputs = Array.from(_index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.d.querySelectorAll('ion-input, ion-textarea'));
    const hideCaretMap = new WeakMap();
    const scrollAssistMap = new WeakMap();
    /**
     * Grab the native keyboard resize configuration
     * and pass it to scroll assist. Scroll assist requires
     * that we adjust the input right before the input
     * is about to be focused. If we called `Keyboard.getResizeMode`
     * on focusin in scroll assist, we could potentially adjust the
     * input too late since this call is async.
     */
    const keyboardResizeMode = yield _keyboard_CUw4ekVy_js__WEBPACK_IMPORTED_MODULE_4__.K.getResizeMode();
    const registerInput = /*#__PURE__*/function () {
      var _ref5 = (0,C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (componentEl) {
        yield new Promise(resolve => (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.c)(componentEl, resolve));
        const inputRoot = componentEl.shadowRoot || componentEl;
        const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');
        const scrollEl = (0,_index_BlJTBdxG_js__WEBPACK_IMPORTED_MODULE_2__.f)(componentEl);
        const footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;
        if (!inputEl) {
          return;
        }
        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {
          const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);
          hideCaretMap.set(componentEl, rmFn);
        }
        /**
         * date/datetime-locale inputs on mobile devices show date picker
         * overlays instead of keyboards. As a result, scroll assist is
         * not needed. This also works around a bug in iOS <16 where
         * scroll assist causes the browser to lock up. See FW-1997.
         */
        const isDateInput = inputEl.type === 'date' || inputEl.type === 'datetime-local';
        if (!isDateInput && (!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {
          const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight, scrollPadding, keyboardResizeMode, isAndroid);
          scrollAssistMap.set(componentEl, rmFn);
        }
      });
      return function registerInput(_x9) {
        return _ref5.apply(this, arguments);
      };
    }();
    const unregisterInput = componentEl => {
      if (hideCaret) {
        const fn = hideCaretMap.get(componentEl);
        if (fn) {
          fn();
        }
        hideCaretMap.delete(componentEl);
      }
      if (scrollAssist) {
        const fn = scrollAssistMap.get(componentEl);
        if (fn) {
          fn();
        }
        scrollAssistMap.delete(componentEl);
      }
    };
    if (inputBlurring && INPUT_BLURRING) {
      enableInputBlurring();
    }
    // Input might be already loaded in the DOM before ion-device-hacks did.
    // At this point we need to look for all of the inputs not registered yet
    // and register them.
    for (const input of inputs) {
      registerInput(input);
    }
    _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.d.addEventListener('ionInputDidLoad', ev => {
      registerInput(ev.detail);
    });
    _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_1__.d.addEventListener('ionInputDidUnload', ev => {
      unregisterInput(ev.detail);
    });
  });
  return function startInputShims(_x7, _x8) {
    return _ref4.apply(this, arguments);
  };
}();


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW5wdXQtc2hpbXMtQzNsTnA5M2tfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3lEO0FBQ21EO0FBQ2E7QUFDN0M7QUFDL0M7QUFDSTtBQUVqQyxNQUFNb0IsUUFBUSxHQUFHLElBQUlDLE9BQU8sQ0FBQyxDQUFDO0FBQzlCLE1BQU1DLGFBQWEsR0FBR0EsQ0FBQ0MsV0FBVyxFQUFFQyxPQUFPLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxHQUFHLENBQUMsRUFBRUMsbUJBQW1CLEdBQUcsS0FBSyxLQUFLO0VBQzdHLElBQUlQLFFBQVEsQ0FBQ1EsR0FBRyxDQUFDTCxXQUFXLENBQUMsS0FBS0UsY0FBYyxFQUFFO0lBQzlDO0VBQ0o7RUFDQSxJQUFJQSxjQUFjLEVBQUU7SUFDaEJJLFFBQVEsQ0FBQ04sV0FBVyxFQUFFQyxPQUFPLEVBQUVFLGNBQWMsRUFBRUMsbUJBQW1CLENBQUM7RUFDdkUsQ0FBQyxNQUNJO0lBQ0RHLFdBQVcsQ0FBQ1AsV0FBVyxFQUFFQyxPQUFPLENBQUM7RUFDckM7QUFDSixDQUFDO0FBQ0QsTUFBTU8sU0FBUyxHQUFJQyxLQUFLLElBQUs7RUFDekI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksT0FBT0EsS0FBSyxLQUFLQSxLQUFLLENBQUNDLFdBQVcsQ0FBQyxDQUFDLENBQUNDLGFBQWE7QUFDdEQsQ0FBQztBQUNELE1BQU1MLFFBQVEsR0FBR0EsQ0FBQ04sV0FBVyxFQUFFQyxPQUFPLEVBQUVFLGNBQWMsRUFBRUMsbUJBQW1CLEdBQUcsS0FBSyxLQUFLO0VBQ3BGO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLE1BQU1RLFFBQVEsR0FBR1gsT0FBTyxDQUFDWSxVQUFVO0VBQ25DO0VBQ0EsTUFBTUMsUUFBUSxHQUFHYixPQUFPLENBQUNjLFNBQVMsQ0FB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QUNKLENBQUM7SUFDRCxJQUFJa0ssYUFBYSxJQUFJVixjQUFjLEVBQUU7TUFDakMvRyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3pCO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsS0FBSyxNQUFNaEMsS0FBSyxJQUFJMEosTUFBTSxFQUFFO01BQ3hCUSxhQUFhLENBQUNsSyxLQUFLLENBQUM7SUFDeEI7SUFDQTdCLGlEQUFHLENBQUNPLGdCQUFnQixDQUFDLGlCQUFpQixFQUFHNkQsRUFBRSxJQUFLO01BQzVDMkgsYUFBYSxDQUFDM0gsRUFBRSxDQUFDbUUsTUFBTSxDQUFDO0lBQzVCLENBQUMsQ0FBQztJQUNGdkksaURBQUcsQ0FBQ08sZ0JBQWdCLENBQUMsbUJBQW1CLEVBQUc2RCxFQUFFLElBQUs7TUFDOUNxSSxlQUFlLENBQUNySSxFQUFFLENBQUNtRSxNQUFNLENBQUM7SUFDOUIsQ0FBQyxDQUFDO0VBQ04sQ0FBQztFQUFBLGdCQWxHS3NDLGVBQWVBLENBQUE4QixHQUFBLEVBQUFDLEdBQUE7SUFBQSxPQUFBOUIsS0FBQSxDQUFBaEMsS0FBQSxPQUFBQyxTQUFBO0VBQUE7QUFBQSxHQWtHcEIiLCJzb3VyY2VzIjpbIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2lucHV0LXNoaW1zLUMzbE5wOTNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyB3IGFzIHdpbiwgZCBhcyBkb2MgfSBmcm9tICcuL2luZGV4LVpqUDRDamVaLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0U2Nyb2xsRWxlbWVudCwgYyBhcyBzY3JvbGxCeVBvaW50LCBmIGFzIGZpbmRDbG9zZXN0SW9uQ29udGVudCB9IGZyb20gJy4vaW5kZXgtQmxKVEJkeEcuanMnO1xuaW1wb3J0IHsgZiBhcyBhZGRFdmVudExpc3RlbmVyLCBtIGFzIHJlbW92ZUV2ZW50TGlzdGVuZXIsIHIgYXMgcmFmLCBjIGFzIGNvbXBvbmVudE9uUmVhZHkgfSBmcm9tICcuL2hlbHBlcnMtMU80RDJiN3kuanMnO1xuaW1wb3J0IHsgYSBhcyBLZXlib2FyZFJlc2l6ZSwgSyBhcyBLZXlib2FyZCB9IGZyb20gJy4va2V5Ym9hcmQtQ1V3NGVrVnkuanMnO1xuaW1wb3J0ICcuL2luZGV4LUJfVTlDdGFZLmpzJztcbmltcG9ydCAnLi9jYXBhY2l0b3ItQ0ZFUkllYVUuanMnO1xuXG5jb25zdCBjbG9uZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWxvY2F0ZUlucHV0ID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzaG91bGRSZWxvY2F0ZSwgaW5wdXRSZWxhdGl2ZVkgPSAwLCBkaXNhYmxlZENsb25lZElucHV0ID0gZmFsc2UpID0+IHtcbiAgICBpZiAoY2xvbmVNYXAuaGFzKGNvbXBvbmVudEVsKSA9PT0gc2hvdWxkUmVsb2NhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUmVsb2NhdGUpIHtcbiAgICAgICAgYWRkQ2xvbmUoY29tcG9uZW50RWwsIGlucHV0RWwsIGlucHV0UmVsYXRpdmVZLCBkaXNhYmxlZENsb25lZElucHV0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUNsb25lKGNvbXBvbmVudEVsLCBpbnB1dEVsKTtcbiAgICB9XG59O1xuY29uc3QgaXNGb2N1c2VkID0gKGlucHV0KSA9PiB7XG4gICAgLyoqXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvZ2V0Um9vdE5vZGVcbiAgICAgKiBDYWxsaW5nIGdldFJvb3ROb2RlIG9uIGFuIGVsZW1lbnQgaW4gc3RhbmRhcmQgd2ViIHBhZ2Ugd2lsbCByZXR1cm4gSFRNTERvY3VtZW50LlxuICAgICAqIENhbGxpbmcgZ2V0Um9vdE5vZGUgb24gYW4gZWxlbWVudCBpbnNpZGUgb2YgdGhlIFNoYWRvdyBET00gd2lsbCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgU2hhZG93Um9vdC5cbiAgICAgKiBDYWxsaW5nIGdldFJvb3ROb2RlIG9uIGFuIGVsZW1lbnQgdGhhdCBpcyBub3QgYXR0YWNoZWQgdG8gYSBkb2N1bWVudC9zaGFkb3cgdHJlZSB3aWxsIHJldHVyblxuICAgICAqIHRoZSByb290IG9mIHRoZSBET00gdHJlZSBpdCBiZWxvbmdzIHRvLlxuICAgICAqIGlzRm9jdXNlZCBpcyB1c2VkIGZvciB0aGUgaGlkZS1jYXJldCB1dGlsaXR5IHdoaWNoIG9ubHkgY29uc2lkZXJzIGlucHV0L3RleHRhcmVhIGVsZW1lbnRzXG4gICAgICogdGhhdCBhcmUgcHJlc2VudCBpbiB0aGUgRE9NLCBzbyB3ZSBkb24ndCBzZXQgdHlwZXMgZm9yIHRoYXQgZmluYWwgY2FzZSBzaW5jZSBpdCBkb2VzIG5vdCBhcHBseS5cbiAgICAgKi9cbiAgICByZXR1cm4gaW5wdXQgPT09IGlucHV0LmdldFJvb3ROb2RlKCkuYWN0aXZlRWxlbWVudDtcbn07XG5jb25zdCBhZGRDbG9uZSA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgaW5wdXRSZWxhdGl2ZVksIGRpc2FibGVkQ2xvbmVkSW5wdXQgPSBmYWxzZSkgPT4ge1xuICAgIC8vIHRoaXMgYWxsb3dzIGZvciB0aGUgYWN0dWFsIGlucHV0IHRvIHJlY2VpdmUgdGhlIGZvY3VzIGZyb21cbiAgICAvLyB0aGUgdXNlcidzIHRvdWNoIGV2ZW50LCBidXQgYmVmb3JlIGl0IHJlY2VpdmVzIGZvY3VzLCBpdFxuICAgIC8vIG1vdmVzIHRoZSBhY3R1YWwgaW5wdXQgdG8gYSBsb2NhdGlvbiB0aGF0IHdpbGwgbm90IHNjcmV3XG4gICAgLy8gdXAgdGhlIGFwcCdzIGxheW91dCwgYW5kIGRvZXMgbm90IGFsbG93IHRoZSBuYXRpdmUgYnJvd3NlclxuICAgIC8vIHRvIGF0dGVtcHQgdG8gc2Nyb2xsIHRoZSBpbnB1dCBpbnRvIHBsYWNlIChtZXNzaW5nIHVwIGhlYWRlcnMvZm9vdGVycylcbiAgICAvLyB0aGUgY2xvbmVkIGlucHV0IGZpbGxzIHRoZSBhcmVhIG9mIHdoZXJlIG5hdGl2ZSBpbnB1dCBzaG91bGQgYmVcbiAgICAvLyB3aGlsZSB0aGUgbmF0aXZlIGlucHV0IGZha2VzIG91dCB0aGUgYnJvd3NlciBieSByZWxvY2F0aW5nIGl0c2VsZlxuICAgIC8vIGJlZm9yZSBpdCByZWNlaXZlcyB0aGUgYWN0dWFsIGZvY3VzIGV2ZW50XG4gICAgLy8gV2UgaGlkZSB0aGUgZm9jdXNlZCBpbnB1dCAod2l0aCB0aGUgdmlzaWJsZSBjYXJldCkgaW52aXNpYmxlIGJ5IG1ha2luZyBpdCBzY2FsZSgwKSxcbiAgICBjb25zdCBwYXJlbnRFbCA9IGlucHV0RWwucGFyZW50Tm9kZTtcbiAgICAvLyBET00gV1JJVEVTXG4gICAgY29uc3QgY2xvbmVkRWwgPSBpbnB1dEVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgY2xvbmVkRWwuY2xhc3NMaXN0LmFkZCgnY2xvbmVkLWlucHV0Jyk7XG4gICAgY2xvbmVkRWwudGFiSW5kZXggPSAtMTtcbiAgICAvKipcbiAgICAgKiBNYWtpbmcgdGhlIGNsb25lZCBpbnB1dCBkaXNhYmxlZCBwcmV2ZW50c1xuICAgICAqIENocm9tZSBmb3IgQW5kcm9pZCBmcm9tIHN0aWxsIHNjcm9sbGluZ1xuICAgICAqIHRoZSBlbnRpcmUgcGFnZSBzaW5jZSB0aGlzIGNsb25lZCBpbnB1dFxuICAgICAqIHdpbGwgYnJpZWZseSBiZSBoaWRkZW4gYnkgdGhlIGtleWJvYXJkXG4gICAgICogZXZlbiB0aG91Z2ggaXQgaXMgbm90IGZvY3VzZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5vdCBuZWVkZWQgb24gaU9TLiBXaGlsZSB0aGlzXG4gICAgICogZG9lcyBub3QgY2F1c2UgZnVuY3Rpb25hbCBpc3N1ZXMgb24gaU9TLFxuICAgICAqIHRoZSBpbnB1dCBzdGlsbCBhcHBlYXJzIHNsaWdodGx5IGRpbW1lZCBldmVuXG4gICAgICogaWYgd2Ugc2V0IG9wYWNpdHk6IDEuXG4gICAgICovXG4gICAgaWYgKGRpc2FibGVkQ2xvbmVkSW5wdXQpIHtcbiAgICAgICAgY2xvbmVkRWwuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChjbG9uZWRFbCk7XG4gICAgY2xvbmVNYXAuc2V0KGNvbXBvbmVudEVsLCBjbG9uZWRFbCk7XG4gICAgY29uc3QgZG9jID0gY29tcG9uZW50RWwub3duZXJEb2N1bWVudDtcbiAgICBjb25zdCB0eCA9IGRvYy5kaXIgPT09ICdydGwnID8gOTk5OSA6IC05OTk5O1xuICAgIGNvbXBvbmVudEVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgaW5wdXRFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0eH1weCwke2lucHV0UmVsYXRpdmVZfXB4LDApIHNjYWxlKDApYDtcbn07XG5jb25zdCByZW1vdmVDbG9uZSA9IChjb21wb25lbnRFbCwgaW5wdXRFbCkgPT4ge1xuICAgIGNvbnN0IGNsb25lID0gY2xvbmVNYXAuZ2V0KGNvbXBvbmVudEVsKTtcbiAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgY2xvbmVNYXAuZGVsZXRlKGNvbXBvbmVudEVsKTtcbiAgICAgICAgY2xvbmUucmVtb3ZlKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudEVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICBpbnB1dEVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xufTtcbi8qKlxuICogRmFjdG9yaW5nIGluIDUwcHggZ2l2ZXMgdXMgc29tZSByb29tXG4gKiBpbiBjYXNlIHRoZSBrZXlib2FyZCBzaG93cyBwYXNzd29yZC9hdXRvZmlsbCBiYXJzXG4gKiBhc3luY2hyb25vdXNseS5cbiAqL1xuY29uc3QgU0NST0xMX0FNT1VOVF9QQURESU5HID0gNTA7XG5cbmNvbnN0IGVuYWJsZUhpZGVDYXJldE9uU2Nyb2xsID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCkgPT4ge1xuICAgIGlmICghc2Nyb2xsRWwgfHwgIWlucHV0RWwpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsSGlkZUNhcmV0ID0gKHNob3VsZEhpZGVDYXJldCkgPT4ge1xuICAgICAgICBpZiAoaXNGb2N1c2VkKGlucHV0RWwpKSB7XG4gICAgICAgICAgICByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzaG91bGRIaWRlQ2FyZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkJsdXIgPSAoKSA9PiByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBmYWxzZSk7XG4gICAgY29uc3QgaGlkZUNhcmV0ID0gKCkgPT4gc2Nyb2xsSGlkZUNhcmV0KHRydWUpO1xuICAgIGNvbnN0IHNob3dDYXJldCA9ICgpID0+IHNjcm9sbEhpZGVDYXJldChmYWxzZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbFN0YXJ0JywgaGlkZUNhcmV0KTtcbiAgICBhZGRFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsRW5kJywgc2hvd0NhcmV0KTtcbiAgICBpbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxTdGFydCcsIGhpZGVDYXJldCk7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxFbmQnLCBzaG93Q2FyZXQpO1xuICAgICAgICBpbnB1dEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIH07XG59O1xuXG5jb25zdCBTS0lQX1NFTEVDVE9SID0gJ2lucHV0LCB0ZXh0YXJlYSwgW25vLWJsdXJdLCBbY29udGVudGVkaXRhYmxlXSc7XG5jb25zdCBlbmFibGVJbnB1dEJsdXJyaW5nID0gKCkgPT4ge1xuICAgIGxldCBmb2N1c2VkID0gdHJ1ZTtcbiAgICBsZXQgZGlkU2Nyb2xsID0gZmFsc2U7XG4gICAgY29uc3QgZG9jID0gZG9jdW1lbnQ7XG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgIGRpZFNjcm9sbCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBvbkZvY3VzaW4gPSAoKSA9PiB7XG4gICAgICAgIGZvY3VzZWQgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3Qgb25Ub3VjaGVuZCA9IChldikgPT4ge1xuICAgICAgICAvLyBpZiBhcHAgZGlkIHNjcm9sbCByZXR1cm4gZWFybHlcbiAgICAgICAgaWYgKGRpZFNjcm9sbCkge1xuICAgICAgICAgICAgZGlkU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aXZlID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBibHVyIGlmIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBhIHRleHQtaW5wdXQgb3IgYSB0ZXh0YXJlYVxuICAgICAgICBpZiAoYWN0aXZlLm1hdGNoZXMoU0tJUF9TRUxFQ1RPUikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgc2VsZWN0ZWQgdGFyZ2V0IGlzIHRoZSBhY3RpdmUgZWxlbWVudCwgZG8gbm90IGJsdXJcbiAgICAgICAgY29uc3QgdGFwcGVkID0gZXYudGFyZ2V0O1xuICAgICAgICBpZiAodGFwcGVkID09PSBhY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFwcGVkLm1hdGNoZXMoU0tJUF9TRUxFQ1RPUikgfHwgdGFwcGVkLmNsb3Nlc3QoU0tJUF9TRUxFQ1RPUikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8vIFRPRE8gRlctMjc5NjogZmluZCBhIGJldHRlciB3YXksIHdoeSA1MG1zP1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZS5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDUwKTtcbiAgICB9O1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9jLCAnaW9uU2Nyb2xsU3RhcnQnLCBvblNjcm9sbCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzaW4sIHRydWUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQsIGZhbHNlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKGRvYywgJ2lvblNjcm9sbFN0YXJ0Jywgb25TY3JvbGwsIHRydWUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXNpbiwgdHJ1ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQsIGZhbHNlKTtcbiAgICB9O1xufTtcblxuY29uc3QgU0NST0xMX0FTU0lTVF9TUEVFRCA9IDAuMztcbmNvbnN0IGdldFNjcm9sbERhdGEgPSAoY29tcG9uZW50RWwsIGNvbnRlbnRFbCwga2V5Ym9hcmRIZWlnaHQsIHBsYXRmb3JtSGVpZ2h0KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGl0ZW1FbCA9IChfYSA9IGNvbXBvbmVudEVsLmNsb3Nlc3QoJ2lvbi1pdGVtLFtpb24taXRlbV0nKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29tcG9uZW50RWw7XG4gICAgcmV0dXJuIGNhbGNTY3JvbGxEYXRhKGl0ZW1FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgY29udGVudEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBrZXlib2FyZEhlaWdodCwgcGxhdGZvcm1IZWlnaHQpO1xufTtcbmNvbnN0IGNhbGNTY3JvbGxEYXRhID0gKGlucHV0UmVjdCwgY29udGVudFJlY3QsIGtleWJvYXJkSGVpZ2h0LCBwbGF0Zm9ybUhlaWdodCkgPT4ge1xuICAgIC8vIGNvbXB1dGUgaW5wdXQncyBZIHZhbHVlcyByZWxhdGl2ZSB0byB0aGUgYm9keVxuICAgIGNvbnN0IGlucHV0VG9wID0gaW5wdXRSZWN0LnRvcDtcbiAgICBjb25zdCBpbnB1dEJvdHRvbSA9IGlucHV0UmVjdC5ib3R0b207XG4gICAgLy8gY29tcHV0ZSB2aXNpYmxlIGFyZWFcbiAgICBjb25zdCB2aXNpYmxlQXJlYVRvcCA9IGNvbnRlbnRSZWN0LnRvcDtcbiAgICBjb25zdCB2aXNpYmxlQXJlYUJvdHRvbSA9IE1hdGgubWluKGNvbnRlbnRSZWN0LmJvdHRvbSwgcGxhdGZvcm1IZWlnaHQgLSBrZXlib2FyZEhlaWdodCk7XG4gICAgLy8gY29tcHV0ZSBzYWZlIGFyZWFcbiAgICBjb25zdCBzYWZlQXJlYVRvcCA9IHZpc2libGVBcmVhVG9wICsgMTU7XG4gICAgY29uc3Qgc2FmZUFyZWFCb3R0b20gPSB2aXNpYmxlQXJlYUJvdHRvbSAtIFNDUk9MTF9BTU9VTlRfUEFERElORztcbiAgICAvLyBmaWd1cmUgb3V0IGlmIGVhY2ggZWRnZSBvZiB0aGUgaW5wdXQgaXMgd2l0aGluIHRoZSBzYWZlIGFyZWFcbiAgICBjb25zdCBkaXN0YW5jZVRvQm90dG9tID0gc2FmZUFyZWFCb3R0b20gLSBpbnB1dEJvdHRvbTtcbiAgICBjb25zdCBkaXN0YW5jZVRvVG9wID0gc2FmZUFyZWFUb3AgLSBpbnB1dFRvcDtcbiAgICAvLyBkZXNpcmVkU2Nyb2xsQW1vdW50IGlzIHRoZSBuZWdhdGVkIGRpc3RhbmNlIHRvIHRoZSBzYWZlIGFyZWEgYWNjb3JkaW5nIHRvIG91ciBjYWxjdWxhdGlvbnMuXG4gICAgY29uc3QgZGVzaXJlZFNjcm9sbEFtb3VudCA9IE1hdGgucm91bmQoZGlzdGFuY2VUb0JvdHRvbSA8IDAgPyAtZGlzdGFuY2VUb0JvdHRvbSA6IGRpc3RhbmNlVG9Ub3AgPiAwID8gLWRpc3RhbmNlVG9Ub3AgOiAwKTtcbiAgICAvLyBvdXIgY2FsY3VsYXRpb25zIG1ha2Ugc29tZSBhc3N1bXB0aW9ucyB0aGF0IGFyZW4ndCBhbHdheXMgdHJ1ZSwgbGlrZSB0aGUga2V5Ym9hcmQgYmVpbmcgY2xvc2VkIHdoZW4gYW4gaW5wdXRcbiAgICAvLyBnZXRzIGZvY3VzLCBzbyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2Nyb2xsIHRoZSBpbnB1dCBhYm92ZSB0aGUgdmlzaWJsZSBhcmVhXG4gICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5taW4oZGVzaXJlZFNjcm9sbEFtb3VudCwgaW5wdXRUb3AgLSB2aXNpYmxlQXJlYVRvcCk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmFicyhzY3JvbGxBbW91bnQpO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZGlzdGFuY2UgLyBTQ1JPTExfQVNTSVNUX1NQRUVEO1xuICAgIGNvbnN0IHNjcm9sbER1cmF0aW9uID0gTWF0aC5taW4oNDAwLCBNYXRoLm1heCgxNTAsIGR1cmF0aW9uKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Nyb2xsQW1vdW50LFxuICAgICAgICBzY3JvbGxEdXJhdGlvbixcbiAgICAgICAgc2Nyb2xsUGFkZGluZzoga2V5Ym9hcmRIZWlnaHQsXG4gICAgICAgIGlucHV0U2FmZVk6IC0oaW5wdXRUb3AgLSBzYWZlQXJlYVRvcCkgKyA0LFxuICAgIH07XG59O1xuXG5jb25zdCBQQURESU5HX1RJTUVSX0tFWSA9ICckaW9uUGFkZGluZ1RpbWVyJztcbi8qKlxuICogU2Nyb2xsIHBhZGRpbmcgYWRkcyBhZGRpdGlvbmFsIHBhZGRpbmcgdG8gdGhlIGJvdHRvbVxuICogb2YgaW9uLWNvbnRlbnQgc28gdGhhdCB0aGVyZSBpcyBlbm91Z2ggc2Nyb2xsIHNwYWNlXG4gKiBmb3IgYW4gaW5wdXQgdG8gYmUgc2Nyb2xsZWQgYWJvdmUgdGhlIGtleWJvYXJkLiBUaGlzXG4gKiBpcyBuZWVkZWQgaW4gZW52aXJvbm1lbnRzIHdoZXJlIHRoZSB3ZWJ2aWV3IGRvZXMgbm90XG4gKiByZXNpemUgd2hlbiB0aGUga2V5Ym9hcmQgb3BlbnMuXG4gKlxuICogRXhhbXBsZTogSWYgYW4gaW5wdXQgYXQgdGhlIGJvdHRvbSBvZiBpb24tY29udGVudCBpc1xuICogZm9jdXNlZCwgdGhlcmUgaXMgbm8gYWRkaXRpb25hbCBzY3JvbGxpbmcgc3BhY2UgYmVsb3dcbiAqIGl0LCBzbyB0aGUgaW5wdXQgY2Fubm90IGJlIHNjcm9sbGVkIGFib3ZlIHRoZSBrZXlib2FyZC5cbiAqIFNjcm9sbCBwYWRkaW5nIGZpeGVzIHRoaXMgYnkgYWRkaW5nIHBhZGRpbmcgZXF1YWwgdG8gdGhlXG4gKiBoZWlnaHQgb2YgdGhlIGtleWJvYXJkIHRvIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQuXG4gKlxuICogQ29tbW9uIGVudmlyb25tZW50cyB3aGVyZSB0aGlzIGlzIG5lZWRlZDpcbiAqIC0gTW9iaWxlIFNhZmFyaTogVGhlIGtleWJvYXJkIG92ZXJsYXlzIHRoZSBjb250ZW50XG4gKiAtIENhcGFjaXRvci9Db3Jkb3ZhIG9uIGlPUzogVGhlIGtleWJvYXJkIG92ZXJsYXlzIHRoZSBjb250ZW50XG4gKiB3aGVuIHRoZSBLZXlib2FyZFJlc2l6ZSBtb2RlIGlzIHNldCB0byAnbm9uZScuXG4gKi9cbmNvbnN0IHNldFNjcm9sbFBhZGRpbmcgPSAoY29udGVudEVsLCBwYWRkaW5nQW1vdW50LCBjbGVhckNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgdGltZXIgPSBjb250ZW50RWxbUEFERElOR19USU1FUl9LRVldO1xuICAgIGlmICh0aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIH1cbiAgICBpZiAocGFkZGluZ0Ftb3VudCA+IDApIHtcbiAgICAgICAgY29udGVudEVsLnN0eWxlLnNldFByb3BlcnR5KCctLWtleWJvYXJkLW9mZnNldCcsIGAke3BhZGRpbmdBbW91bnR9cHhgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRlbnRFbFtQQURESU5HX1RJTUVSX0tFWV0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1rZXlib2FyZC1vZmZzZXQnLCAnMHB4Jyk7XG4gICAgICAgICAgICBpZiAoY2xlYXJDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNsZWFyQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTIwKTtcbiAgICB9XG59O1xuLyoqXG4gKiBXaGVuIGFuIGlucHV0IGlzIGFib3V0IHRvIGJlIGZvY3VzZWQsXG4gKiBzZXQgYSB0aW1lb3V0IHRvIGNsZWFyIGFueSBzY3JvbGwgcGFkZGluZ1xuICogb24gdGhlIGNvbnRlbnQuIE5vdGU6IFRoZSBjbGVhcmluZ1xuICogaXMgZG9uZSBvbiBhIHRpbWVvdXQgc28gdGhhdCBpZiB1c2Vyc1xuICogYXJlIG1vdmluZyBmb2N1cyBmcm9tIG9uZSBpbnB1dCB0byB0aGUgbmV4dFxuICogdGhlbiByZS1hZGRpbmcgc2Nyb2xsIHBhZGRpbmcgdG8gdGhlIG5ld1xuICogaW5wdXQgd2l0aCBjYW5jZWwgdGhlIHRpbWVvdXQgdG8gY2xlYXIgdGhlXG4gKiBzY3JvbGwgcGFkZGluZy5cbiAqL1xuY29uc3Qgc2V0Q2xlYXJTY3JvbGxQYWRkaW5nTGlzdGVuZXIgPSAoaW5wdXRFbCwgY29udGVudEVsLCBkb25lQ2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBjbGVhclNjcm9sbFBhZGRpbmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjb250ZW50RWwpIHtcbiAgICAgICAgICAgIHNldFNjcm9sbFBhZGRpbmcoY29udGVudEVsLCAwLCBkb25lQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgY2xlYXJTY3JvbGxQYWRkaW5nLCB7IG9uY2U6IHRydWUgfSk7XG59O1xuXG5sZXQgY3VycmVudFBhZGRpbmcgPSAwO1xuY29uc3QgU0tJUF9TQ1JPTExfQVNTSVNUID0gJ2RhdGEtaW9uaWMtc2tpcC1zY3JvbGwtYXNzaXN0JztcbmNvbnN0IGVuYWJsZVNjcm9sbEFzc2lzdCA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQsIGVuYWJsZVNjcm9sbFBhZGRpbmcsIGtleWJvYXJkUmVzaXplLCBkaXNhYmxlQ2xvbmVkSW5wdXQgPSBmYWxzZSkgPT4ge1xuICAgIC8qKlxuICAgICAqIFNjcm9sbCBwYWRkaW5nIHNob3VsZCBvbmx5IGJlIGFkZGVkIGlmOlxuICAgICAqIDEuIFRoZSBnbG9iYWwgc2Nyb2xsUGFkZGluZyBjb25maWcgb3B0aW9uXG4gICAgICogaXMgc2V0IHRvIHRydWUuXG4gICAgICogMi4gVGhlIG5hdGl2ZSBrZXlib2FyZCByZXNpemUgbW9kZSBpcyBlaXRoZXIgXCJub25lXCJcbiAgICAgKiAoa2V5Ym9hcmQgb3ZlcmxheXMgd2Vidmlldykgb3IgdW5kZWZpbmVkIChyZXNpemVcbiAgICAgKiBpbmZvcm1hdGlvbiB1bmF2YWlsYWJsZSlcbiAgICAgKiBSZXNpemUgaW5mbyBpcyBhdmFpbGFibGUgb24gQ2FwYWNpdG9yIDQrXG4gICAgICovXG4gICAgY29uc3QgYWRkU2Nyb2xsUGFkZGluZyA9IGVuYWJsZVNjcm9sbFBhZGRpbmcgJiYgKGtleWJvYXJkUmVzaXplID09PSB1bmRlZmluZWQgfHwga2V5Ym9hcmRSZXNpemUubW9kZSA9PT0gS2V5Ym9hcmRSZXNpemUuTm9uZSk7XG4gICAgLyoqXG4gICAgICogVGhpcyB0cmFja3Mgd2hldGhlciBvciBub3QgdGhlIGtleWJvYXJkIGhhcyBiZWVuXG4gICAgICogcHJlc2VudGVkIGZvciBhIHNpbmdsZSBmb2N1c2VkIHRleHQgZmllbGQuIE5vdGVcbiAgICAgKiB0aGF0IGl0IGRvZXMgbm90IHRyYWNrIGlmIHRoZSBrZXlib2FyZCBpcyBvcGVuXG4gICAgICogaW4gZ2VuZXJhbCBzdWNoIGFzIGlmIHRoZSBrZXlib2FyZCBpcyBvcGVuIGZvclxuICAgICAqIGEgZGlmZmVyZW50IGZvY3VzZWQgdGV4dCBmaWVsZC5cbiAgICAgKi9cbiAgICBsZXQgaGFzS2V5Ym9hcmRCZWVuUHJlc2VudGVkRm9yVGV4dEZpZWxkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogV2hlbiBhZGRpbmcgc2Nyb2xsIHBhZGRpbmcgd2UgbmVlZCB0byBrbm93XG4gICAgICogaG93IG11Y2ggb2YgdGhlIHZpZXdwb3J0IHRoZSBrZXlib2FyZCBvYnNjdXJlcy5cbiAgICAgKiBXZSBkbyB0aGlzIGJ5IHN1YnRyYWN0aW5nIHRoZSBrZXlib2FyZCBoZWlnaHRcbiAgICAgKiBmcm9tIHRoZSBwbGF0Zm9ybSBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBJZiB3ZSBjb21wdXRlIHRoaXMgdmFsdWUgd2hlbiBzd2l0Y2hpbmcgYmV0d2VlblxuICAgICAqIGlucHV0cyB0aGVuIHRoZSB3ZWJ2aWV3IG1heSBhbHJlYWR5IGJlIHJlc2l6ZWQuXG4gICAgICogQXQgdGhpcyBwb2ludCwgYHdpbi5pbm5lckhlaWdodGAgaGFzIGFscmVhZHkgYWNjb3VudGVkXG4gICAgICogZm9yIHRoZSBrZXlib2FyZCBtZWFuaW5nIHdlIHdvdWxkIHRoZW4gc3VidHJhY3RcbiAgICAgKiB0aGUga2V5Ym9hcmQgaGVpZ2h0IGFnYWluLiBUaGlzIHdpbGwgcmVzdWx0IGluIHRoZSBpbnB1dFxuICAgICAqIGJlaW5nIHNjcm9sbGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0by5cbiAgICAgKi9cbiAgICBjb25zdCBwbGF0Zm9ybUhlaWdodCA9IHdpbiAhPT0gdW5kZWZpbmVkID8gd2luLmlubmVySGVpZ2h0IDogMDtcbiAgICAvKipcbiAgICAgKiBTY3JvbGwgYXNzaXN0IGlzIHJ1biB3aGVuIGEgdGV4dCBmaWVsZFxuICAgICAqIGlzIGZvY3VzZWQuIEhvd2V2ZXIsIGl0IG1heSBuZWVkIHRvXG4gICAgICogcmUtcnVuIHdoZW4gdGhlIGtleWJvYXJkIHNpemUgY2hhbmdlc1xuICAgICAqIHN1Y2ggdGhhdCB0aGUgdGV4dCBmaWVsZCBpcyBub3cgaGlkZGVuXG4gICAgICogdW5kZXJuZWF0aCB0aGUga2V5Ym9hcmQuXG4gICAgICogVGhpcyBmdW5jdGlvbiByZS1ydW5zIHNjcm9sbCBhc3Npc3RcbiAgICAgKiB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICAgKlxuICAgICAqIE9uZSBsaW1pdGF0aW9uIG9mIHRoaXMgaXMgb24gYSB3ZWIgYnJvd3NlclxuICAgICAqIHdoZXJlIG5hdGl2ZSBrZXlib2FyZCBBUElzIGRvIG5vdCBoYXZlIGNyb3NzLWJyb3dzZXJcbiAgICAgKiBzdXBwb3J0LiBgaW9uS2V5Ym9hcmREaWRTaG93YCByZWxpZXMgb24gdGhlIFZpc3VhbCBWaWV3cG9ydCBBUEkuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBrZXlib2FyZCBjaGFuZ2VzIGJ1dCBkb2VzIG5vdCBjaGFuZ2VcbiAgICAgKiBnZW9tZXRyeSwgdGhlbiBzY3JvbGwgYXNzaXN0IHdpbGwgbm90IHJlLXJ1biBldmVuIGlmXG4gICAgICogdGhlIHVzZXIgaGFzIHNjcm9sbGVkIHRoZSB0ZXh0IGZpZWxkIHVuZGVyIHRoZSBrZXlib2FyZC5cbiAgICAgKiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2hlbiBydW5uaW5nIGluIENvcmRvdmEvQ2FwYWNpdG9yXG4gICAgICogYmVjYXVzZSBgaW9uS2V5Ym9hcmREaWRTaG93YCB1c2VzIHRoZSBuYXRpdmUgZXZlbnRzXG4gICAgICogd2hpY2ggZmlyZSBldmVyeSB0aW1lIHRoZSBrZXlib2FyZCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGNvbnN0IGtleWJvYXJkU2hvdyA9IChldikgPT4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGtleWJvYXJkIGhhcyBub3QgeWV0IGJlZW4gcHJlc2VudGVkXG4gICAgICAgICAqIGZvciB0aGlzIHRleHQgZmllbGQgdGhlbiB0aGUgdGV4dCBmaWVsZCBoYXMganVzdFxuICAgICAgICAgKiByZWNlaXZlZCBmb2N1cy4gSW4gdGhhdCBjYXNlLCB0aGUgZm9jdXNpbiBsaXN0ZW5lclxuICAgICAgICAgKiB3aWxsIHJ1biBzY3JvbGwgYXNzaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGhhc0tleWJvYXJkQmVlblByZXNlbnRlZEZvclRleHRGaWVsZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhhc0tleWJvYXJkQmVlblByZXNlbnRlZEZvclRleHRGaWVsZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE90aGVyd2lzZSwgdGhlIGtleWJvYXJkIGhhcyBhbHJlYWR5IGJlZW4gcHJlc2VudGVkXG4gICAgICAgICAqIGZvciB0aGUgZm9jdXNlZCB0ZXh0IGZpZWxkLlxuICAgICAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIGtleWJvYXJkIGxpa2VseSBjaGFuZ2VkXG4gICAgICAgICAqIGdlb21ldHJ5LCBhbmQgd2UgbmVlZCB0byByZS1ydW4gc2Nyb2xsIGFzc2lzdC5cbiAgICAgICAgICogVGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIHVzZXIgcm90YXRlcyB0aGVpciBkZXZpY2VcbiAgICAgICAgICogb3Igd2hlbiB0aGV5IHN3aXRjaCBrZXlib2FyZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE1ha2Ugc3VyZSB3ZSBwYXNzIGluIHRoZSBjb21wdXRlZCBrZXlib2FyZCBoZWlnaHRcbiAgICAgICAgICogcmF0aGVyIHRoYW4gdGhlIGVzdGltYXRlZCBrZXlib2FyZCBoZWlnaHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpbmNlIHRoZSBrZXlib2FyZCBpcyBhbHJlYWR5IG9wZW4gdGhlbiB3ZSBkbyBub3RcbiAgICAgICAgICogbmVlZCB0byB3YWl0IGZvciB0aGUgd2VidmlldyB0byByZXNpemUsIHNvIHdlIHBhc3NcbiAgICAgICAgICogXCJ3YWl0Rm9yUmVzaXplOiBmYWxzZVwiLlxuICAgICAgICAgKi9cbiAgICAgICAganNTZXRGb2N1cyhjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwgZXYuZGV0YWlsLmtleWJvYXJkSGVpZ2h0LCBhZGRTY3JvbGxQYWRkaW5nLCBkaXNhYmxlQ2xvbmVkSW5wdXQsIHBsYXRmb3JtSGVpZ2h0LCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgaW50ZXJuYWwgc3RhdGUgd2hlbiB0aGUgdGV4dCBmaWVsZCBsb3NlcyBmb2N1cy5cbiAgICAgKi9cbiAgICBjb25zdCBmb2N1c091dCA9ICgpID0+IHtcbiAgICAgICAgaGFzS2V5Ym9hcmRCZWVuUHJlc2VudGVkRm9yVGV4dEZpZWxkID0gZmFsc2U7XG4gICAgICAgIHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBrZXlib2FyZFNob3cpO1xuICAgICAgICBjb21wb25lbnRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZvY3VzT3V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIGlucHV0IGlzIGFib3V0IHRvIHJlY2VpdmVcbiAgICAgKiBmb2N1cywgd2UgbmVlZCB0byBtb3ZlIGl0IHRvIHByZXZlbnRcbiAgICAgKiBtb2JpbGUgU2FmYXJpIGZyb20gYWRqdXN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICAgKi9cbiAgICBjb25zdCBmb2N1c0luID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xsIGFzc2lzdCBzaG91bGQgbm90IHJ1biBhZ2FpblxuICAgICAgICAgKiBvbiBpbnB1dHMgdGhhdCBoYXZlIGJlZW4gbWFudWFsbHlcbiAgICAgICAgICogZm9jdXNlZCBpbnNpZGUgb2YgdGhlIHNjcm9sbCBhc3Npc3RcbiAgICAgICAgICogaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaW5wdXRFbC5oYXNBdHRyaWJ1dGUoU0tJUF9TQ1JPTExfQVNTSVNUKSkge1xuICAgICAgICAgICAgaW5wdXRFbC5yZW1vdmVBdHRyaWJ1dGUoU0tJUF9TQ1JPTExfQVNTSVNUKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBqc1NldEZvY3VzKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCwgYWRkU2Nyb2xsUGFkZGluZywgZGlzYWJsZUNsb25lZElucHV0LCBwbGF0Zm9ybUhlaWdodCk7XG4gICAgICAgIHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBrZXlib2FyZFNob3cpO1xuICAgICAgICBjb21wb25lbnRFbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZvY3VzT3V0KTtcbiAgICB9O1xuICAgIGNvbXBvbmVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmb2N1c0luKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb21wb25lbnRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZm9jdXNJbik7XG4gICAgICAgIHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBrZXlib2FyZFNob3cpO1xuICAgICAgICBjb21wb25lbnRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZvY3VzT3V0KTtcbiAgICB9O1xufTtcbi8qKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gd2hlbiB5b3Ugd2FudCB0byBtYW51YWxseVxuICogZm9jdXMgYW4gaW5wdXQgYnV0IG5vdCBoYXZlIHNjcm9sbCBhc3Npc3QgcnVuIGFnYWluLlxuICovXG5jb25zdCBzZXRNYW51YWxGb2N1cyA9IChlbCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICAvKipcbiAgICAgKiBJZiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCB0aGVuXG4gICAgICogYSBuZXcgZm9jdXNpbiBldmVudCB3aWxsIG5vdCBiZSBkaXNwYXRjaGVkXG4gICAgICogdG8gcmVtb3ZlIHRoZSBTS0lMX1NDUk9MTF9BU1NJU1QgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wdGltaXphdGlvbiBmb3Igc2NlbmFyaW9zIHdoZXJlIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50IGlzIGEgc2libGluZ1xuICAgICAqIG9mIHRoZSB0YXJnZXQgZWxlbWVudC4gSW4gc3VjaCBjYXNlcywgd2UgYXZvaWQgc2V0dGluZyBgU0tJUF9TQ1JPTExfQVNTSVNUYC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgY3J1Y2lhbCBmb3IgYWNjZXNzaWJpbGl0eTogaW5wdXQgZWxlbWVudHMgY2FuIG5vdyBjb250YWluIGZvY3VzYWJsZVxuICAgICAqIHNpYmxpbmdzIChlLmcuLCBjbGVhciBidXR0b25zLCBzbG90dGVkIGVsZW1lbnRzKS4gSWYgd2UgZGlkbid0IHNraXAgc2V0dGluZ1xuICAgICAqIHRoZSBhdHRyaWJ1dGUgaGVyZSwgc2NyZWVuIHJlYWRlcnMgd291bGQgYmUgdW5hYmxlIHRvIG5hdmlnYXRlIHRvIGFuZCBpbnRlcmFjdFxuICAgICAqIHdpdGggdGhlc2Ugc2libGluZyBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIFdpdGhvdXQgdGhpcyBjaGVjaywgd2Ugd291bGQgbmVlZCB0byBjYWxsIGBldi5zdG9wUHJvcGFnYXRpb24oKWAgb24gdGhlXG4gICAgICogJ2ZvY3VzaW4nIGV2ZW50IG9mIGVhY2ggZm9jdXNhYmxlIHNpYmxpbmcgdG8gcHJldmVudCB0aGUgc2Nyb2xsIGFzc2lzdFxuICAgICAqIGxpc3RlbmVyIGZyb20gaW5jb3JyZWN0bHkgbW92aW5nIGZvY3VzIGJhY2sgdG8gdGhlIGlucHV0LiBUaGF0IGFwcHJvYWNoXG4gICAgICogd291bGQgYmUgbGVzcyBtYWludGFpbmFibGUgYW5kIG1vcmUgZXJyb3ItcHJvbmUuXG4gICAgICovXG4gICAgY29uc3QgaW5wdXRJZCA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICBjb25zdCBsYWJlbCA9IGVsLmNsb3Nlc3QoYGxhYmVsW2Zvcj1cIiR7aW5wdXRJZH1cIl1gKTtcbiAgICBjb25zdCBhY3RpdmVFbExhYmVsID0gKF9hID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3Nlc3QoYGxhYmVsW2Zvcj1cIiR7aW5wdXRJZH1cIl1gKTtcbiAgICBpZiAobGFiZWwgIT09IG51bGwgJiYgbGFiZWwgPT09IGFjdGl2ZUVsTGFiZWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIHRoZSBhY3RpdmUgZWxlbWVudCBsYWJlbCwgdGhlblxuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHNldCB0aGUgYFNLSVBfU0NST0xMX0FTU0lTVGAgYW5kIHJlc2V0IGZvY3VzLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShTS0lQX1NDUk9MTF9BU1NJU1QsICd0cnVlJyk7XG4gICAgZWwuZm9jdXMoKTtcbn07XG5jb25zdCBqc1NldEZvY3VzID0gYXN5bmMgKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCwgZW5hYmxlU2Nyb2xsUGFkZGluZywgZGlzYWJsZUNsb25lZElucHV0ID0gZmFsc2UsIHBsYXRmb3JtSGVpZ2h0ID0gMCwgd2FpdEZvclJlc2l6ZSA9IHRydWUpID0+IHtcbiAgICBpZiAoIWNvbnRlbnRFbCAmJiAhZm9vdGVyRWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxEYXRhID0gZ2V0U2Nyb2xsRGF0YShjb21wb25lbnRFbCwgKGNvbnRlbnRFbCB8fCBmb290ZXJFbCksIGtleWJvYXJkSGVpZ2h0LCBwbGF0Zm9ybUhlaWdodCk7XG4gICAgaWYgKGNvbnRlbnRFbCAmJiBNYXRoLmFicyhzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCkgPCA0KSB7XG4gICAgICAgIC8vIHRoZSB0ZXh0IGlucHV0IGlzIGluIGEgc2FmZSBwb3NpdGlvbiB0aGF0IGRvZXNuJ3RcbiAgICAgICAgLy8gcmVxdWlyZSBpdCB0byBiZSBzY3JvbGxlZCBpbnRvIHZpZXcsIGp1c3Qgc2V0IGZvY3VzIG5vd1xuICAgICAgICBzZXRNYW51YWxGb2N1cyhpbnB1dEVsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW4gdGhvdWdoIHRoZSBpbnB1dCBkb2VzIG5vdCBuZWVkXG4gICAgICAgICAqIHNjcm9sbCBhc3Npc3QsIHdlIHNob3VsZCBwcmVzZXJ2ZSB0aGVcbiAgICAgICAgICogdGhlIHNjcm9sbCBwYWRkaW5nIGFzIHVzZXJzIGNvdWxkIGJlIG1vdmluZ1xuICAgICAgICAgKiBmb2N1cyBmcm9tIGFuIGlucHV0IHRoYXQgbmVlZHMgc2Nyb2xsIHBhZGRpbmdcbiAgICAgICAgICogdG8gYW4gaW5wdXQgdGhhdCBkb2VzIG5vdCBuZWVkIHNjcm9sbCBwYWRkaW5nLlxuICAgICAgICAgKiBJZiB3ZSByZW1vdmUgdGhlIHNjcm9sbCBwYWRkaW5nIG5vdywgdXNlcnMgd2lsbFxuICAgICAgICAgKiBzZWUgdGhlIHBhZ2UganVtcC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChlbmFibGVTY3JvbGxQYWRkaW5nICYmIGNvbnRlbnRFbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U2Nyb2xsUGFkZGluZyhjb250ZW50RWwsIGN1cnJlbnRQYWRkaW5nKTtcbiAgICAgICAgICAgIHNldENsZWFyU2Nyb2xsUGFkZGluZ0xpc3RlbmVyKGlucHV0RWwsIGNvbnRlbnRFbCwgKCkgPT4gKGN1cnJlbnRQYWRkaW5nID0gMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdGVtcG9yYXJpbHkgbW92ZSB0aGUgZm9jdXMgdG8gdGhlIGZvY3VzIGhvbGRlciBzbyB0aGUgYnJvd3NlclxuICAgIC8vIGRvZXNuJ3QgZnJlYWsgb3V0IHdoaWxlIGl0J3MgdHJ5aW5nIHRvIGdldCB0aGUgaW5wdXQgaW4gcGxhY2VcbiAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBuYXRpdmUgdGV4dCBpbnB1dCBzdGlsbCBkb2VzIG5vdCBoYXZlIGZvY3VzXG4gICAgcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgdHJ1ZSwgc2Nyb2xsRGF0YS5pbnB1dFNhZmVZLCBkaXNhYmxlQ2xvbmVkSW5wdXQpO1xuICAgIHNldE1hbnVhbEZvY3VzKGlucHV0RWwpO1xuICAgIC8qKlxuICAgICAqIFJlbG9jYXRpbmcvRm9jdXNpbmcgaW5wdXQgY2F1c2VzIHRoZVxuICAgICAqIGNsaWNrIGV2ZW50IHRvIGJlIGNhbmNlbGxlZCwgc29cbiAgICAgKiBtYW51YWxseSBmaXJlIG9uZSBoZXJlLlxuICAgICAqL1xuICAgIHJhZigoKSA9PiBjb21wb25lbnRFbC5jbGljaygpKTtcbiAgICAvKipcbiAgICAgKiBJZiBlbmFibGVkLCB3ZSBjYW4gYWRkIHNjcm9sbCBwYWRkaW5nIHRvXG4gICAgICogdGhlIGJvdHRvbSBvZiB0aGUgY29udGVudCBzbyB0aGF0IHNjcm9sbCBhc3Npc3RcbiAgICAgKiBoYXMgZW5vdWdoIHJvb20gdG8gc2Nyb2xsIHRoZSBpbnB1dCBhYm92ZVxuICAgICAqIHRoZSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICBpZiAoZW5hYmxlU2Nyb2xsUGFkZGluZyAmJiBjb250ZW50RWwpIHtcbiAgICAgICAgY3VycmVudFBhZGRpbmcgPSBzY3JvbGxEYXRhLnNjcm9sbFBhZGRpbmc7XG4gICAgICAgIHNldFNjcm9sbFBhZGRpbmcoY29udGVudEVsLCBjdXJyZW50UGFkZGluZyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsZXQgc2Nyb2xsQ29udGVudFRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IHNjcm9sbENvbnRlbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBsaXN0ZW5lcnMgYW5kIHRpbWVvdXRzXG4gICAgICAgICAgICBpZiAoc2Nyb2xsQ29udGVudFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxDb250ZW50VGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93JywgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICAgICAgICAgIC8vIHNjcm9sbCB0aGUgaW5wdXQgaW50byBwbGFjZVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNjcm9sbEJ5UG9pbnQoY29udGVudEVsLCAwLCBzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCwgc2Nyb2xsRGF0YS5zY3JvbGxEdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgc2Nyb2xsIHZpZXcgaXMgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24gbm93XG4gICAgICAgICAgICAvLyBnaXZlIHRoZSBuYXRpdmUgdGV4dCBpbnB1dCBmb2N1c1xuICAgICAgICAgICAgcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgZmFsc2UsIHNjcm9sbERhdGEuaW5wdXRTYWZlWSk7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhpcyBpcyB0aGUgZm9jdXNlZCBpbnB1dFxuICAgICAgICAgICAgc2V0TWFudWFsRm9jdXMoaW5wdXRFbCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gdGhlIGlucHV0IGlzIGFib3V0IHRvIGJlIGJsdXJyZWRcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBzZXQgYSB0aW1lb3V0IHRvIHJlbW92ZVxuICAgICAgICAgICAgICogYW55IHNjcm9sbCBwYWRkaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZW5hYmxlU2Nyb2xsUGFkZGluZykge1xuICAgICAgICAgICAgICAgIHNldENsZWFyU2Nyb2xsUGFkZGluZ0xpc3RlbmVyKGlucHV0RWwsIGNvbnRlbnRFbCwgKCkgPT4gKGN1cnJlbnRQYWRkaW5nID0gMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93JywgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBhd2FpdCBnZXRTY3JvbGxFbGVtZW50KGNvbnRlbnRFbCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNjcm9sbERhdGEgd2lsbCBvbmx5IGNvbnNpZGVyIHRoZSBhbW91bnQgd2UgbmVlZFxuICAgICAgICAgICAgICogdG8gc2Nyb2xsIGluIG9yZGVyIHRvIHByb3Blcmx5IGJyaW5nIHRoZSBpbnB1dFxuICAgICAgICAgICAgICogaW50byB2aWV3LiBJdCB3aWxsIG5vdCBjb25zaWRlciB0aGUgYW1vdW50XG4gICAgICAgICAgICAgKiB3ZSBjYW4gc2Nyb2xsIGluIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAgICAgICAgICAgKiBBcyBhIHJlc3VsdCwgc2Nyb2xsRGF0YSBtYXkgcmVxdWVzdCBhIGdyZWF0ZXJcbiAgICAgICAgICAgICAqIHNjcm9sbCBwb3NpdGlvbiB0aGFuIGlzIGN1cnJlbnRseSBhdmFpbGFibGVcbiAgICAgICAgICAgICAqIGluIHRoZSBET00uIElmIHRoaXMgaXMgdGhlIGNhc2UsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAqIHdhaXQgZm9yIHRoZSB3ZWJ2aWV3IHRvIHJlc2l6ZS90aGUga2V5Ym9hcmRcbiAgICAgICAgICAgICAqIHRvIHNob3cgaW4gb3JkZXIgZm9yIGFkZGl0aW9uYWwgc2Nyb2xsXG4gICAgICAgICAgICAgKiBiYW5kd2lkdGggdG8gYmVjb21lIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdG90YWxTY3JvbGxBbW91bnQgPSBzY3JvbGxFbC5zY3JvbGxIZWlnaHQgLSBzY3JvbGxFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAod2FpdEZvclJlc2l6ZSAmJiBzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCA+IHRvdGFsU2Nyb2xsQW1vdW50IC0gc2Nyb2xsRWwuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogT24gaU9TIGRldmljZXMsIHRoZSBzeXN0ZW0gd2lsbCBzaG93IGEgXCJQYXNzd29yZHNcIiBiYXIgYWJvdmUgdGhlIGtleWJvYXJkXG4gICAgICAgICAgICAgICAgICogYWZ0ZXIgdGhlIGluaXRpYWwga2V5Ym9hcmQgaXMgc2hvd24uIFRoaXMgcHJldmVudHMgdGhlIHdlYnZpZXcgZnJvbSByZXNpemluZ1xuICAgICAgICAgICAgICAgICAqIHVudGlsIHRoZSBcIlBhc3N3b3Jkc1wiIGJhciBpcyBzaG93biwgc28gd2UgbmVlZCB0byB3YWl0IGZvciB0aGF0IHRvIGhhcHBlbiBmaXJzdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRFbC50eXBlID09PSAncGFzc3dvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCA1MHB4IHRvIGFjY291bnQgZm9yIHRoZSBcIlBhc3N3b3Jkc1wiIGJhclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCArPSBTQ1JPTExfQU1PVU5UX1BBRERJTkc7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIHNjcm9sbENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGZpcmUgaW4gMiBpbnN0YW5jZXM6XG4gICAgICAgICAgICAgICAgICogMS4gVGhlIGFwcCBpcyB2ZXJ5IHNsb3cuXG4gICAgICAgICAgICAgICAgICogMi4gVGhlIGFwcCBpcyBydW5uaW5nIGluIGEgYnJvd3NlciBvbiBhbiBvbGQgT1NcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGRvZXMgbm90IHN1cHBvcnQgSW9uaWMgS2V5Ym9hcmQgRXZlbnRzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ29udGVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KHNjcm9sbENvbnRlbnQsIDEwMDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxDb250ZW50KCk7XG4gICAgfVxufTtcblxuY29uc3QgSU5QVVRfQkxVUlJJTkcgPSB0cnVlO1xuY29uc3Qgc3RhcnRJbnB1dFNoaW1zID0gYXN5bmMgKGNvbmZpZywgcGxhdGZvcm0pID0+IHtcbiAgICAvKipcbiAgICAgKiBJZiBkb2MgaXMgdW5kZWZpbmVkIHRoZW4gd2UgYXJlIGluIGFuIFNTUiBlbnZpcm9ubWVudFxuICAgICAqIHdoZXJlIGlucHV0IHNoaW1zIGRvIG5vdCBhcHBseS5cbiAgICAgKi9cbiAgICBpZiAoZG9jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0lPUyA9IHBsYXRmb3JtID09PSAnaW9zJztcbiAgICBjb25zdCBpc0FuZHJvaWQgPSBwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnO1xuICAgIC8qKlxuICAgICAqIEhpZGUgQ2FyZXQgYW5kIElucHV0IEJsdXJyaW5nIGFyZSBuZWVkZWQgb24gaU9TLlxuICAgICAqIFNjcm9sbCBBc3Npc3QgYW5kIFNjcm9sbCBQYWRkaW5nIGFyZSBuZWVkZWQgb24gaU9TIGFuZCBBbmRyb2lkXG4gICAgICogd2l0aCBDaHJvbWUgd2ViIGJyb3dzZXIgKG5vdCBDaHJvbWUgd2VidmlldykuXG4gICAgICovXG4gICAgY29uc3Qga2V5Ym9hcmRIZWlnaHQgPSBjb25maWcuZ2V0TnVtYmVyKCdrZXlib2FyZEhlaWdodCcsIDI5MCk7XG4gICAgY29uc3Qgc2Nyb2xsQXNzaXN0ID0gY29uZmlnLmdldEJvb2xlYW4oJ3Njcm9sbEFzc2lzdCcsIHRydWUpO1xuICAgIGNvbnN0IGhpZGVDYXJldCA9IGNvbmZpZy5nZXRCb29sZWFuKCdoaWRlQ2FyZXRPblNjcm9sbCcsIGlzSU9TKTtcbiAgICAvKipcbiAgICAgKiBUaGUgdGVhbSBpcyBldmFsdWF0aW5nIGlmIGlucHV0Qmx1cnJpbmcgaXMgc3RpbGwgbmVlZGVkLiBBcyBhIHJlc3VsdFxuICAgICAqIHRoaXMgZmVhdHVyZSBpcyBkaXNhYmxlZCBieSBkZWZhdWx0IGFzIG9mIElvbmljIDguMC4gRGV2ZWxvcGVycyBhcmVcbiAgICAgKiBhYmxlIHRvIHJlLWVuYWJsZSBpdCB0ZW1wb3JhcmlseS4gVGhlIHRlYW0gbWF5IHJlbW92ZSB0aGlzIHV0aWxpdHlcbiAgICAgKiBpZiBpdCBpcyBkZXRlcm1pbmVkIHRoYXQgZG9pbmcgc28gd291bGQgbm90IGJyaW5nIGFueSBhZHZlcnNlIHNpZGUgZWZmZWN0cy5cbiAgICAgKiBUT0RPIEZXLTYwMTQgcmVtb3ZlIGlucHV0IGJsdXJyaW5nIHV0aWxpdHkgKGluY2x1ZGluZyBpbXBsZW1lbnRhdGlvbilcbiAgICAgKi9cbiAgICBjb25zdCBpbnB1dEJsdXJyaW5nID0gY29uZmlnLmdldEJvb2xlYW4oJ2lucHV0Qmx1cnJpbmcnLCBmYWxzZSk7XG4gICAgY29uc3Qgc2Nyb2xsUGFkZGluZyA9IGNvbmZpZy5nZXRCb29sZWFuKCdzY3JvbGxQYWRkaW5nJywgdHJ1ZSk7XG4gICAgY29uc3QgaW5wdXRzID0gQXJyYXkuZnJvbShkb2MucXVlcnlTZWxlY3RvckFsbCgnaW9uLWlucHV0LCBpb24tdGV4dGFyZWEnKSk7XG4gICAgY29uc3QgaGlkZUNhcmV0TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBzY3JvbGxBc3Npc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIC8qKlxuICAgICAqIEdyYWIgdGhlIG5hdGl2ZSBrZXlib2FyZCByZXNpemUgY29uZmlndXJhdGlvblxuICAgICAqIGFuZCBwYXNzIGl0IHRvIHNjcm9sbCBhc3Npc3QuIFNjcm9sbCBhc3Npc3QgcmVxdWlyZXNcbiAgICAgKiB0aGF0IHdlIGFkanVzdCB0aGUgaW5wdXQgcmlnaHQgYmVmb3JlIHRoZSBpbnB1dFxuICAgICAqIGlzIGFib3V0IHRvIGJlIGZvY3VzZWQuIElmIHdlIGNhbGxlZCBgS2V5Ym9hcmQuZ2V0UmVzaXplTW9kZWBcbiAgICAgKiBvbiBmb2N1c2luIGluIHNjcm9sbCBhc3Npc3QsIHdlIGNvdWxkIHBvdGVudGlhbGx5IGFkanVzdCB0aGVcbiAgICAgKiBpbnB1dCB0b28gbGF0ZSBzaW5jZSB0aGlzIGNhbGwgaXMgYXN5bmMuXG4gICAgICovXG4gICAgY29uc3Qga2V5Ym9hcmRSZXNpemVNb2RlID0gYXdhaXQgS2V5Ym9hcmQuZ2V0UmVzaXplTW9kZSgpO1xuICAgIGNvbnN0IHJlZ2lzdGVySW5wdXQgPSBhc3luYyAoY29tcG9uZW50RWwpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGNvbXBvbmVudE9uUmVhZHkoY29tcG9uZW50RWwsIHJlc29sdmUpKTtcbiAgICAgICAgY29uc3QgaW5wdXRSb290ID0gY29tcG9uZW50RWwuc2hhZG93Um9vdCB8fCBjb21wb25lbnRFbDtcbiAgICAgICAgY29uc3QgaW5wdXRFbCA9IGlucHV0Um9vdC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpIHx8IGlucHV0Um9vdC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpO1xuICAgICAgICBjb25zdCBzY3JvbGxFbCA9IGZpbmRDbG9zZXN0SW9uQ29udGVudChjb21wb25lbnRFbCk7XG4gICAgICAgIGNvbnN0IGZvb3RlckVsID0gIXNjcm9sbEVsID8gY29tcG9uZW50RWwuY2xvc2VzdCgnaW9uLWZvb3RlcicpIDogbnVsbDtcbiAgICAgICAgaWYgKCFpbnB1dEVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhc2Nyb2xsRWwgJiYgaGlkZUNhcmV0ICYmICFoaWRlQ2FyZXRNYXAuaGFzKGNvbXBvbmVudEVsKSkge1xuICAgICAgICAgICAgY29uc3Qgcm1GbiA9IGVuYWJsZUhpZGVDYXJldE9uU2Nyb2xsKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCk7XG4gICAgICAgICAgICBoaWRlQ2FyZXRNYXAuc2V0KGNvbXBvbmVudEVsLCBybUZuKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0ZS9kYXRldGltZS1sb2NhbGUgaW5wdXRzIG9uIG1vYmlsZSBkZXZpY2VzIHNob3cgZGF0ZSBwaWNrZXJcbiAgICAgICAgICogb3ZlcmxheXMgaW5zdGVhZCBvZiBrZXlib2FyZHMuIEFzIGEgcmVzdWx0LCBzY3JvbGwgYXNzaXN0IGlzXG4gICAgICAgICAqIG5vdCBuZWVkZWQuIFRoaXMgYWxzbyB3b3JrcyBhcm91bmQgYSBidWcgaW4gaU9TIDwxNiB3aGVyZVxuICAgICAgICAgKiBzY3JvbGwgYXNzaXN0IGNhdXNlcyB0aGUgYnJvd3NlciB0byBsb2NrIHVwLiBTZWUgRlctMTk5Ny5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGlzRGF0ZUlucHV0ID0gaW5wdXRFbC50eXBlID09PSAnZGF0ZScgfHwgaW5wdXRFbC50eXBlID09PSAnZGF0ZXRpbWUtbG9jYWwnO1xuICAgICAgICBpZiAoIWlzRGF0ZUlucHV0ICYmXG4gICAgICAgICAgICAoISFzY3JvbGxFbCB8fCAhIWZvb3RlckVsKSAmJlxuICAgICAgICAgICAgc2Nyb2xsQXNzaXN0ICYmXG4gICAgICAgICAgICAhc2Nyb2xsQXNzaXN0TWFwLmhhcyhjb21wb25lbnRFbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJtRm4gPSBlbmFibGVTY3JvbGxBc3Npc3QoY29tcG9uZW50RWwsIGlucHV0RWwsIHNjcm9sbEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQsIHNjcm9sbFBhZGRpbmcsIGtleWJvYXJkUmVzaXplTW9kZSwgaXNBbmRyb2lkKTtcbiAgICAgICAgICAgIHNjcm9sbEFzc2lzdE1hcC5zZXQoY29tcG9uZW50RWwsIHJtRm4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bnJlZ2lzdGVySW5wdXQgPSAoY29tcG9uZW50RWwpID0+IHtcbiAgICAgICAgaWYgKGhpZGVDYXJldCkge1xuICAgICAgICAgICAgY29uc3QgZm4gPSBoaWRlQ2FyZXRNYXAuZ2V0KGNvbXBvbmVudEVsKTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaWRlQ2FyZXRNYXAuZGVsZXRlKGNvbXBvbmVudEVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsQXNzaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHNjcm9sbEFzc2lzdE1hcC5nZXQoY29tcG9uZW50RWwpO1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcm9sbEFzc2lzdE1hcC5kZWxldGUoY29tcG9uZW50RWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5wdXRCbHVycmluZyAmJiBJTlBVVF9CTFVSUklORykge1xuICAgICAgICBlbmFibGVJbnB1dEJsdXJyaW5nKCk7XG4gICAgfVxuICAgIC8vIElucHV0IG1pZ2h0IGJlIGFscmVhZHkgbG9hZGVkIGluIHRoZSBET00gYmVmb3JlIGlvbi1kZXZpY2UtaGFja3MgZGlkLlxuICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgbmVlZCB0byBsb29rIGZvciBhbGwgb2YgdGhlIGlucHV0cyBub3QgcmVnaXN0ZXJlZCB5ZXRcbiAgICAvLyBhbmQgcmVnaXN0ZXIgdGhlbS5cbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICByZWdpc3RlcklucHV0KGlucHV0KTtcbiAgICB9XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbklucHV0RGlkTG9hZCcsIChldikgPT4ge1xuICAgICAgICByZWdpc3RlcklucHV0KGV2LmRldGFpbCk7XG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbklucHV0RGlkVW5sb2FkJywgKGV2KSA9PiB7XG4gICAgICAgIHVucmVnaXN0ZXJJbnB1dChldi5kZXRhaWwpO1xuICAgIH0pO1xufTtcblxuZXhwb3J0IHsgc3RhcnRJbnB1dFNoaW1zIH07XG4iXSwibmFtZXMiOlsidyIsIndpbiIsImQiLCJkb2MiLCJnIiwiZ2V0U2Nyb2xsRWxlbWVudCIsImMiLCJzY3JvbGxCeVBvaW50IiwiZiIsImZpbmRDbG9zZXN0SW9uQ29udGVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJtIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInIiLCJyYWYiLCJjb21wb25lbnRPblJlYWR5IiwiYSIsIktleWJvYXJkUmVzaXplIiwiSyIsIktleWJvYXJkIiwiY2xvbmVNYXAiLCJXZWFrTWFwIiwicmVsb2NhdGVJbnB1dCIsImNvbXBvbmVudEVsIiwiaW5wdXRFbCIsInNob3VsZFJlbG9jYXRlIiwiaW5wdXRSZWxhdGl2ZVkiLCJkaXNhYmxlZENsb25lZElucHV0IiwiaGFzIiwiYWRkQ2xvbmUiLCJyZW1vdmVDbG9uZSIsImlzRm9jdXNlZCIsImlucHV0IiwiZ2V0Um9vdE5vZGUiLCJhY3RpdmVFbGVtZW50IiwicGFyZW50RWwiLCJwYXJlbnROb2RlIiwiY2xvbmVkRWwiLCJjbG9uZU5vZGUiLCJjbGFzc0xpc3QiLCJhZGQiLCJ0YWJJbmRleCIsImRpc2FibGVkIiwiYXBwZW5kQ2hpbGQiLCJzZXQiLCJvd25lckRvY3VtZW50IiwidHgiLCJkaXIiLCJzdHlsZSIsInBvaW50ZXJFdmVudHMiLCJ0cmFuc2Zvcm0iLCJjbG9uZSIsImdldCIsImRlbGV0ZSIsInJlbW92ZSIsIlNDUk9MTF9BTU9VTlRfUEFERElORyIsImVuYWJsZUhpZGVDYXJldE9uU2Nyb2xsIiwic2Nyb2xsRWwiLCJzY3JvbGxIaWRlQ2FyZXQiLCJzaG91bGRIaWRlQ2FyZXQiLCJvbkJsdXIiLCJoaWRlQ2FyZXQiLCJzaG93Q2FyZXQiLCJTS0lQX1NFTEVDVE9SIiwiZW5hYmxlSW5wdXRCbHVycmluZyIsImZvY3VzZWQiLCJkaWRTY3JvbGwiLCJkb2N1bWVudCIsIm9uU2Nyb2xsIiwib25Gb2N1c2luIiwib25Ub3VjaGVuZCIsImV2IiwiYWN0aXZlIiwibWF0Y2hlcyIsInRhcHBlZCIsInRhcmdldCIsImNsb3Nlc3QiLCJzZXRUaW1lb3V0IiwiYmx1ciIsIlNDUk9MTF9BU1NJU1RfU1BFRUQiLCJnZXRTY3JvbGxEYXRhIiwiY29udGVudEVsIiwia2V5Ym9hcmRIZWlnaHQiLCJwbGF0Zm9ybUhlaWdodCIsIl9hIiwiaXRlbUVsIiwiY2FsY1Njcm9sbERhdGEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbnB1dFJlY3QiLCJjb250ZW50UmVjdCIsImlucHV0VG9wIiwidG9wIiwiaW5wdXRCb3R0b20iLCJib3R0b20iLCJ2aXNpYmxlQXJlYVRvcCIsInZpc2libGVBcmVhQm90dG9tIiwiTWF0aCIsIm1pbiIsInNhZmVBcmVhVG9wIiwic2FmZUFyZWFCb3R0b20iLCJkaXN0YW5jZVRvQm90dG9tIiwiZGlzdGFuY2VUb1RvcCIsImRlc2lyZWRTY3JvbGxBbW91bnQiLCJyb3VuZCIsInNjcm9sbEFtb3VudCIsImRpc3RhbmNlIiwiYWJzIiwiZHVyYXRpb24iLCJzY3JvbGxEdXJhdGlvbiIsIm1heCIsInNjcm9sbFBhZGRpbmciLCJpbnB1dFNhZmVZIiwiUEFERElOR19USU1FUl9LRVkiLCJzZXRTY3JvbGxQYWRkaW5nIiwicGFkZGluZ0Ftb3VudCIsImNsZWFyQ2FsbGJhY2siLCJ0aW1lciIsImNsZWFyVGltZW91dCIsInNldFByb3BlcnR5Iiwic2V0Q2xlYXJTY3JvbGxQYWRkaW5nTGlzdGVuZXIiLCJkb25lQ2FsbGJhY2siLCJjbGVhclNjcm9sbFBhZGRpbmciLCJvbmNlIiwiY3VycmVudFBhZGRpbmciLCJTS0lQX1NDUk9MTF9BU1NJU1QiLCJlbmFibGVTY3JvbGxBc3Npc3QiLCJmb290ZXJFbCIsImVuYWJsZVNjcm9sbFBhZGRpbmciLCJrZXlib2FyZFJlc2l6ZSIsImRpc2FibGVDbG9uZWRJbnB1dCIsImFkZFNjcm9sbFBhZGRpbmciLCJ1bmRlZmluZWQiLCJtb2RlIiwiTm9uZSIsImhhc0tleWJvYXJkQmVlblByZXNlbnRlZEZvclRleHRGaWVsZCIsImlubmVySGVpZ2h0Iiwia2V5Ym9hcmRTaG93IiwianNTZXRGb2N1cyIsImRldGFpbCIsImZvY3VzT3V0IiwiZm9jdXNJbiIsIl9yZWYiLCJfYXN5bmNUb0dlbmVyYXRvciIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImFwcGx5IiwiYXJndW1lbnRzIiwic2V0TWFudWFsRm9jdXMiLCJlbCIsImlucHV0SWQiLCJnZXRBdHRyaWJ1dGUiLCJsYWJlbCIsImFjdGl2ZUVsTGFiZWwiLCJzZXRBdHRyaWJ1dGUiLCJmb2N1cyIsIl9yZWYyIiwid2FpdEZvclJlc2l6ZSIsInNjcm9sbERhdGEiLCJjbGljayIsIndpbmRvdyIsInNjcm9sbENvbnRlbnRUaW1lb3V0Iiwic2Nyb2xsQ29udGVudCIsIl9yZWYzIiwiZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyIiwidG90YWxTY3JvbGxBbW91bnQiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxUb3AiLCJ0eXBlIiwiX3giLCJfeDIiLCJfeDMiLCJfeDQiLCJfeDUiLCJfeDYiLCJJTlBVVF9CTFVSUklORyIsInN0YXJ0SW5wdXRTaGltcyIsIl9yZWY0IiwiY29uZmlnIiwicGxhdGZvcm0iLCJpc0lPUyIsImlzQW5kcm9pZCIsImdldE51bWJlciIsInNjcm9sbEFzc2lzdCIsImdldEJvb2xlYW4iLCJpbnB1dEJsdXJyaW5nIiwiaW5wdXRzIiwiQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImhpZGVDYXJldE1hcCIsInNjcm9sbEFzc2lzdE1hcCIsImtleWJvYXJkUmVzaXplTW9kZSIsImdldFJlc2l6ZU1vZGUiLCJyZWdpc3RlcklucHV0IiwiX3JlZjUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImlucHV0Um9vdCIsInNoYWRvd1Jvb3QiLCJxdWVyeVNlbGVjdG9yIiwicm1GbiIsImlzRGF0ZUlucHV0IiwiX3g5IiwidW5yZWdpc3RlcklucHV0IiwiZm4iLCJfeDciLCJfeDgiXSwic291cmNlUm9vdCI6IndlYnBhY2s6Ly8vIiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzBdfQ==