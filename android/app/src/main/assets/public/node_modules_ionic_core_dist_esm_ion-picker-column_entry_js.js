"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ionic_core_dist_esm_ion-picker-column_entry_js"],{

/***/ 3110:
/*!**********************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/ion-picker-column.entry.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ion_picker_column: () => (/* binding */ PickerColumn)
/* harmony export */ });
/* harmony import */ var C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 9204);
/* harmony import */ var _index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-B_U9CtaY.js */ 4917);
/* harmony import */ var _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-ZjP4CjeZ.js */ 575);
/* harmony import */ var _helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers-1O4D2b7y.js */ 450);
/* harmony import */ var _haptic_DzAMWJuk_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./haptic-DzAMWJuk.js */ 8235);
/* harmony import */ var _theme_DiVJyqlX_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./theme-DiVJyqlX.js */ 247);
/* harmony import */ var _capacitor_CFERIeaU_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./capacitor-CFERIeaU.js */ 5051);

/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */






const pickerColumnCss = ":host{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;max-width:100%;height:200px;font-size:22px;text-align:center}.assistive-focusable{left:0;right:0;top:0;bottom:0;position:absolute;z-index:1;pointer-events:none}.assistive-focusable:focus{outline:none}.picker-opts{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0px;padding-bottom:0px;min-width:26px;max-height:200px;outline:none;text-align:inherit;-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory;overflow-x:hidden;overflow-y:scroll;scrollbar-width:none}.picker-item-empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;height:34px;border:0px;outline:none;background:transparent;color:inherit;font-family:var(--ion-font-family, inherit);font-size:inherit;line-height:34px;text-align:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.picker-opts::-webkit-scrollbar{display:none}::slotted(ion-picker-column-option){display:block;scroll-snap-align:center}.picker-item-empty,:host(:not([disabled])) ::slotted(ion-picker-column-option.option-disabled){scroll-snap-align:none}::slotted([slot=prefix]),::slotted([slot=suffix]){max-width:200px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}::slotted([slot=prefix]){-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0;padding-bottom:0;-ms-flex-pack:end;justify-content:end}::slotted([slot=suffix]){-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0;padding-bottom:0;-ms-flex-pack:start;justify-content:start}:host(.picker-column-disabled) .picker-opts{overflow-y:hidden}:host(.picker-column-disabled) ::slotted(ion-picker-column-option){cursor:default;opacity:0.4;pointer-events:none}@media (any-hover: hover){:host(:focus) .picker-opts{outline:none;background:rgba(var(--ion-color-base-rgb), 0.2)}}";
const PickerColumn = class {
  constructor(hostRef) {
    (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.ionChange = (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.d)(this, "ionChange", 7);
    this.isScrolling = false;
    this.isColumnVisible = false;
    this.canExitInputMode = true;
    this.updateValueTextOnScroll = false;
    this.ariaLabel = null;
    this.isActive = false;
    /**
     * If `true`, the user cannot interact with the picker.
     */
    this.disabled = false;
    /**
     * The color to use from your application's color palette.
     * Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     * For more information on colors, see [theming](/docs/theming/basics).
     */
    this.color = 'primary';
    /**
     * If `true`, tapping the picker will
     * reveal a number input keyboard that lets
     * the user type in values for each picker
     * column. This is useful when working
     * with time pickers.
     *
     * @internal
     */
    this.numericInput = false;
    this.centerPickerItemInView = (target, smooth = true, canExitInputMode = true) => {
      const {
        isColumnVisible,
        scrollEl
      } = this;
      if (isColumnVisible && scrollEl) {
        // (Vertical offset from parent) - (three empty picker rows) + (half the height of the target to ensure the scroll triggers)
        const top = target.offsetTop - 3 * target.clientHeight + target.clientHeight / 2;
        if (scrollEl.scrollTop !== top) {
          /**
           * Setting this flag prevents input
           * mode from exiting in the picker column's
           * scroll callback. This is useful when the user manually
           * taps an item or types on the keyboard as both
           * of these can cause a scroll to occur.
           */
          this.canExitInputMode = canExitInputMode;
          this.updateValueTextOnScroll = false;
          scrollEl.scroll({
            top,
            left: 0,
            behavior: smooth ? 'smooth' : undefined
          });
        }
      }
    };
    this.setPickerItemActiveState = (item, isActive) => {
      if (isActive) {
        item.classList.add(PICKER_ITEM_ACTIVE_CLASS);
      } else {
        item.classList.remove(PICKER_ITEM_ACTIVE_CLASS);
      }
    };
    /**
     * When ionInputModeChange is emitted, each column
     * needs to check if it is the one being made available
     * for text entry.
     */
    this.inputModeChange = ev => {
      if (!this.numericInput) {
        return;
      }
      const {
        useInputMode,
        inputModeColumn
      } = ev.detail;
      /**
       * If inputModeColumn is undefined then this means
       * all numericInput columns are being selected.
       */
      const isColumnActive = inputModeColumn === undefined || inputModeColumn === this.el;
      if (!useInputMode || !isColumnActive) {
        this.setInputModeActive(false);
        return;
      }
      this.setInputModeActive(true);
    };
    /**
     * Setting isActive will cause a re-render.
     * As a result, we do not want to cause the
     * re-render mid scroll as this will cause
     * the picker column to jump back to
     * whatever value was selected at the
     * start of the scroll interaction.
     */
    this.setInputModeActive = state => {
      if (this.isScrolling) {
        this.scrollEndCallback = () => {
          this.isActive = state;
        };
        return;
      }
      this.isActive = state;
    };
    /**
     * When the column scrolls, the component
     * needs to determine which item is centered
     * in the view and will emit an ionChange with
     * the item object.
     */
    this.initializeScrollListener = () => {
      /**
       * The haptics for the wheel picker are
       * an iOS-only feature. As a result, they should
       * be disabled on Android.
       */
      const enableHaptics = (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.a)('ios');
      const {
        el,
        scrollEl
      } = this;
      let timeout;
      let activeEl = this.activeItem;
      const scrollCallback = () => {
        (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.r)(() => {
          var _a;
          if (!scrollEl) return;
          if (timeout) {
            clearTimeout(timeout);
            timeout = undefined;
          }
          if (!this.isScrolling) {
            enableHaptics && (0,_haptic_DzAMWJuk_js__WEBPACK_IMPORTED_MODULE_4__.b)();
            this.isScrolling = true;
          }
          /**
           * Select item in the center of the column
           * which is the month/year that we want to select
           */
          const bbox = scrollEl.getBoundingClientRect();
          const centerX = bbox.x + bbox.width / 2;
          const centerY = bbox.y + bbox.height / 2;
          /**
           * elementFromPoint returns the top-most element.
           * This means that if an ion-backdrop is overlaying the
           * picker then the appropriate picker column option will
           * not be selected. To account for this, we use elementsFromPoint
           * and use an Array.find to find the appropriate column option
           * at that point.
           *
           * Additionally, the picker column could be used in the
           * Shadow DOM (i.e. in ion-datetime) so we need to make
           * sure we are choosing the correct host otherwise
           * the elements returns by elementsFromPoint will be
           * retargeted. To account for this, we check to see
           * if the picker column has a parent shadow root. If
           * so, we use that shadow root when doing elementsFromPoint.
           * Otherwise, we just use the document.
           */
          const rootNode = el.getRootNode();
          const hasParentShadow = rootNode instanceof ShadowRoot;
          const referenceNode = hasParentShadow ? rootNode : _index_ZjP4CjeZ_js__WEBPACK_IMPORTED_MODULE_2__.d;
          /**
           * If the reference node is undefined
           * then it's likely that doc is undefined
           * due to being in an SSR environment.
           */
          if (referenceNode === undefined) {
            return;
          }
          const elementsAtPoint = referenceNode.elementsFromPoint(centerX, centerY);
          /**
           * elementsFromPoint can returns multiple elements
           * so find the relevant picker column option if one exists.
           */
          let newActiveElement = elementsAtPoint.find(el => el.tagName === 'ION-PICKER-COLUMN-OPTION');
          /**
           * TODO(FW-6594): Remove this workaround when iOS 16 is no longer
           * supported.
           *
           * If `elementsFromPoint` failed to find the active element (a known
           * issue on iOS 16 when elements are in a Shadow DOM and the
           * referenceNode is the document), a fallback to `elementFromPoint`
           * is used. While `elementsFromPoint` returns all elements,
           * `elementFromPoint` returns only the top-most, which is sufficient
           * for this use case and appears to handle Shadow DOM retargeting
           * more reliably in this specific iOS bug.
           */
          if (newActiveElement === undefined) {
            const fallbackActiveElement = referenceNode.elementFromPoint(centerX, centerY);
            if ((fallbackActiveElement === null || fallbackActiveElement === void 0 ? void 0 : fallbackActiveElement.tagName) === 'ION-PICKER-COLUMN-OPTION') {
              newActiveElement = fallbackActiveElement;
            }
          }
          if (activeEl !== undefined) {
            this.setPickerItemActiveState(activeEl, false);
          }
          if (newActiveElement === undefined || newActiveElement.disabled) {
            return;
          }
          /**
           * If we are selecting a new value,
           * we need to run haptics again.
           */
          if (newActiveElement !== activeEl) {
            enableHaptics && (0,_haptic_DzAMWJuk_js__WEBPACK_IMPORTED_MODULE_4__.a)();
            if (this.canExitInputMode) {
              /**
               * The native iOS wheel picker
               * only dismisses the keyboard
               * once the selected item has changed
               * as a result of a swipe
               * from the user. If `canExitInputMode` is
               * `false` then this means that the
               * scroll is happening as a result of
               * the `value` property programmatically changing
               * either by an application or by the user via the keyboard.
               */
              this.exitInputMode();
            }
          }
          activeEl = newActiveElement;
          this.setPickerItemActiveState(newActiveElement, true);
          /**
           * Set the aria-valuetext even though the value prop has not been updated yet.
           * This enables some screen readers to announce the value as the users drag
           * as opposed to when their release their pointer from the screen.
           *
           * When the value is programmatically updated, we will smoothly scroll
           * to the new option. However, we do not want to update aria-valuetext mid-scroll
           * as that can cause the old value to be briefly set before being set to the
           * correct option. This will cause some screen readers to announce the old value
           * again before announcing the new value. The correct valuetext will be set on render.
           */
          if (this.updateValueTextOnScroll) {
            (_a = this.assistiveFocusable) === null || _a === void 0 ? void 0 : _a.setAttribute('aria-valuetext', this.getOptionValueText(newActiveElement));
          }
          timeout = setTimeout(() => {
            this.isScrolling = false;
            this.updateValueTextOnScroll = true;
            enableHaptics && (0,_haptic_DzAMWJuk_js__WEBPACK_IMPORTED_MODULE_4__.h)();
            /**
             * Certain tasks (such as those that
             * cause re-renders) should only be done
             * once scrolling has finished, otherwise
             * flickering may occur.
             */
            const {
              scrollEndCallback
            } = this;
            if (scrollEndCallback) {
              scrollEndCallback();
              this.scrollEndCallback = undefined;
            }
            /**
             * Reset this flag as the
             * next scroll interaction could
             * be a scroll from the user. In this
             * case, we should exit input mode.
             */
            this.canExitInputMode = true;
            this.setValue(newActiveElement.value);
          }, 250);
        });
      };
      /**
       * Wrap this in an raf so that the scroll callback
       * does not fire when component is initially shown.
       */
      (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.r)(() => {
        if (!scrollEl) return;
        scrollEl.addEventListener('scroll', scrollCallback);
        this.destroyScrollListener = () => {
          scrollEl.removeEventListener('scroll', scrollCallback);
        };
      });
    };
    /**
     * Tells the parent picker to
     * exit text entry mode. This is only called
     * when the selected item changes during scroll, so
     * we know that the user likely wants to scroll
     * instead of type.
     */
    this.exitInputMode = () => {
      const {
        parentEl
      } = this;
      if (parentEl == null) return;
      parentEl.exitInputMode();
      /**
       * setInputModeActive only takes
       * effect once scrolling stops to avoid
       * a component re-render while scrolling.
       * However, we want the visual active
       * indicator to go away immediately, so
       * we call classList.remove here.
       */
      this.el.classList.remove('picker-column-active');
    };
    /**
     * Find the next enabled option after the active option.
     * @param stride - How many options to "jump" over in order to select the next option.
     * This can be used to implement PageUp/PageDown behaviors where pressing these keys
     * scrolls the picker by more than 1 option. For example, a stride of 5 means select
     * the enabled option 5 options after the active one. Note that the actual option selected
     * may be past the stride if the option at the stride is disabled.
     */
    this.findNextOption = (stride = 1) => {
      const {
        activeItem
      } = this;
      if (!activeItem) return null;
      let prevNode = activeItem;
      let node = activeItem.nextElementSibling;
      while (node != null) {
        if (stride > 0) {
          stride--;
        }
        if (node.tagName === 'ION-PICKER-COLUMN-OPTION' && !node.disabled && stride === 0) {
          return node;
        }
        prevNode = node;
        // Use nextElementSibling instead of nextSibling to avoid text/comment nodes
        node = node.nextElementSibling;
      }
      return prevNode;
    };
    /**
     * Find the next enabled option after the active option.
     * @param stride - How many options to "jump" over in order to select the next option.
     * This can be used to implement PageUp/PageDown behaviors where pressing these keys
     * scrolls the picker by more than 1 option. For example, a stride of 5 means select
     * the enabled option 5 options before the active one. Note that the actual option selected
     *  may be past the stride if the option at the stride is disabled.
     */
    this.findPreviousOption = (stride = 1) => {
      const {
        activeItem
      } = this;
      if (!activeItem) return null;
      let nextNode = activeItem;
      let node = activeItem.previousElementSibling;
      while (node != null) {
        if (stride > 0) {
          stride--;
        }
        if (node.tagName === 'ION-PICKER-COLUMN-OPTION' && !node.disabled && stride === 0) {
          return node;
        }
        nextNode = node;
        // Use previousElementSibling instead of previousSibling to avoid text/comment nodes
        node = node.previousElementSibling;
      }
      return nextNode;
    };
    this.onKeyDown = ev => {
      /**
       * The below operations should be inverted when running on a mobile device.
       * For example, swiping up will dispatch an "ArrowUp" event. On desktop,
       * this should cause the previous option to be selected. On mobile, swiping
       * up causes a view to scroll down. As a result, swiping up on mobile should
       * cause the next option to be selected. The Home/End operations remain
       * unchanged because those always represent the first/last options, respectively.
       */
      const mobile = (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.a)('mobile');
      let newOption = null;
      switch (ev.key) {
        case 'ArrowDown':
          newOption = mobile ? this.findPreviousOption() : this.findNextOption();
          break;
        case 'ArrowUp':
          newOption = mobile ? this.findNextOption() : this.findPreviousOption();
          break;
        case 'PageUp':
          newOption = mobile ? this.findNextOption(5) : this.findPreviousOption(5);
          break;
        case 'PageDown':
          newOption = mobile ? this.findPreviousOption(5) : this.findNextOption(5);
          break;
        case 'Home':
          /**
           * There is no guarantee that the first child will be an ion-picker-column-option,
           * so we do not use firstElementChild.
           */
          newOption = this.el.querySelector('ion-picker-column-option:first-of-type');
          break;
        case 'End':
          /**
           * There is no guarantee that the last child will be an ion-picker-column-option,
           * so we do not use lastElementChild.
           */
          newOption = this.el.querySelector('ion-picker-column-option:last-of-type');
          break;
      }
      if (newOption !== null) {
        this.setValue(newOption.value);
        // This stops any default browser behavior such as scrolling
        ev.preventDefault();
      }
    };
    /**
     * Utility to generate the correct text for aria-valuetext.
     */
    this.getOptionValueText = el => {
      var _a;
      return el ? (_a = el.getAttribute('aria-label')) !== null && _a !== void 0 ? _a : el.innerText : '';
    };
    /**
     * Render an element that overlays the column. This element is for assistive
     * tech to allow users to navigate the column up/down. This element should receive
     * focus as it listens for synthesized keyboard events as required by the
     * slider role: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/slider_role
     */
    this.renderAssistiveFocusable = () => {
      const {
        activeItem
      } = this;
      const valueText = this.getOptionValueText(activeItem);
      /**
       * When using the picker, the valuetext provides important context that valuenow
       * does not. Additionally, using non-zero valuemin/valuemax values can cause
       * WebKit to incorrectly announce numeric valuetext values (such as a year
       * like "2024") as percentages: https://bugs.webkit.org/show_bug.cgi?id=273126
       */
      return (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
        ref: el => this.assistiveFocusable = el,
        class: "assistive-focusable",
        role: "slider",
        tabindex: this.disabled ? undefined : 0,
        "aria-label": this.ariaLabel,
        "aria-valuemin": 0,
        "aria-valuemax": 0,
        "aria-valuenow": 0,
        "aria-valuetext": valueText,
        "aria-orientation": "vertical",
        onKeyDown: ev => this.onKeyDown(ev)
      });
    };
  }
  ariaLabelChanged(newValue) {
    this.ariaLabel = newValue;
  }
  valueChange() {
    if (this.isColumnVisible) {
      /**
       * Only scroll the active item into view when the picker column
       * is actively visible to the user.
       */
      this.scrollActiveItemIntoView(true);
    }
  }
  /**
   * Only setup scroll listeners
   * when the picker is visible, otherwise
   * the container will have a scroll
   * height of 0px.
   */
  componentWillLoad() {
    /**
     * We cache parentEl in a local variable
     * so we don't need to keep accessing
     * the class variable (which comes with
     * a small performance hit)
     */
    const parentEl = this.parentEl = this.el.closest('ion-picker');
    const visibleCallback = entries => {
      /**
       * Browsers will sometimes group multiple IO events into a single callback.
       * As a result, we want to grab the last/most recent event in case there are multiple events.
       */
      const ev = entries[entries.length - 1];
      if (ev.isIntersecting) {
        const {
          activeItem,
          el
        } = this;
        this.isColumnVisible = true;
        /**
         * Because this initial call to scrollActiveItemIntoView has to fire before
         * the scroll listener is set up, we need to manage the active class manually.
         */
        const oldActive = (0,_helpers_1O4D2b7y_js__WEBPACK_IMPORTED_MODULE_3__.g)(el).querySelector(`.${PICKER_ITEM_ACTIVE_CLASS}`);
        if (oldActive) {
          this.setPickerItemActiveState(oldActive, false);
        }
        this.scrollActiveItemIntoView();
        if (activeItem) {
          this.setPickerItemActiveState(activeItem, true);
        }
        this.initializeScrollListener();
      } else {
        this.isColumnVisible = false;
        if (this.destroyScrollListener) {
          this.destroyScrollListener();
          this.destroyScrollListener = undefined;
        }
      }
    };
    /**
     * Set the root to be the parent picker element
     * This causes the IO callback
     * to be fired in WebKit as soon as the element
     * is visible. If we used the default root value
     * then WebKit would only fire the IO callback
     * after any animations (such as a modal transition)
     * finished, and there would potentially be a flicker.
     */
    new IntersectionObserver(visibleCallback, {
      threshold: 0.001,
      root: this.parentEl
    }).observe(this.el);
    if (parentEl !== null) {
      // TODO(FW-2832): type
      parentEl.addEventListener('ionInputModeChange', ev => this.inputModeChange(ev));
    }
  }
  componentDidRender() {
    const {
      el,
      activeItem,
      isColumnVisible,
      value
    } = this;
    if (isColumnVisible && !activeItem) {
      const firstOption = el.querySelector('ion-picker-column-option');
      /**
       * If the picker column does not have an active item and the current value
       * does not match the first item in the picker column, that means
       * the value is out of bounds. In this case, we assign the value to the
       * first item to match the scroll position of the column.
       *
       */
      if (firstOption !== null && firstOption.value !== value) {
        this.setValue(firstOption.value);
      }
    }
  }
  /** @internal  */
  scrollActiveItemIntoView() {
    var _this = this;
    return (0,C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (smooth = false) {
      const activeEl = _this.activeItem;
      if (activeEl) {
        _this.centerPickerItemInView(activeEl, smooth, false);
      }
    }).apply(this, arguments);
  }
  /**
   * Sets the value prop and fires the ionChange event.
   * This is used when we need to fire ionChange from
   * user-generated events that cannot be caught with normal
   * input/change event listeners.
   * @internal
   */
  setValue(value) {
    var _this2 = this;
    return (0,C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this2.disabled === true || _this2.value === value) {
        return;
      }
      _this2.value = value;
      _this2.ionChange.emit({
        value
      });
    })();
  }
  /**
   * Sets focus on the scrollable container within the picker column.
   * Use this method instead of the global `pickerColumn.focus()`.
   */
  setFocus() {
    var _this3 = this;
    return (0,C_Users_Faizan_Desktop_Desktop_Projects_tactical_trap_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this3.assistiveFocusable) {
        _this3.assistiveFocusable.focus();
      }
    })();
  }
  connectedCallback() {
    var _a;
    this.ariaLabel = (_a = this.el.getAttribute('aria-label')) !== null && _a !== void 0 ? _a : 'Select a value';
  }
  get activeItem() {
    const {
      value
    } = this;
    const options = Array.from(this.el.querySelectorAll('ion-picker-column-option'));
    return options.find(option => {
      /**
       * If the whole picker column is disabled, the current value should appear active
       * If the current value item is specifically disabled, it should not appear active
       */
      if (!this.disabled && option.disabled) {
        return false;
      }
      return option.value === value;
    });
  }
  render() {
    const {
      color,
      disabled,
      isActive,
      numericInput
    } = this;
    const mode = (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.e)(this);
    return (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)(_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.j, {
      key: 'ea0280355b2f87895bf7dddd289ccf473aa759f3',
      class: (0,_theme_DiVJyqlX_js__WEBPACK_IMPORTED_MODULE_5__.c)(color, {
        [mode]: true,
        ['picker-column-active']: isActive,
        ['picker-column-numeric-input']: numericInput,
        ['picker-column-disabled']: disabled
      })
    }, this.renderAssistiveFocusable(), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      key: '482992131cdeb85b1f61430d7fe1322a16345769',
      name: "prefix"
    }), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      key: '43f7f80d621d411ef366b3ca1396299e8c9a0c97',
      "aria-hidden": "true",
      class: "picker-opts",
      ref: el => {
        this.scrollEl = el;
      },
      /**
       * When an element has an overlay scroll style and
       * a fixed height, Firefox will focus the scrollable
       * container if the content exceeds the container's
       * dimensions.
       *
       * This causes keyboard navigation to focus to this
       * element instead of going to the next element in
       * the tab order.
       *
       * The desired behavior is for the user to be able to
       * focus the assistive focusable element and tab to
       * the next element in the tab order. Instead of tabbing
       * to this element.
       *
       * To prevent this, we set the tabIndex to -1. This
       * will match the behavior of the other browsers.
       */
      tabIndex: -1
    }, (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      key: '13a9ee686132af32240710730765de4c0003a9e8',
      class: "picker-item-empty",
      "aria-hidden": "true"
    }, "\u00A0"), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      key: 'dbccba4920833cfcebe9b0fc763458ec3053705a',
      class: "picker-item-empty",
      "aria-hidden": "true"
    }, "\u00A0"), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      key: '682b43f83a5ea2e46067457f3af118535e111edb',
      class: "picker-item-empty",
      "aria-hidden": "true"
    }, "\u00A0"), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      key: 'd27e1e1dc0504b2f4627a29912a05bb91e8e413a'
    }), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      key: '61c948dbb9cf7469aed3018542bc0954211585ba',
      class: "picker-item-empty",
      "aria-hidden": "true"
    }, "\u00A0"), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      key: 'cf46c277fbee65e35ff44ce0d53ce12aa9cbf9db',
      class: "picker-item-empty",
      "aria-hidden": "true"
    }, "\u00A0"), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      key: 'bbc0e2d491d3f836ab849493ade2f7fa6ad9244e',
      class: "picker-item-empty",
      "aria-hidden": "true"
    }, "\u00A0")), (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      key: 'd25cbbe14b2914fe7b878d43b4e3f4a8c8177d24',
      name: "suffix"
    }));
  }
  get el() {
    return (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_1__.k)(this);
  }
  static get watchers() {
    return {
      "aria-label": ["ariaLabelChanged"],
      "value": ["valueChange"]
    };
  }
};
const PICKER_ITEM_ACTIVE_CLASS = 'option-active';
PickerColumn.style = pickerColumnCss;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW9uLXBpY2tlci1jb2x1bW5fZW50cnlfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQytJO0FBQ2hHO0FBQ3VCO0FBQ2lEO0FBQ3pEO0FBQzdCO0FBRWpDLE1BQU11QixlQUFlLEdBQUcsNG1FQUE0bUU7QUFFcG9FLE1BQU1DLFlBQVksR0FBRyxNQUFNO0VBQ3ZCQyxXQUFXQSxDQUFDQyxPQUFPLEVBQUU7SUFDakJ6QixxREFBZ0IsQ0FBQyxJQUFJLEVBQUV5QixPQUFPLENBQUM7SUFDL0IsSUFBSSxDQUFDQyxTQUFTLEdBQUd4QixxREFBVyxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELElBQUksQ0FBQ3lCLFdBQVcsR0FBRyxLQUFLO0lBQ3hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLEtBQUs7SUFDNUIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJO0lBQzVCLElBQUksQ0FBQ0MsdUJBQXVCLEdBQUcsS0FBSztJQUNwQyxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJO0lBQ3JCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEtBQUs7SUFDckI7QUFDUjtBQUNBO0lBQ1EsSUFBSSxDQUFDQyxRQUFRLEdBQUcsS0FBSztJQUNyQjtBQUNSO0FBQ0E7QUFDQTtBQUNBO0lBQ1EsSUFBSSxDQUFDQyxLQUFLLEdBQUcsU0FBUztJQUN0QjtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDUSxJQUFJLENBQUNDLFlBQVksR0FBRyxLQUFLO0lBQ3pCLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsQ0FBQ0MsTUFBTSxFQUFFQyxNQUFNLEdBQUcsSUFBSSxFQUFFVCxnQkFBZ0IsR0FBRyxJQUFJLEtBQUs7TUFDOUUsTUFBTTtRQUFFRCxlQUFlO1FBQUVXO01BQVMsQ0FBQyxHQUFHLElBQUk7TUFDMUMsSUFBSVgsZUFBZSxJQUFJVyxRQUFRLEVBQUU7UUFDN0I7UUFDQSxNQUFNQyxHQUFHLEdBQUdILE1BQU0sQ0FBQ0ksU0FBUyxHQUFHLENBQUMsR0FBR0osTUFBTSxDQUFDSyxZQUFZLEdBQUdMLE1BQU0sQ0FBQ0ssWUFBWSxHQUFHLENBQUM7UUFDaEYsSUFBSUgsUUFBUSxDQUFDSSxTQUFTLEtBQUtILEdBQUcsRUFBRTtVQUM1QjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7VUFDb0IsSUFBSSxDQUFDWCxnQkFBZ0IsR0FBR0EsZ0JBQWdCO1VBQ3hDLElBQUksQ0FBQ0MsdUJBQXVCLEdBQUcsS0FBSztVQUNwQ1MsUUFBUSxDQUFDSyxNQUFNLENBQUM7WUFDWkosR0FBRztZQUNISyxJQUFJLEVBQUUsQ0FBQztZQUNQQyxRQUFRLEVBQUVSLE1BQU0sR0FBRyxRQUFRLEdBQUdTO1VBQ2xDLENBQUMsQ0FBQztRQUNOO01BQ0o7SUFDSixDQUFDO0lBQ0QsSUFBSSxDQUFDQyx3QkFBd0IsR0FBRyxDQUFDQyxJQUFJLEVBQUVqQixRQUFRLEtBQUs7TUFDaEQsSUFBSUEsUUFBUSxFQUFFO1FBQ1ZpQixJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDQyx3QkFBd0IsQ0FBQztNQUNoRCxDQUFDLE1BQ0k7UUFDREgsSUFBSSxDQUFDQyxTQUFTLENBQUNHLE1BQU0sQ0FBQ0Qsd0JBQXdCLENBQUM7TUFDbkQ7SUFDSixDQUFDO0lBQ0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtJQUNRLElBQUksQ0FBQ0UsZUFBZSxHQUFJQyxFQUFFLElBQUs7TUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQ3BCLFlBQVksRUFBRTtRQUNwQjtNQUNKO01BQ0EsTUFBTTtRQUFFcUIsWUFBWTtRQUFFQztNQUFnQixDQUFDLEdBQUdGLEVBQUUsQ0FBQ0csTUFBTTtNQUNuRDtBQUNaO0FBQ0E7QUFDQTtNQUNZLE1BQU1DLGNBQWMsR0FBR0YsZUFBZSxLQUFLVixTQUFTLElBQUlVLGVBQWUsS0FBSyxJQUFJLENBQUNHLEVBQUU7TUFDbkYsSUFBSSxDQUFDSixZQUFZLElBQUksQ0FBQ0csY0FBYyxFQUFFO1FBQ2xDLElBQUksQ0FBQ0Usa0JBQWtCLENBQUMsS0FBSyxDQUFDO1FBQzlCO01BQ0o7TUFDQSxJQUFJLENBQUNBLGtCQUFrQixDQUFDLElBQUksQ0FBQztJQUNqQyxDQUFDO0lBQ0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNRLElBQUksQ0FBQ0Esa0JBQWtCLEdBQUlDLEtBQUssSUFBSztNQUNqQyxJQUFJLElBQUksQ0FBQ25DLFdBQVcsRUFBRTtRQUNsQixJQUFJLENBQUNvQyxpQkFBaUIsR0FBRyxNQUFNO1VBQzNCLElBQUksQ0FBQy9CLFFBQVEsR0FBRzhCLEtBQUs7UUFDekIsQ0FBQztRQUNEO01BQ0o7TUFDQSxJQUFJLENBQUM5QixRQUFRLEdBQUc4QixLQUFLO0lBQ3pCLENBQUM7SUFDRDtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDUSxJQUFJLENBQUNFLHdCQUF3QixHQUFHLE1BQU07TUFDbEM7QUFDWjtBQUNBO0FBQ0E7QUFDQTtNQUNZLE1BQU1DLGFBQWEsR0FBRzdELHFEQUFVLENBQUMsS0FBSyxDQUFDO01BQ3ZDLE1BQU07UUFBRXdELEVBQUU7UUFBRXJCO01BQVMsQ0FBQyxHQUFHLElBQUk7TUFDN0IsSUFBSTJCLE9BQU87TUFDWCxJQUFJQyxRQUFRLEdBQUcsSUFBSSxDQUFDQyxVQUFVO01BQzlCLE1BQU1DLGNBQWMsR0FBR0EsQ0FBQSxLQUFNO1FBQ3pCeEQsdURBQUcsQ0FBQyxNQUFNO1VBQ04sSUFBSXlELEVBQUU7VUFDTixJQUFJLENBQUMvQixRQUFRLEVBQ1Q7VUFDSixJQUFJMkIsT0FBTyxFQUFFO1lBQ1RLLFlBQVksQ0FBQ0wsT0FBTyxDQUFDO1lBQ3JCQSxPQUFPLEdBQUduQixTQUFTO1VBQ3ZCO1VBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ3BCLFdBQVcsRUFBRTtZQUNuQnNDLGFBQWEsSUFBSWhELHNEQUFvQixDQUFDLENBQUM7WUFDdkMsSUFBSSxDQUFDVSxXQUFXLEdBQUcsSUFBSTtVQUMzQjtVQUNBO0FBQ3BCO0FBQ0E7QUFDQTtVQUNvQixNQUFNNkMsSUFBSSxHQUFHakMsUUFBUSxDQUFDa0MscUJBQXFCLENBQUMsQ0FBQztVQUM3QyxNQUFNQyxPQUFPLEdBQUdGLElBQUksQ0FBQ0csQ0FBQyxHQUFHSCxJQUFJLENBQUNJLEtBQUssR0FBRyxDQUFDO1VBQ3ZDLE1BQU1DLE9BQU8sR0FBR0wsSUFBSSxDQUFDTSxDQUFDLEdBQUdOLElBQUksQ0FBQ08sTUFBTSxHQUFHLENBQUM7VUFDeEM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7VUFDb0IsTUFBTUMsUUFBUSxHQUFHcEIsRUFBRSxDQUFDcUIsV0FBVyxDQUFDLENBQUM7VUFDakMsTUFBTUMsZUFBZSxHQUFHRixRQUFRLFlBQVlHLFVBQVU7VUFDdEQsTUFBTUMsYUFBYSxHQUFHRixlQUFlLEdBQUdGLFFBQVEsR0FBR3BFLGlEQUFHO1VBQ3REO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO1VBQ29CLElBQUl3RSxhQUFhLEtBQUtyQyxTQUFTLEVBQUU7WUFDN0I7VUFDSjtVQUNBLE1BQU1zQyxlQUFlLEdBQUdELGFBQWEsQ0FBQ0UsaUJBQWlCLENBQUNaLE9BQU8sRUFBRUcsT0FBTyxDQUFDO1VBQ3pFO0FBQ3BCO0FBQ0E7QUFDQTtVQUNvQixJQUFJVSxnQkFBZ0IsR0FBR0YsZUFBZSxDQUFDRyxJQUFJLENBQUU1QixFQUFFLElBQUtBLEVBQUUsQ0FBQzZCLE9BQU8sS0FBSywwQkFBMEIsQ0FBQztVQUM5RjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO1VBQ29CLElBQUlGLGdCQUFnQixLQUFLeEMsU0FBUyxFQUFFO1lBQ2hDLE1BQU0yQyxxQkFBcUIsR0FBR04sYUFBYSxDQUFDTyxnQkFBZ0IsQ0FBQ2pCLE9BQU8sRUFBRUcsT0FBTyxDQUFDO1lBQzlFLElBQUksQ0FBQ2EscUJBQXFCLEtBQUssSUFBSSxJQUFJQSxxQkFBcUIsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBR0EscUJBQXFCLENBQUNELE9BQU8sTUFBTSwwQkFBMEIsRUFBRTtjQUM5SUYsZ0JBQWdCLEdBQUdHLHFCQUFxQjtZQUM1QztVQUNKO1VBQ0EsSUFBSXZCLFFBQVEsS0FBS3BCLFNBQVMsRUFBRTtZQUN4QixJQUFJLENBQUNDLHdCQUF3QixDQUFDbUIsUUFBUSxFQUFFLEtBQUssQ0FBQztVQUNsRDtVQUNBLElBQUlvQixnQkFBZ0IsS0FBS3hDLFNBQVMsSUFBSXdDLGdCQUFnQixDQUFDdEQsUUFBUSxFQUFFO1lBQzdEO1VBQ0o7VUFDQTtBQUNwQjtBQUNBO0FBQ0E7VUFDb0IsSUFBSXNELGdCQUFnQixLQUFLcEIsUUFBUSxFQUFFO1lBQy9CRixhQUFhLElBQUkvQyxzREFBc0IsQ0FBQyxDQUFDO1lBQ3pDLElBQUksSUFBSSxDQUFDVyxnQkFBZ0IsRUFBRTtjQUN2QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtjQUM0QixJQUFJLENBQUMrRCxhQUFhLENBQUMsQ0FBQztZQUN4QjtVQUNKO1VBQ0F6QixRQUFRLEdBQUdvQixnQkFBZ0I7VUFDM0IsSUFBSSxDQUFDdkMsd0JBQXdCLENBQUN1QyxnQkFBZ0IsRUFBRSxJQUFJLENBQUM7VUFDckQ7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7VUFDb0IsSUFBSSxJQUFJLENBQUN6RCx1QkFBdUIsRUFBRTtZQUM5QixDQUFDd0MsRUFBRSxHQUFHLElBQUksQ0FBQ3VCLGtCQUFrQixNQUFNLElBQUksSUFBSXZCLEVBQUUsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBR0EsRUFBRSxDQUFDd0IsWUFBWSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNSLGdCQUFnQixDQUFDLENBQUM7VUFDcEo7VUFDQXJCLE9BQU8sR0FBRzhCLFVBQVUsQ0FBQyxNQUFNO1lBQ3ZCLElBQUksQ0FBQ3JFLFdBQVcsR0FBRyxLQUFLO1lBQ3hCLElBQUksQ0FBQ0csdUJBQXVCLEdBQUcsSUFBSTtZQUNuQ21DLGFBQWEsSUFBSTlDLHNEQUFrQixDQUFDLENBQUM7WUFDckM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtZQUN3QixNQUFNO2NBQUU0QztZQUFrQixDQUFDLEdBQUcsSUFBSTtZQUNsQyxJQUFJQSxpQkFBaUIsRUFBRTtjQUNuQkEsaUJBQWlCLENBQUMsQ0FBQztjQUNuQixJQUFJLENBQUNBLGlCQUFpQixHQUFHaEIsU0FBUztZQUN0QztZQUNBO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7WUFDd0IsSUFBSSxDQUFDbEIsZ0JBQWdCLEdBQUcsSUFBSTtZQUM1QixJQUFJLENBQUNvRSxRQUFRLENBQUNWLGdCQUFnQixDQUFDVyxLQUFLLENBQUM7VUFDekMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNYLENBQUMsQ0FBQztNQUNOLENBQUM7TUFDRDtBQUNaO0FBQ0E7QUFDQTtNQUNZckYsdURBQUcsQ0FBQyxNQUFNO1FBQ04sSUFBSSxDQUFDMEIsUUFBUSxFQUNUO1FBQ0pBLFFBQVEsQ0FBQzRELGdCQUFnQixDQUFDLFFBQVEsRUFBRTlCLGNBQWMsQ0FBQztRQUNuRCxJQUFJLENBQUMrQixxQkFBcUIsR0FBRyxNQUFNO1VBQy9CN0QsUUFBUSxDQUFDOEQsbUJBQW1CLENBQUMsUUFBUSxFQUFFaEMsY0FBYyxDQUFDO1FBQzFELENBQUM7TUFDTCxDQUFDLENBQUM7SUFDTixDQUFDO0lBQ0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDUSxJQUFJLENBQUN1QixhQUFhLEdBQUcsTUFBTTtNQUN2QixNQUFNO1FBQUVVO01BQVMsQ0FBQyxHQUFHLElBQUk7TUFDekIsSUFBSUEsUUFBUSxJQUFJLElBQUksRUFDaEI7TUFDSkEsUUFBUSxDQUFDVixhQUFhLENBQUMsQ0FBQztNQUN4QjtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO01BQ1ksSUFBSSxDQUFDaEMsRUFBRSxDQUFDVixTQUFTLENBQUNHLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQztJQUNwRCxDQUFDO0lBQ0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNRLElBQUksQ0FBQ2tELGNBQWMsR0FBRyxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxLQUFLO01BQ2xDLE1BQU07UUFBRXBDO01BQVcsQ0FBQyxHQUFHLElBQUk7TUFDM0IsSUFBSSxDQUFDQSxVQUFVLEVBQ1gsT0FBTyxJQUFJO01BQ2YsSUFBSXFDLFFBQVEsR0FBR3JDLFVBQVU7TUFDekIsSUFBSXNDLElBQUksR0FBR3RDLFVBQVUsQ0FBQ3VDLGtCQUFrQjtNQUN4QyxPQUFPRCxJQUFJLElBQUksSUFBSSxFQUFFO1FBQ2pCLElBQUlGLE1BQU0sR0FBRyxDQUFDLEVBQUU7VUFDWkEsTUFBTSxFQUFFO1FBQ1o7UUFDQSxJQUFJRSxJQUFJLENBQUNqQixPQUFPLEtBQUssMEJBQTBCLElBQUksQ0FBQ2lCLElBQUksQ0FBQ3pFLFFBQVEsSUFBSXVFLE1BQU0sS0FBSyxDQUFDLEVBQUU7VUFDL0UsT0FBT0UsSUFBSTtRQUNmO1FBQ0FELFFBQVEsR0FBR0MsSUFBSTtRQUNmO1FBQ0FBLElBQUksR0FBR0EsSUFBSSxDQUFDQyxrQkFBa0I7TUFDbEM7TUFDQSxPQUFPRixRQUFRO0lBQ25CLENBQUM7SUFDRDtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ1EsSUFBSSxDQUFDRyxrQkFBa0IsR0FBRyxDQUFDSixNQUFNLEdBQUcsQ0FBQyxLQUFLO01BQ3RDLE1BQU07UUFBRXBDO01BQVcsQ0FBQyxHQUFHLElBQUk7TUFDM0IsSUFBSSxDQUFDQSxVQUFVLEVBQ1gsT0FBTyxJQUFJO01BQ2YsSUFBSXlDLFFBQVEsR0FBR3pDLFVBQVU7TUFDekIsSUFBSXNDLElBQUksR0FBR3RDLFVBQVUsQ0FBQzBDLHNCQUFzQjtNQUM1QyxPQUFPSixJQUFJLElBQUksSUFBSSxFQUFFO1FBQ2pCLElBQUlGLE1BQU0sR0FBRyxDQUFDLEVBQUU7VUFDWkEsTUFBTSxFQUFFO1FBQ1o7UUFDQSxJQUFJRSxJQUFJLENBQUNqQixPQUFPLEtBQUssMEJBQTBCLElBQUksQ0FBQ2lCLElBQUksQ0FBQ3pFLFFBQVEsSUFBSXVFLE1BQU0sS0FBSyxDQUFDLEVBQUU7VUFDL0UsT0FBT0UsSUFBSTtRQUNmO1FBQ0FHLFFBQVEsR0FBR0gsSUFBSTtRQUNmO1FBQ0FBLElBQUksR0FBR0EsSUFBSSxDQUFDSSxzQkFBc0I7TUFDdEM7TUFDQSxPQUFPRCxRQUFRO0lBQ25CLENBQUM7SUFDRCxJQUFJLENBQUNFLFNBQVMsR0FBSXhELEVBQUUsSUFBSztNQUNyQjtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO01BQ1ksTUFBTXlELE1BQU0sR0FBRzVHLHFEQUFVLENBQUMsUUFBUSxDQUFDO01BQ25DLElBQUk2RyxTQUFTLEdBQUcsSUFBSTtNQUNwQixRQUFRMUQsRUFBRSxDQUFDMkQsR0FBRztRQUNWLEtBQUssV0FBVztVQUNaRCxTQUFTLEdBQUdELE1BQU0sR0FBRyxJQUFJLENBQUNKLGtCQUFrQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNMLGNBQWMsQ0FBQyxDQUFDO1VBQ3RFO1FBQ0osS0FBSyxTQUFTO1VBQ1ZVLFNBQVMsR0FBR0QsTUFBTSxHQUFHLElBQUksQ0FBQ1QsY0FBYyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNLLGtCQUFrQixDQUFDLENBQUM7VUFDdEU7UUFDSixLQUFLLFFBQVE7VUFDVEssU0FBUyxHQUFHRCxNQUFNLEdBQUcsSUFBSSxDQUFDVCxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDSyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7VUFDeEU7UUFDSixLQUFLLFVBQVU7VUFDWEssU0FBUyxHQUFHRCxNQUFNLEdBQUcsSUFBSSxDQUFDSixrQkFBa0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNMLGNBQWMsQ0FBQyxDQUFDLENBQUM7VUFDeEU7UUFDSixLQUFLLE1BQU07VUFDUDtBQUNwQjtBQUNBO0FBQ0E7VUFDb0JVLFNBQVMsR0FBRyxJQUFJLENBQUNyRCxFQUFFLENBQUN1RCxhQUFhLENBQUMsd0NBQXdDLENBQUM7VUFDM0U7UUFDSixLQUFLLEtBQUs7VUFDTjtBQUNwQjtBQUNBO0FBQ0E7VUFDb0JGLFNBQVMsR0FBRyxJQUFJLENBQUNyRCxFQUFFLENBQUN1RCxhQUFhLENBQUMsdUNBQXVDLENBQUM7VUFDMUU7TUFDUjtNQUNBLElBQUlGLFNBQVMsS0FBSyxJQUFJLEVBQUU7UUFDcEIsSUFBSSxDQUFDaEIsUUFBUSxDQUFDZ0IsU0FBUyxDQUFDZixLQUFLLENBQUM7UUFDOUI7UUFDQTNDLEVBQUUsQ0FBQzZELGNBQWMsQ0FBQyxDQUFDO01BQ3ZCO0lBQ0osQ0FBQztJQUNEO0FBQ1I7QUFDQTtJQUNRLElBQUksQ0FBQ3JCLGtCQUFrQixHQUFJbkMsRUFBRSxJQUFLO01BQzlCLElBQUlVLEVBQUU7TUFDTixPQUFPVixFQUFFLEdBQUcsQ0FBQ1UsRUFBRSxHQUFHVixFQUFFLENBQUN5RCxZQUFZLENBQUMsWUFBWSxDQUFDLE1BQU0sSUFBSSxJQUFJL0MsRUFBRSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxFQUFFLEdBQUdWLEVBQUUsQ0FBQzBELFNBQVMsR0FBRyxFQUFFO0lBQ3ZHLENBQUM7SUFDRDtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDUSxJQUFJLENBQUNDLHdCQUF3QixHQUFHLE1BQU07TUFDbEMsTUFBTTtRQUFFbkQ7TUFBVyxDQUFDLEdBQUcsSUFBSTtNQUMzQixNQUFNb0QsU0FBUyxHQUFHLElBQUksQ0FBQ3pCLGtCQUFrQixDQUFDM0IsVUFBVSxDQUFDO01BQ3JEO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUNZLE9BQVEvRCxxREFBQyxDQUFDLEtBQUssRUFBRTtRQUFFb0gsR0FBRyxFQUFHN0QsRUFBRSxJQUFNLElBQUksQ0FBQ2lDLGtCQUFrQixHQUFHakMsRUFBRztRQUFFOEQsS0FBSyxFQUFFLHFCQUFxQjtRQUFFQyxJQUFJLEVBQUUsUUFBUTtRQUFFQyxRQUFRLEVBQUUsSUFBSSxDQUFDM0YsUUFBUSxHQUFHYyxTQUFTLEdBQUcsQ0FBQztRQUFFLFlBQVksRUFBRSxJQUFJLENBQUNoQixTQUFTO1FBQUUsZUFBZSxFQUFFLENBQUM7UUFBRSxlQUFlLEVBQUUsQ0FBQztRQUFFLGVBQWUsRUFBRSxDQUFDO1FBQUUsZ0JBQWdCLEVBQUV5RixTQUFTO1FBQUUsa0JBQWtCLEVBQUUsVUFBVTtRQUFFVCxTQUFTLEVBQUd4RCxFQUFFLElBQUssSUFBSSxDQUFDd0QsU0FBUyxDQUFDeEQsRUFBRTtNQUFFLENBQUMsQ0FBQztJQUMxVixDQUFDO0VBQ0w7RUFDQXNFLGdCQUFnQkEsQ0FBQ0MsUUFBUSxFQUFFO0lBQ3ZCLElBQUksQ0FBQy9GLFNBQVMsR0FBRytGLFFBQVE7RUFDN0I7RUFDQUMsV0FBV0EsQ0FBQSxFQUFHO0lBQ1YsSUFBSSxJQUFJLENBQUNuRyxlQUFlLEVBQUU7TUFDdEI7QUFDWjtBQUNBO0FBQ0E7TUFDWSxJQUFJLENBQUNvRyx3QkFBd0IsQ0FBQyxJQUFJLENBQUM7SUFDdkM7RUFDSjtFQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxpQkFBaUJBLENBQUEsRUFBRztJQUNoQjtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDUSxNQUFNM0IsUUFBUSxHQUFJLElBQUksQ0FBQ0EsUUFBUSxHQUFHLElBQUksQ0FBQzFDLEVBQUUsQ0FBQ3NFLE9BQU8sQ0FBQyxZQUFZLENBQUU7SUFDaEUsTUFBTUMsZUFBZSxHQUFJQyxPQUFPLElBQUs7TUFDakM7QUFDWjtBQUNBO0FBQ0E7TUFDWSxNQUFNN0UsRUFBRSxHQUFHNkUsT0FBTyxDQUFDQSxPQUFPLENBQUNDLE1BQU0sR0FBRyxDQUFDLENBQUM7TUFDdEMsSUFBSTlFLEVBQUUsQ0FBQytFLGNBQWMsRUFBRTtRQUNuQixNQUFNO1VBQUVsRSxVQUFVO1VBQUVSO1FBQUcsQ0FBQyxHQUFHLElBQUk7UUFDL0IsSUFBSSxDQUFDaEMsZUFBZSxHQUFHLElBQUk7UUFDM0I7QUFDaEI7QUFDQTtBQUNBO1FBQ2dCLE1BQU0yRyxTQUFTLEdBQUd4SCx1REFBYyxDQUFDNkMsRUFBRSxDQUFDLENBQUN1RCxhQUFhLENBQUMsSUFBSS9ELHdCQUF3QixFQUFFLENBQUM7UUFDbEYsSUFBSW1GLFNBQVMsRUFBRTtVQUNYLElBQUksQ0FBQ3ZGLHdCQUF3QixDQUFDdUYsU0FBUyxFQUFFLEtBQUssQ0FBQztRQUNuRDtRQUNBLElBQUksQ0FBQ1Asd0JBQXdCLENBQUMsQ0FBQztRQUMvQixJQUFJNUQsVUFBVSxFQUFFO1VBQ1osSUFBSSxDQUFDcEIsd0JBQXdCLENBQUNvQixVQUFVLEVBQUUsSUFBSSxDQUFDO1FBQ25EO1FBQ0EsSUFBSSxDQUFDSix3QkFBd0IsQ0FBQyxDQUFDO01BQ25DLENBQUMsTUFDSTtRQUNELElBQUksQ0FBQ3BDLGVBQWUsR0FBRyxLQUFLO1FBQzVCLElBQUksSUFBSSxDQUFDd0UscUJBQXFCLEVBQUU7VUFDNUIsSUFBSSxDQUFDQSxxQkFBcUIsQ0FBQyxDQUFDO1VBQzVCLElBQUksQ0FBQ0EscUJBQXFCLEdBQUdyRCxTQUFTO1FBQzFDO01BQ0o7SUFDSixDQUFDO0lBQ0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ1EsSUFBSXlGLG9CQUFvQixDQUFDTCxlQUFlLEVBQUU7TUFBRU0sU0FBUyxFQUFFLEtBQUs7TUFBRUMsSUFBSSxFQUFFLElBQUksQ0FBQ3BDO0lBQVMsQ0FBQyxDQUFDLENBQUNxQyxPQUFPLENBQUMsSUFBSSxDQUFDL0UsRUFBRSxDQUFDO0lBQ3JHLElBQUkwQyxRQUFRLEtBQUssSUFBSSxFQUFFO01BQ25CO01BQ0FBLFFBQVEsQ0FBQ0gsZ0JBQWdCLENBQUMsb0JBQW9CLEVBQUc1QyxFQUFFLElBQUssSUFBSSxDQUFDRCxlQUFlLENBQUNDLEVBQUUsQ0FBQyxDQUFDO0lBQ3JGO0VBQ0o7RUFDQXFGLGtCQUFrQkEsQ0FBQSxFQUFHO0lBQ2pCLE1BQU07TUFBRWhGLEVBQUU7TUFBRVEsVUFBVTtNQUFFeEMsZUFBZTtNQUFFc0U7SUFBTSxDQUFDLEdBQUcsSUFBSTtJQUN2RCxJQUFJdEUsZUFBZSxJQUFJLENBQUN3QyxVQUFVLEVBQUU7TUFDaEMsTUFBTXlFLFdBQVcsR0FBR2pGLEVBQUUsQ0FBQ3VELGFBQWEsQ0FBQywwQkFBMEIsQ0FBQztNQUNoRTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUNZLElBQUkwQixXQUFXLEtBQUssSUFBSSxJQUFJQSxXQUFXLENBQUMzQyxLQUFLLEtBQUtBLEtBQUssRUFBRTtRQUNyRCxJQUFJLENBQUNELFFBQVEsQ0FBQzRDLFdBQVcsQ0FBQzNDLEtBQUssQ0FBQztNQUNwQztJQUNKO0VBQ0o7RUFDQTtFQUNNOEIsd0JBQXdCQSxDQUFBLEVBQWlCO0lBQUEsSUFBQWMsS0FBQTtJQUFBLE9BQUFDLGdLQUFBLFlBQWhCekcsTUFBTSxHQUFHLEtBQUs7TUFDekMsTUFBTTZCLFFBQVEsR0FBRzJFLEtBQUksQ0FBQzFFLFVBQVU7TUFDaEMsSUFBSUQsUUFBUSxFQUFFO1FBQ1YyRSxLQUFJLENBQUMxRyxzQkFBc0IsQ0FBQytCLFFBQVEsRUFBRTdCLE1BQU0sRUFBRSxLQUFLLENBQUM7TUFDeEQ7SUFBQyxHQUFBMEcsS0FBQSxPQUFBQyxTQUFBO0VBQ0w7RUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNVaEQsUUFBUUEsQ0FBQ0MsS0FBSyxFQUFFO0lBQUEsSUFBQWdELE1BQUE7SUFBQSxPQUFBSCxnS0FBQTtNQUNsQixJQUFJRyxNQUFJLENBQUNqSCxRQUFRLEtBQUssSUFBSSxJQUFJaUgsTUFBSSxDQUFDaEQsS0FBSyxLQUFLQSxLQUFLLEVBQUU7UUFDaEQ7TUFDSjtNQUNBZ0QsTUFBSSxDQUFDaEQsS0FBSyxHQUFHQSxLQUFLO01BQ2xCZ0QsTUFBSSxDQUFDeEgsU0FBUyxDQUFDeUgsSUFBSSxDQUFDO1FBQUVqRDtNQUFNLENBQUMsQ0FBQztJQUFDO0VBQ25DO0VBQ0E7QUFDSjtBQUNBO0FBQ0E7RUFDVWtELFFBQVFBLENBQUEsRUFBRztJQUFBLElBQUFDLE1BQUE7SUFBQSxPQUFBTixnS0FBQTtNQUNiLElBQUlNLE1BQUksQ0FBQ3hELGtCQUFrQixFQUFFO1FBQ3pCd0QsTUFBSSxDQUFDeEQsa0JBQWtCLENBQUN5RCxLQUFLLENBQUMsQ0FBQztNQUNuQztJQUFDO0VBQ0w7RUFDQUMsaUJBQWlCQSxDQUFBLEVBQUc7SUFDaEIsSUFBSWpGLEVBQUU7SUFDTixJQUFJLENBQUN2QyxTQUFTLEdBQUcsQ0FBQ3VDLEVBQUUsR0FBRyxJQUFJLENBQUNWLEVBQUUsQ0FBQ3lELFlBQVksQ0FBQyxZQUFZLENBQUMsTUFBTSxJQUFJLElBQUkvQyxFQUFFLEtBQUssS0FBSyxDQUFDLEdBQUdBLEVBQUUsR0FBRyxnQkFBZ0I7RUFDaEg7RUFDQSxJQUFJRixVQUFVQSxDQUFBLEVBQUc7SUFDYixNQUFNO01BQUU4QjtJQUFNLENBQUMsR0FBRyxJQUFJO0lBQ3RCLE1BQU1zRCxPQUFPLEdBQUdDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQzlGLEVBQUUsQ0FBQytGLGdCQUFnQixDQUFDLDBCQUEwQixDQUFDLENBQUM7SUFDaEYsT0FBT0gsT0FBTyxDQUFDaEUsSUFBSSxDQUFFb0UsTUFBTSxJQUFLO01BQzVCO0FBQ1o7QUFDQTtBQUNBO01BQ1ksSUFBSSxDQUFDLElBQUksQ0FBQzNILFFBQVEsSUFBSTJILE1BQU0sQ0FBQzNILFFBQVEsRUFBRTtRQUNuQyxPQUFPLEtBQUs7TUFDaEI7TUFDQSxPQUFPMkgsTUFBTSxDQUFDMUQsS0FBSyxLQUFLQSxLQUFLO0lBQ2pDLENBQUMsQ0FBQztFQUNOO0VBQ0EyRCxNQUFNQSxDQUFBLEVBQUc7SUFDTCxNQUFNO01BQUUzSCxLQUFLO01BQUVELFFBQVE7TUFBRUQsUUFBUTtNQUFFRztJQUFhLENBQUMsR0FBRyxJQUFJO0lBQ3hELE1BQU0ySCxJQUFJLEdBQUd2SixxREFBVSxDQUFDLElBQUksQ0FBQztJQUM3QixPQUFRRixxREFBQyxDQUFDSSxpREFBSSxFQUFFO01BQUV5RyxHQUFHLEVBQUUsMENBQTBDO01BQUVRLEtBQUssRUFBRXJHLHFEQUFrQixDQUFDYSxLQUFLLEVBQUU7UUFDNUYsQ0FBQzRILElBQUksR0FBRyxJQUFJO1FBQ1osQ0FBQyxzQkFBc0IsR0FBRzlILFFBQVE7UUFDbEMsQ0FBQyw2QkFBNkIsR0FBR0csWUFBWTtRQUM3QyxDQUFDLHdCQUF3QixHQUFHRjtNQUNoQyxDQUFDO0lBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQ3NGLHdCQUF3QixDQUFDLENBQUMsRUFBRWxILHFEQUFDLENBQUMsTUFBTSxFQUFFO01BQUU2RyxHQUFHLEVBQUUsMENBQTBDO01BQUU2QyxJQUFJLEVBQUU7SUFBUyxDQUFDLENBQUMsRUFBRTFKLHFEQUFDLENBQUMsS0FBSyxFQUFFO01BQUU2RyxHQUFHLEVBQUUsMENBQTBDO01BQUUsYUFBYSxFQUFFLE1BQU07TUFBRVEsS0FBSyxFQUFFLGFBQWE7TUFBRUQsR0FBRyxFQUFHN0QsRUFBRSxJQUFLO1FBQ3pPLElBQUksQ0FBQ3JCLFFBQVEsR0FBR3FCLEVBQUU7TUFDdEIsQ0FBQztNQUNEO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUNZb0csUUFBUSxFQUFFLENBQUM7SUFBRSxDQUFDLEVBQUUzSixxREFBQyxDQUFDLEtBQUssRUFBRTtNQUFFNkcsR0FBRyxFQUFFLDBDQUEwQztNQUFFUSxLQUFLLEVBQUUsbUJBQW1CO01BQUUsYUFBYSxFQUFFO0lBQU8sQ0FBQyxFQUFFLFFBQVEsQ0FBQyxFQUFFckgscURBQUMsQ0FBQyxLQUFLLEVBQUU7TUFBRTZHLEdBQUcsRUFBRSwwQ0FBMEM7TUFBRVEsS0FBSyxFQUFFLG1CQUFtQjtNQUFFLGFBQWEsRUFBRTtJQUFPLENBQUMsRUFBRSxRQUFRLENBQUMsRUFBRXJILHFEQUFDLENBQUMsS0FBSyxFQUFFO01BQUU2RyxHQUFHLEVBQUUsMENBQTBDO01BQUVRLEtBQUssRUFBRSxtQkFBbUI7TUFBRSxhQUFhLEVBQUU7SUFBTyxDQUFDLEVBQUUsUUFBUSxDQUFDLEVBQUVySCxxREFBQyxDQUFDLE1BQU0sRUFBRTtNQUFFNkcsR0FBRyxFQUFFO0lBQTJDLENBQUMsQ0FBQyxFQUFFN0cscURBQUMsQ0FBQyxLQUFLLEVBQUU7TUFBRTZHLEdBQUcsRUFBRSwwQ0FBMEM7TUFBRVEsS0FBSyxFQUFFLG1CQUFtQjtNQUFFLGFBQWEsRUFBRTtJQUFPLENBQUMsRUFBRSxRQUFRLENBQUMsRUFBRXJILHFEQUFDLENBQUMsS0FBSyxFQUFFO01BQUU2RyxHQUFHLEVBQUUsMENBQTBDO01BQUVRLEtBQUssRUFBRSxtQkFBbUI7TUFBRSxhQUFhLEVBQUU7SUFBTyxDQUFDLEVBQUUsUUFBUSxDQUFDLEVBQUVySCxxREFBQyxDQUFDLEtBQUssRUFBRTtNQUFFNkcsR0FBRyxFQUFFLDBDQUEwQztNQUFFUSxLQUFLLEVBQUUsbUJBQW1CO01BQUUsYUFBYSxFQUFFO0lBQU8sQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEVBQUVySCxxREFBQyxDQUFDLE1BQU0sRUFBRTtNQUFFNkcsR0FBRyxFQUFFLDBDQUEwQztNQUFFNkMsSUFBSSxFQUFFO0lBQVMsQ0FBQyxDQUFDLENBQUM7RUFDaDVCO0VBQ0EsSUFBSW5HLEVBQUVBLENBQUEsRUFBRztJQUFFLE9BQU9qRCxxREFBVSxDQUFDLElBQUksQ0FBQztFQUFFO0VBQ3BDLFdBQVdzSixRQUFRQSxDQUFBLEVBQUc7SUFBRSxPQUFPO01BQzNCLFlBQVksRUFBRSxDQUFDLGtCQUFrQixDQUFDO01BQ2xDLE9BQU8sRUFBRSxDQUFDLGFBQWE7SUFDM0IsQ0FBQztFQUFFO0FBQ1AsQ0FBQztBQUNELE1BQU03Ryx3QkFBd0IsR0FBRyxlQUFlO0FBQ2hEN0IsWUFBWSxDQUFDMkksS0FBSyxHQUFHNUksZUFBZSIsInNvdXJjZXMiOlsiLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vaW9uLXBpY2tlci1jb2x1bW4uZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgZCBhcyBjcmVhdGVFdmVudCwgYSBhcyBpc1BsYXRmb3JtLCBoLCBlIGFzIGdldElvbk1vZGUsIGogYXMgSG9zdCwgayBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC1CX1U5Q3RhWS5qcyc7XG5pbXBvcnQgeyBkIGFzIGRvYyB9IGZyb20gJy4vaW5kZXgtWmpQNENqZVouanMnO1xuaW1wb3J0IHsgciBhcyByYWYsIGcgYXMgZ2V0RWxlbWVudFJvb3QgfSBmcm9tICcuL2hlbHBlcnMtMU80RDJiN3kuanMnO1xuaW1wb3J0IHsgYiBhcyBoYXB0aWNTZWxlY3Rpb25TdGFydCwgYSBhcyBoYXB0aWNTZWxlY3Rpb25DaGFuZ2VkLCBoIGFzIGhhcHRpY1NlbGVjdGlvbkVuZCB9IGZyb20gJy4vaGFwdGljLUR6QU1XSnVrLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzIH0gZnJvbSAnLi90aGVtZS1EaVZKeXFsWC5qcyc7XG5pbXBvcnQgJy4vY2FwYWNpdG9yLUNGRVJJZWFVLmpzJztcblxuY29uc3QgcGlja2VyQ29sdW1uQ3NzID0gXCI6aG9zdHtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWF4LXdpZHRoOjEwMCU7aGVpZ2h0OjIwMHB4O2ZvbnQtc2l6ZToyMnB4O3RleHQtYWxpZ246Y2VudGVyfS5hc3Npc3RpdmUtZm9jdXNhYmxle2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTtwb2ludGVyLWV2ZW50czpub25lfS5hc3Npc3RpdmUtZm9jdXNhYmxlOmZvY3Vze291dGxpbmU6bm9uZX0ucGlja2VyLW9wdHN7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE2cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTZweDstd2Via2l0LXBhZGRpbmctZW5kOjE2cHg7cGFkZGluZy1pbmxpbmUtZW5kOjE2cHg7cGFkZGluZy10b3A6MHB4O3BhZGRpbmctYm90dG9tOjBweDttaW4td2lkdGg6MjZweDttYXgtaGVpZ2h0OjIwMHB4O291dGxpbmU6bm9uZTt0ZXh0LWFsaWduOmluaGVyaXQ7LXdlYmtpdC1zY3JvbGwtc25hcC10eXBlOnkgbWFuZGF0b3J5Oy1tcy1zY3JvbGwtc25hcC10eXBlOnkgbWFuZGF0b3J5O3Njcm9sbC1zbmFwLXR5cGU6eSBtYW5kYXRvcnk7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTpzY3JvbGw7c2Nyb2xsYmFyLXdpZHRoOm5vbmV9LnBpY2tlci1pdGVtLWVtcHR5e3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtoZWlnaHQ6MzRweDtib3JkZXI6MHB4O291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2NvbG9yOmluaGVyaXQ7Zm9udC1mYW1pbHk6dmFyKC0taW9uLWZvbnQtZmFtaWx5LCBpbmhlcml0KTtmb250LXNpemU6aW5oZXJpdDtsaW5lLWhlaWdodDozNHB4O3RleHQtYWxpZ246aW5oZXJpdDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW59LnBpY2tlci1vcHRzOjotd2Via2l0LXNjcm9sbGJhcntkaXNwbGF5Om5vbmV9OjpzbG90dGVkKGlvbi1waWNrZXItY29sdW1uLW9wdGlvbil7ZGlzcGxheTpibG9jaztzY3JvbGwtc25hcC1hbGlnbjpjZW50ZXJ9LnBpY2tlci1pdGVtLWVtcHR5LDpob3N0KDpub3QoW2Rpc2FibGVkXSkpIDo6c2xvdHRlZChpb24tcGlja2VyLWNvbHVtbi1vcHRpb24ub3B0aW9uLWRpc2FibGVkKXtzY3JvbGwtc25hcC1hbGlnbjpub25lfTo6c2xvdHRlZChbc2xvdD1wcmVmaXhdKSw6OnNsb3R0ZWQoW3Nsb3Q9c3VmZml4XSl7bWF4LXdpZHRoOjIwMHB4O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbn06OnNsb3R0ZWQoW3Nsb3Q9cHJlZml4XSl7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE2cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTZweDstd2Via2l0LXBhZGRpbmctZW5kOjE2cHg7cGFkZGluZy1pbmxpbmUtZW5kOjE2cHg7cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowOy1tcy1mbGV4LXBhY2s6ZW5kO2p1c3RpZnktY29udGVudDplbmR9OjpzbG90dGVkKFtzbG90PXN1ZmZpeF0pey13ZWJraXQtcGFkZGluZy1zdGFydDoxNnB4O3BhZGRpbmctaW5saW5lLXN0YXJ0OjE2cHg7LXdlYmtpdC1wYWRkaW5nLWVuZDoxNnB4O3BhZGRpbmctaW5saW5lLWVuZDoxNnB4O3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDstbXMtZmxleC1wYWNrOnN0YXJ0O2p1c3RpZnktY29udGVudDpzdGFydH06aG9zdCgucGlja2VyLWNvbHVtbi1kaXNhYmxlZCkgLnBpY2tlci1vcHRze292ZXJmbG93LXk6aGlkZGVufTpob3N0KC5waWNrZXItY29sdW1uLWRpc2FibGVkKSA6OnNsb3R0ZWQoaW9uLXBpY2tlci1jb2x1bW4tb3B0aW9uKXtjdXJzb3I6ZGVmYXVsdDtvcGFjaXR5OjAuNDtwb2ludGVyLWV2ZW50czpub25lfUBtZWRpYSAoYW55LWhvdmVyOiBob3Zlcil7Omhvc3QoOmZvY3VzKSAucGlja2VyLW9wdHN7b3V0bGluZTpub25lO2JhY2tncm91bmQ6cmdiYSh2YXIoLS1pb24tY29sb3ItYmFzZS1yZ2IpLCAwLjIpfX1cIjtcblxuY29uc3QgUGlja2VyQ29sdW1uID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5pb25DaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvbkNoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ29sdW1uVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbkV4aXRJbnB1dE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlVGV4dE9uU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXJpYUxhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYHRydWVgLCB0aGUgdXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCB0aGUgcGlja2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIHRvIHVzZSBmcm9tIHlvdXIgYXBwbGljYXRpb24ncyBjb2xvciBwYWxldHRlLlxuICAgICAgICAgKiBEZWZhdWx0IG9wdGlvbnMgYXJlOiBgXCJwcmltYXJ5XCJgLCBgXCJzZWNvbmRhcnlcImAsIGBcInRlcnRpYXJ5XCJgLCBgXCJzdWNjZXNzXCJgLCBgXCJ3YXJuaW5nXCJgLCBgXCJkYW5nZXJcImAsIGBcImxpZ2h0XCJgLCBgXCJtZWRpdW1cImAsIGFuZCBgXCJkYXJrXCJgLlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBjb2xvcnMsIHNlZSBbdGhlbWluZ10oL2RvY3MvdGhlbWluZy9iYXNpY3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xvciA9ICdwcmltYXJ5JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGFwcGluZyB0aGUgcGlja2VyIHdpbGxcbiAgICAgICAgICogcmV2ZWFsIGEgbnVtYmVyIGlucHV0IGtleWJvYXJkIHRoYXQgbGV0c1xuICAgICAgICAgKiB0aGUgdXNlciB0eXBlIGluIHZhbHVlcyBmb3IgZWFjaCBwaWNrZXJcbiAgICAgICAgICogY29sdW1uLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHdvcmtpbmdcbiAgICAgICAgICogd2l0aCB0aW1lIHBpY2tlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5udW1lcmljSW5wdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZW50ZXJQaWNrZXJJdGVtSW5WaWV3ID0gKHRhcmdldCwgc21vb3RoID0gdHJ1ZSwgY2FuRXhpdElucHV0TW9kZSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNDb2x1bW5WaXNpYmxlLCBzY3JvbGxFbCB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmIChpc0NvbHVtblZpc2libGUgJiYgc2Nyb2xsRWwpIHtcbiAgICAgICAgICAgICAgICAvLyAoVmVydGljYWwgb2Zmc2V0IGZyb20gcGFyZW50KSAtICh0aHJlZSBlbXB0eSBwaWNrZXIgcm93cykgKyAoaGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgdG8gZW5zdXJlIHRoZSBzY3JvbGwgdHJpZ2dlcnMpXG4gICAgICAgICAgICAgICAgY29uc3QgdG9wID0gdGFyZ2V0Lm9mZnNldFRvcCAtIDMgKiB0YXJnZXQuY2xpZW50SGVpZ2h0ICsgdGFyZ2V0LmNsaWVudEhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEVsLnNjcm9sbFRvcCAhPT0gdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTZXR0aW5nIHRoaXMgZmxhZyBwcmV2ZW50cyBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgKiBtb2RlIGZyb20gZXhpdGluZyBpbiB0aGUgcGlja2VyIGNvbHVtbidzXG4gICAgICAgICAgICAgICAgICAgICAqIHNjcm9sbCBjYWxsYmFjay4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGUgdXNlciBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICAgKiB0YXBzIGFuIGl0ZW0gb3IgdHlwZXMgb24gdGhlIGtleWJvYXJkIGFzIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgICogb2YgdGhlc2UgY2FuIGNhdXNlIGEgc2Nyb2xsIHRvIG9jY3VyLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5FeGl0SW5wdXRNb2RlID0gY2FuRXhpdElucHV0TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZVRleHRPblNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBzbW9vdGggPyAnc21vb3RoJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFBpY2tlckl0ZW1BY3RpdmVTdGF0ZSA9IChpdGVtLCBpc0FjdGl2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKFBJQ0tFUl9JVEVNX0FDVElWRV9DTEFTUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoUElDS0VSX0lURU1fQUNUSVZFX0NMQVNTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gaW9uSW5wdXRNb2RlQ2hhbmdlIGlzIGVtaXR0ZWQsIGVhY2ggY29sdW1uXG4gICAgICAgICAqIG5lZWRzIHRvIGNoZWNrIGlmIGl0IGlzIHRoZSBvbmUgYmVpbmcgbWFkZSBhdmFpbGFibGVcbiAgICAgICAgICogZm9yIHRleHQgZW50cnkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlucHV0TW9kZUNoYW5nZSA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm51bWVyaWNJbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdXNlSW5wdXRNb2RlLCBpbnB1dE1vZGVDb2x1bW4gfSA9IGV2LmRldGFpbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgaW5wdXRNb2RlQ29sdW1uIGlzIHVuZGVmaW5lZCB0aGVuIHRoaXMgbWVhbnNcbiAgICAgICAgICAgICAqIGFsbCBudW1lcmljSW5wdXQgY29sdW1ucyBhcmUgYmVpbmcgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGlzQ29sdW1uQWN0aXZlID0gaW5wdXRNb2RlQ29sdW1uID09PSB1bmRlZmluZWQgfHwgaW5wdXRNb2RlQ29sdW1uID09PSB0aGlzLmVsO1xuICAgICAgICAgICAgaWYgKCF1c2VJbnB1dE1vZGUgfHwgIWlzQ29sdW1uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnB1dE1vZGVBY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0SW5wdXRNb2RlQWN0aXZlKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dGluZyBpc0FjdGl2ZSB3aWxsIGNhdXNlIGEgcmUtcmVuZGVyLlxuICAgICAgICAgKiBBcyBhIHJlc3VsdCwgd2UgZG8gbm90IHdhbnQgdG8gY2F1c2UgdGhlXG4gICAgICAgICAqIHJlLXJlbmRlciBtaWQgc2Nyb2xsIGFzIHRoaXMgd2lsbCBjYXVzZVxuICAgICAgICAgKiB0aGUgcGlja2VyIGNvbHVtbiB0byBqdW1wIGJhY2sgdG9cbiAgICAgICAgICogd2hhdGV2ZXIgdmFsdWUgd2FzIHNlbGVjdGVkIGF0IHRoZVxuICAgICAgICAgKiBzdGFydCBvZiB0aGUgc2Nyb2xsIGludGVyYWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRJbnB1dE1vZGVBY3RpdmUgPSAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbmRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHN0YXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgY29sdW1uIHNjcm9sbHMsIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogbmVlZHMgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gaXMgY2VudGVyZWRcbiAgICAgICAgICogaW4gdGhlIHZpZXcgYW5kIHdpbGwgZW1pdCBhbiBpb25DaGFuZ2Ugd2l0aFxuICAgICAgICAgKiB0aGUgaXRlbSBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxpemVTY3JvbGxMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGhhcHRpY3MgZm9yIHRoZSB3aGVlbCBwaWNrZXIgYXJlXG4gICAgICAgICAgICAgKiBhbiBpT1Mtb25seSBmZWF0dXJlLiBBcyBhIHJlc3VsdCwgdGhleSBzaG91bGRcbiAgICAgICAgICAgICAqIGJlIGRpc2FibGVkIG9uIEFuZHJvaWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGVuYWJsZUhhcHRpY3MgPSBpc1BsYXRmb3JtKCdpb3MnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZWwsIHNjcm9sbEVsIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgICAgICBsZXQgYWN0aXZlRWwgPSB0aGlzLmFjdGl2ZUl0ZW07XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByYWYoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2Nyb2xsRWwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Njcm9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlSGFwdGljcyAmJiBoYXB0aWNTZWxlY3Rpb25TdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFNlbGVjdCBpdGVtIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgKiB3aGljaCBpcyB0aGUgbW9udGgveWVhciB0aGF0IHdlIHdhbnQgdG8gc2VsZWN0XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYm94ID0gc2Nyb2xsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSBiYm94LnggKyBiYm94LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IGJib3gueSArIGJib3guaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIGVsZW1lbnRGcm9tUG9pbnQgcmV0dXJucyB0aGUgdG9wLW1vc3QgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICogVGhpcyBtZWFucyB0aGF0IGlmIGFuIGlvbi1iYWNrZHJvcCBpcyBvdmVybGF5aW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBwaWNrZXIgdGhlbiB0aGUgYXBwcm9wcmlhdGUgcGlja2VyIGNvbHVtbiBvcHRpb24gd2lsbFxuICAgICAgICAgICAgICAgICAgICAgKiBub3QgYmUgc2VsZWN0ZWQuIFRvIGFjY291bnQgZm9yIHRoaXMsIHdlIHVzZSBlbGVtZW50c0Zyb21Qb2ludFxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgdXNlIGFuIEFycmF5LmZpbmQgdG8gZmluZCB0aGUgYXBwcm9wcmlhdGUgY29sdW1uIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiBhdCB0aGF0IHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBBZGRpdGlvbmFsbHksIHRoZSBwaWNrZXIgY29sdW1uIGNvdWxkIGJlIHVzZWQgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIFNoYWRvdyBET00gKGkuZS4gaW4gaW9uLWRhdGV0aW1lKSBzbyB3ZSBuZWVkIHRvIG1ha2VcbiAgICAgICAgICAgICAgICAgICAgICogc3VyZSB3ZSBhcmUgY2hvb3NpbmcgdGhlIGNvcnJlY3QgaG9zdCBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGVsZW1lbnRzIHJldHVybnMgYnkgZWxlbWVudHNGcm9tUG9pbnQgd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICAgKiByZXRhcmdldGVkLiBUbyBhY2NvdW50IGZvciB0aGlzLCB3ZSBjaGVjayB0byBzZWVcbiAgICAgICAgICAgICAgICAgICAgICogaWYgdGhlIHBpY2tlciBjb2x1bW4gaGFzIGEgcGFyZW50IHNoYWRvdyByb290LiBJZlxuICAgICAgICAgICAgICAgICAgICAgKiBzbywgd2UgdXNlIHRoYXQgc2hhZG93IHJvb3Qgd2hlbiBkb2luZyBlbGVtZW50c0Zyb21Qb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICogT3RoZXJ3aXNlLCB3ZSBqdXN0IHVzZSB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1BhcmVudFNoYWRvdyA9IHJvb3ROb2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IGhhc1BhcmVudFNoYWRvdyA/IHJvb3ROb2RlIDogZG9jO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIHJlZmVyZW5jZSBub2RlIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgKiB0aGVuIGl0J3MgbGlrZWx5IHRoYXQgZG9jIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgKiBkdWUgdG8gYmVpbmcgaW4gYW4gU1NSIGVudmlyb25tZW50LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQXRQb2ludCA9IHJlZmVyZW5jZU5vZGUuZWxlbWVudHNGcm9tUG9pbnQoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50c0Zyb21Qb2ludCBjYW4gcmV0dXJucyBtdWx0aXBsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgKiBzbyBmaW5kIHRoZSByZWxldmFudCBwaWNrZXIgY29sdW1uIG9wdGlvbiBpZiBvbmUgZXhpc3RzLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0FjdGl2ZUVsZW1lbnQgPSBlbGVtZW50c0F0UG9pbnQuZmluZCgoZWwpID0+IGVsLnRhZ05hbWUgPT09ICdJT04tUElDS0VSLUNPTFVNTi1PUFRJT04nKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRPRE8oRlctNjU5NCk6IFJlbW92ZSB0aGlzIHdvcmthcm91bmQgd2hlbiBpT1MgMTYgaXMgbm8gbG9uZ2VyXG4gICAgICAgICAgICAgICAgICAgICAqIHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogSWYgYGVsZW1lbnRzRnJvbVBvaW50YCBmYWlsZWQgdG8gZmluZCB0aGUgYWN0aXZlIGVsZW1lbnQgKGEga25vd25cbiAgICAgICAgICAgICAgICAgICAgICogaXNzdWUgb24gaU9TIDE2IHdoZW4gZWxlbWVudHMgYXJlIGluIGEgU2hhZG93IERPTSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHJlZmVyZW5jZU5vZGUgaXMgdGhlIGRvY3VtZW50KSwgYSBmYWxsYmFjayB0byBgZWxlbWVudEZyb21Qb2ludGBcbiAgICAgICAgICAgICAgICAgICAgICogaXMgdXNlZC4gV2hpbGUgYGVsZW1lbnRzRnJvbVBvaW50YCByZXR1cm5zIGFsbCBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICogYGVsZW1lbnRGcm9tUG9pbnRgIHJldHVybnMgb25seSB0aGUgdG9wLW1vc3QsIHdoaWNoIGlzIHN1ZmZpY2llbnRcbiAgICAgICAgICAgICAgICAgICAgICogZm9yIHRoaXMgdXNlIGNhc2UgYW5kIGFwcGVhcnMgdG8gaGFuZGxlIFNoYWRvdyBET00gcmV0YXJnZXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICogbW9yZSByZWxpYWJseSBpbiB0aGlzIHNwZWNpZmljIGlPUyBidWcuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3QWN0aXZlRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja0FjdGl2ZUVsZW1lbnQgPSByZWZlcmVuY2VOb2RlLmVsZW1lbnRGcm9tUG9pbnQoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZhbGxiYWNrQWN0aXZlRWxlbWVudCA9PT0gbnVsbCB8fCBmYWxsYmFja0FjdGl2ZUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrQWN0aXZlRWxlbWVudC50YWdOYW1lKSA9PT0gJ0lPTi1QSUNLRVItQ09MVU1OLU9QVElPTicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBY3RpdmVFbGVtZW50ID0gZmFsbGJhY2tBY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBpY2tlckl0ZW1BY3RpdmVTdGF0ZShhY3RpdmVFbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdBY3RpdmVFbGVtZW50ID09PSB1bmRlZmluZWQgfHwgbmV3QWN0aXZlRWxlbWVudC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB3ZSBhcmUgc2VsZWN0aW5nIGEgbmV3IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIHJ1biBoYXB0aWNzIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0FjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVIYXB0aWNzICYmIGhhcHRpY1NlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbkV4aXRJbnB1dE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgbmF0aXZlIGlPUyB3aGVlbCBwaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvbmx5IGRpc21pc3NlcyB0aGUga2V5Ym9hcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvbmNlIHRoZSBzZWxlY3RlZCBpdGVtIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYXMgYSByZXN1bHQgb2YgYSBzd2lwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGZyb20gdGhlIHVzZXIuIElmIGBjYW5FeGl0SW5wdXRNb2RlYCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGBmYWxzZWAgdGhlbiB0aGlzIG1lYW5zIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc2Nyb2xsIGlzIGhhcHBlbmluZyBhcyBhIHJlc3VsdCBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBgdmFsdWVgIHByb3BlcnR5IHByb2dyYW1tYXRpY2FsbHkgY2hhbmdpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBlaXRoZXIgYnkgYW4gYXBwbGljYXRpb24gb3IgYnkgdGhlIHVzZXIgdmlhIHRoZSBrZXlib2FyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4aXRJbnB1dE1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbCA9IG5ld0FjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGlja2VySXRlbUFjdGl2ZVN0YXRlKG5ld0FjdGl2ZUVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogU2V0IHRoZSBhcmlhLXZhbHVldGV4dCBldmVuIHRob3VnaCB0aGUgdmFsdWUgcHJvcCBoYXMgbm90IGJlZW4gdXBkYXRlZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAqIFRoaXMgZW5hYmxlcyBzb21lIHNjcmVlbiByZWFkZXJzIHRvIGFubm91bmNlIHRoZSB2YWx1ZSBhcyB0aGUgdXNlcnMgZHJhZ1xuICAgICAgICAgICAgICAgICAgICAgKiBhcyBvcHBvc2VkIHRvIHdoZW4gdGhlaXIgcmVsZWFzZSB0aGVpciBwb2ludGVyIGZyb20gdGhlIHNjcmVlbi5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogV2hlbiB0aGUgdmFsdWUgaXMgcHJvZ3JhbW1hdGljYWxseSB1cGRhdGVkLCB3ZSB3aWxsIHNtb290aGx5IHNjcm9sbFxuICAgICAgICAgICAgICAgICAgICAgKiB0byB0aGUgbmV3IG9wdGlvbi4gSG93ZXZlciwgd2UgZG8gbm90IHdhbnQgdG8gdXBkYXRlIGFyaWEtdmFsdWV0ZXh0IG1pZC1zY3JvbGxcbiAgICAgICAgICAgICAgICAgICAgICogYXMgdGhhdCBjYW4gY2F1c2UgdGhlIG9sZCB2YWx1ZSB0byBiZSBicmllZmx5IHNldCBiZWZvcmUgYmVpbmcgc2V0IHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBjb3JyZWN0IG9wdGlvbi4gVGhpcyB3aWxsIGNhdXNlIHNvbWUgc2NyZWVuIHJlYWRlcnMgdG8gYW5ub3VuY2UgdGhlIG9sZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgKiBhZ2FpbiBiZWZvcmUgYW5ub3VuY2luZyB0aGUgbmV3IHZhbHVlLiBUaGUgY29ycmVjdCB2YWx1ZXRleHQgd2lsbCBiZSBzZXQgb24gcmVuZGVyLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlVmFsdWVUZXh0T25TY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuYXNzaXN0aXZlRm9jdXNhYmxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIHRoaXMuZ2V0T3B0aW9uVmFsdWVUZXh0KG5ld0FjdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlVGV4dE9uU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZUhhcHRpY3MgJiYgaGFwdGljU2VsZWN0aW9uRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIENlcnRhaW4gdGFza3MgKHN1Y2ggYXMgdGhvc2UgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogY2F1c2UgcmUtcmVuZGVycykgc2hvdWxkIG9ubHkgYmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogb25jZSBzY3JvbGxpbmcgaGFzIGZpbmlzaGVkLCBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGZsaWNrZXJpbmcgbWF5IG9jY3VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjcm9sbEVuZENhbGxiYWNrIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbEVuZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRW5kQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVuZENhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBSZXNldCB0aGlzIGZsYWcgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXh0IHNjcm9sbCBpbnRlcmFjdGlvbiBjb3VsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogYmUgYSBzY3JvbGwgZnJvbSB0aGUgdXNlci4gSW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogY2FzZSwgd2Ugc2hvdWxkIGV4aXQgaW5wdXQgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5FeGl0SW5wdXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUobmV3QWN0aXZlRWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcmFwIHRoaXMgaW4gYW4gcmFmIHNvIHRoYXQgdGhlIHNjcm9sbCBjYWxsYmFja1xuICAgICAgICAgICAgICogZG9lcyBub3QgZmlyZSB3aGVuIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgc2hvd24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJhZigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxFbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNjcm9sbEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lTY3JvbGxMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbGxzIHRoZSBwYXJlbnQgcGlja2VyIHRvXG4gICAgICAgICAqIGV4aXQgdGV4dCBlbnRyeSBtb2RlLiBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAqIHdoZW4gdGhlIHNlbGVjdGVkIGl0ZW0gY2hhbmdlcyBkdXJpbmcgc2Nyb2xsLCBzb1xuICAgICAgICAgKiB3ZSBrbm93IHRoYXQgdGhlIHVzZXIgbGlrZWx5IHdhbnRzIHRvIHNjcm9sbFxuICAgICAgICAgKiBpbnN0ZWFkIG9mIHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4aXRJbnB1dE1vZGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBhcmVudEVsIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHBhcmVudEVsID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGFyZW50RWwuZXhpdElucHV0TW9kZSgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzZXRJbnB1dE1vZGVBY3RpdmUgb25seSB0YWtlc1xuICAgICAgICAgICAgICogZWZmZWN0IG9uY2Ugc2Nyb2xsaW5nIHN0b3BzIHRvIGF2b2lkXG4gICAgICAgICAgICAgKiBhIGNvbXBvbmVudCByZS1yZW5kZXIgd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAgICAgICAgICogSG93ZXZlciwgd2Ugd2FudCB0aGUgdmlzdWFsIGFjdGl2ZVxuICAgICAgICAgICAgICogaW5kaWNhdG9yIHRvIGdvIGF3YXkgaW1tZWRpYXRlbHksIHNvXG4gICAgICAgICAgICAgKiB3ZSBjYWxsIGNsYXNzTGlzdC5yZW1vdmUgaGVyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdwaWNrZXItY29sdW1uLWFjdGl2ZScpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgbmV4dCBlbmFibGVkIG9wdGlvbiBhZnRlciB0aGUgYWN0aXZlIG9wdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHN0cmlkZSAtIEhvdyBtYW55IG9wdGlvbnMgdG8gXCJqdW1wXCIgb3ZlciBpbiBvcmRlciB0byBzZWxlY3QgdGhlIG5leHQgb3B0aW9uLlxuICAgICAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBQYWdlVXAvUGFnZURvd24gYmVoYXZpb3JzIHdoZXJlIHByZXNzaW5nIHRoZXNlIGtleXNcbiAgICAgICAgICogc2Nyb2xscyB0aGUgcGlja2VyIGJ5IG1vcmUgdGhhbiAxIG9wdGlvbi4gRm9yIGV4YW1wbGUsIGEgc3RyaWRlIG9mIDUgbWVhbnMgc2VsZWN0XG4gICAgICAgICAqIHRoZSBlbmFibGVkIG9wdGlvbiA1IG9wdGlvbnMgYWZ0ZXIgdGhlIGFjdGl2ZSBvbmUuIE5vdGUgdGhhdCB0aGUgYWN0dWFsIG9wdGlvbiBzZWxlY3RlZFxuICAgICAgICAgKiBtYXkgYmUgcGFzdCB0aGUgc3RyaWRlIGlmIHRoZSBvcHRpb24gYXQgdGhlIHN0cmlkZSBpcyBkaXNhYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluZE5leHRPcHRpb24gPSAoc3RyaWRlID0gMSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhY3RpdmVJdGVtIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVJdGVtKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHByZXZOb2RlID0gYWN0aXZlSXRlbTtcbiAgICAgICAgICAgIGxldCBub2RlID0gYWN0aXZlSXRlbS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmlkZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWRlLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdJT04tUElDS0VSLUNPTFVNTi1PUFRJT04nICYmICFub2RlLmRpc2FibGVkICYmIHN0cmlkZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldk5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBuZXh0RWxlbWVudFNpYmxpbmcgaW5zdGVhZCBvZiBuZXh0U2libGluZyB0byBhdm9pZCB0ZXh0L2NvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldk5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBuZXh0IGVuYWJsZWQgb3B0aW9uIGFmdGVyIHRoZSBhY3RpdmUgb3B0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gc3RyaWRlIC0gSG93IG1hbnkgb3B0aW9ucyB0byBcImp1bXBcIiBvdmVyIGluIG9yZGVyIHRvIHNlbGVjdCB0aGUgbmV4dCBvcHRpb24uXG4gICAgICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IFBhZ2VVcC9QYWdlRG93biBiZWhhdmlvcnMgd2hlcmUgcHJlc3NpbmcgdGhlc2Uga2V5c1xuICAgICAgICAgKiBzY3JvbGxzIHRoZSBwaWNrZXIgYnkgbW9yZSB0aGFuIDEgb3B0aW9uLiBGb3IgZXhhbXBsZSwgYSBzdHJpZGUgb2YgNSBtZWFucyBzZWxlY3RcbiAgICAgICAgICogdGhlIGVuYWJsZWQgb3B0aW9uIDUgb3B0aW9ucyBiZWZvcmUgdGhlIGFjdGl2ZSBvbmUuIE5vdGUgdGhhdCB0aGUgYWN0dWFsIG9wdGlvbiBzZWxlY3RlZFxuICAgICAgICAgKiAgbWF5IGJlIHBhc3QgdGhlIHN0cmlkZSBpZiB0aGUgb3B0aW9uIGF0IHRoZSBzdHJpZGUgaXMgZGlzYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbmRQcmV2aW91c09wdGlvbiA9IChzdHJpZGUgPSAxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFjdGl2ZUl0ZW0gfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZUl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dE5vZGUgPSBhY3RpdmVJdGVtO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBhY3RpdmVJdGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmlkZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWRlLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdJT04tUElDS0VSLUNPTFVNTi1PUFRJT04nICYmICFub2RlLmRpc2FibGVkICYmIHN0cmlkZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c0VsZW1lbnRTaWJsaW5nIGluc3RlYWQgb2YgcHJldmlvdXNTaWJsaW5nIHRvIGF2b2lkIHRleHQvY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25LZXlEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBiZWxvdyBvcGVyYXRpb25zIHNob3VsZCBiZSBpbnZlcnRlZCB3aGVuIHJ1bm5pbmcgb24gYSBtb2JpbGUgZGV2aWNlLlxuICAgICAgICAgICAgICogRm9yIGV4YW1wbGUsIHN3aXBpbmcgdXAgd2lsbCBkaXNwYXRjaCBhbiBcIkFycm93VXBcIiBldmVudC4gT24gZGVza3RvcCxcbiAgICAgICAgICAgICAqIHRoaXMgc2hvdWxkIGNhdXNlIHRoZSBwcmV2aW91cyBvcHRpb24gdG8gYmUgc2VsZWN0ZWQuIE9uIG1vYmlsZSwgc3dpcGluZ1xuICAgICAgICAgICAgICogdXAgY2F1c2VzIGEgdmlldyB0byBzY3JvbGwgZG93bi4gQXMgYSByZXN1bHQsIHN3aXBpbmcgdXAgb24gbW9iaWxlIHNob3VsZFxuICAgICAgICAgICAgICogY2F1c2UgdGhlIG5leHQgb3B0aW9uIHRvIGJlIHNlbGVjdGVkLiBUaGUgSG9tZS9FbmQgb3BlcmF0aW9ucyByZW1haW5cbiAgICAgICAgICAgICAqIHVuY2hhbmdlZCBiZWNhdXNlIHRob3NlIGFsd2F5cyByZXByZXNlbnQgdGhlIGZpcnN0L2xhc3Qgb3B0aW9ucywgcmVzcGVjdGl2ZWx5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBtb2JpbGUgPSBpc1BsYXRmb3JtKCdtb2JpbGUnKTtcbiAgICAgICAgICAgIGxldCBuZXdPcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb24gPSBtb2JpbGUgPyB0aGlzLmZpbmRQcmV2aW91c09wdGlvbigpIDogdGhpcy5maW5kTmV4dE9wdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gbW9iaWxlID8gdGhpcy5maW5kTmV4dE9wdGlvbigpIDogdGhpcy5maW5kUHJldmlvdXNPcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gbW9iaWxlID8gdGhpcy5maW5kTmV4dE9wdGlvbig1KSA6IHRoaXMuZmluZFByZXZpb3VzT3B0aW9uKDUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgICAgICAgICAgICAgIG5ld09wdGlvbiA9IG1vYmlsZSA/IHRoaXMuZmluZFByZXZpb3VzT3B0aW9uKDUpIDogdGhpcy5maW5kTmV4dE9wdGlvbig1KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSBhbiBpb24tcGlja2VyLWNvbHVtbi1vcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAqIHNvIHdlIGRvIG5vdCB1c2UgZmlyc3RFbGVtZW50Q2hpbGQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb24gPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2lvbi1waWNrZXItY29sdW1uLW9wdGlvbjpmaXJzdC1vZi10eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlIGFuIGlvbi1waWNrZXItY29sdW1uLW9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICogc28gd2UgZG8gbm90IHVzZSBsYXN0RWxlbWVudENoaWxkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdpb24tcGlja2VyLWNvbHVtbi1vcHRpb246bGFzdC1vZi10eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld09wdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUobmV3T3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHN0b3BzIGFueSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igc3VjaCBhcyBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXRpbGl0eSB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCB0ZXh0IGZvciBhcmlhLXZhbHVldGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9uVmFsdWVUZXh0ID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gZWwgPyAoX2EgPSBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZWwuaW5uZXJUZXh0IDogJyc7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgYW4gZWxlbWVudCB0aGF0IG92ZXJsYXlzIHRoZSBjb2x1bW4uIFRoaXMgZWxlbWVudCBpcyBmb3IgYXNzaXN0aXZlXG4gICAgICAgICAqIHRlY2ggdG8gYWxsb3cgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIGNvbHVtbiB1cC9kb3duLiBUaGlzIGVsZW1lbnQgc2hvdWxkIHJlY2VpdmVcbiAgICAgICAgICogZm9jdXMgYXMgaXQgbGlzdGVucyBmb3Igc3ludGhlc2l6ZWQga2V5Ym9hcmQgZXZlbnRzIGFzIHJlcXVpcmVkIGJ5IHRoZVxuICAgICAgICAgKiBzbGlkZXIgcm9sZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQWNjZXNzaWJpbGl0eS9BUklBL1JvbGVzL3NsaWRlcl9yb2xlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlckFzc2lzdGl2ZUZvY3VzYWJsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWN0aXZlSXRlbSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVGV4dCA9IHRoaXMuZ2V0T3B0aW9uVmFsdWVUZXh0KGFjdGl2ZUl0ZW0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHVzaW5nIHRoZSBwaWNrZXIsIHRoZSB2YWx1ZXRleHQgcHJvdmlkZXMgaW1wb3J0YW50IGNvbnRleHQgdGhhdCB2YWx1ZW5vd1xuICAgICAgICAgICAgICogZG9lcyBub3QuIEFkZGl0aW9uYWxseSwgdXNpbmcgbm9uLXplcm8gdmFsdWVtaW4vdmFsdWVtYXggdmFsdWVzIGNhbiBjYXVzZVxuICAgICAgICAgICAgICogV2ViS2l0IHRvIGluY29ycmVjdGx5IGFubm91bmNlIG51bWVyaWMgdmFsdWV0ZXh0IHZhbHVlcyAoc3VjaCBhcyBhIHllYXJcbiAgICAgICAgICAgICAqIGxpa2UgXCIyMDI0XCIpIGFzIHBlcmNlbnRhZ2VzOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjczMTI2XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IHJlZjogKGVsKSA9PiAodGhpcy5hc3Npc3RpdmVGb2N1c2FibGUgPSBlbCksIGNsYXNzOiBcImFzc2lzdGl2ZS1mb2N1c2FibGVcIiwgcm9sZTogXCJzbGlkZXJcIiwgdGFiaW5kZXg6IHRoaXMuZGlzYWJsZWQgPyB1bmRlZmluZWQgOiAwLCBcImFyaWEtbGFiZWxcIjogdGhpcy5hcmlhTGFiZWwsIFwiYXJpYS12YWx1ZW1pblwiOiAwLCBcImFyaWEtdmFsdWVtYXhcIjogMCwgXCJhcmlhLXZhbHVlbm93XCI6IDAsIFwiYXJpYS12YWx1ZXRleHRcIjogdmFsdWVUZXh0LCBcImFyaWEtb3JpZW50YXRpb25cIjogXCJ2ZXJ0aWNhbFwiLCBvbktleURvd246IChldikgPT4gdGhpcy5vbktleURvd24oZXYpIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXJpYUxhYmVsQ2hhbmdlZChuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLmFyaWFMYWJlbCA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb2x1bW5WaXNpYmxlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9ubHkgc2Nyb2xsIHRoZSBhY3RpdmUgaXRlbSBpbnRvIHZpZXcgd2hlbiB0aGUgcGlja2VyIGNvbHVtblxuICAgICAgICAgICAgICogaXMgYWN0aXZlbHkgdmlzaWJsZSB0byB0aGUgdXNlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBY3RpdmVJdGVtSW50b1ZpZXcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSBzZXR1cCBzY3JvbGwgbGlzdGVuZXJzXG4gICAgICogd2hlbiB0aGUgcGlja2VyIGlzIHZpc2libGUsIG90aGVyd2lzZVxuICAgICAqIHRoZSBjb250YWluZXIgd2lsbCBoYXZlIGEgc2Nyb2xsXG4gICAgICogaGVpZ2h0IG9mIDBweC5cbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGNhY2hlIHBhcmVudEVsIGluIGEgbG9jYWwgdmFyaWFibGVcbiAgICAgICAgICogc28gd2UgZG9uJ3QgbmVlZCB0byBrZWVwIGFjY2Vzc2luZ1xuICAgICAgICAgKiB0aGUgY2xhc3MgdmFyaWFibGUgKHdoaWNoIGNvbWVzIHdpdGhcbiAgICAgICAgICogYSBzbWFsbCBwZXJmb3JtYW5jZSBoaXQpXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwYXJlbnRFbCA9ICh0aGlzLnBhcmVudEVsID0gdGhpcy5lbC5jbG9zZXN0KCdpb24tcGlja2VyJykpO1xuICAgICAgICBjb25zdCB2aXNpYmxlQ2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCcm93c2VycyB3aWxsIHNvbWV0aW1lcyBncm91cCBtdWx0aXBsZSBJTyBldmVudHMgaW50byBhIHNpbmdsZSBjYWxsYmFjay5cbiAgICAgICAgICAgICAqIEFzIGEgcmVzdWx0LCB3ZSB3YW50IHRvIGdyYWIgdGhlIGxhc3QvbW9zdCByZWNlbnQgZXZlbnQgaW4gY2FzZSB0aGVyZSBhcmUgbXVsdGlwbGUgZXZlbnRzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBldiA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChldi5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWN0aXZlSXRlbSwgZWwgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbHVtblZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEJlY2F1c2UgdGhpcyBpbml0aWFsIGNhbGwgdG8gc2Nyb2xsQWN0aXZlSXRlbUludG9WaWV3IGhhcyB0byBmaXJlIGJlZm9yZVxuICAgICAgICAgICAgICAgICAqIHRoZSBzY3JvbGwgbGlzdGVuZXIgaXMgc2V0IHVwLCB3ZSBuZWVkIHRvIG1hbmFnZSB0aGUgYWN0aXZlIGNsYXNzIG1hbnVhbGx5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEFjdGl2ZSA9IGdldEVsZW1lbnRSb290KGVsKS5xdWVyeVNlbGVjdG9yKGAuJHtQSUNLRVJfSVRFTV9BQ1RJVkVfQ0xBU1N9YCk7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBpY2tlckl0ZW1BY3RpdmVTdGF0ZShvbGRBY3RpdmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxBY3RpdmVJdGVtSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBpY2tlckl0ZW1BY3RpdmVTdGF0ZShhY3RpdmVJdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb2x1bW5WaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveVNjcm9sbExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbExpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcm9vdCB0byBiZSB0aGUgcGFyZW50IHBpY2tlciBlbGVtZW50XG4gICAgICAgICAqIFRoaXMgY2F1c2VzIHRoZSBJTyBjYWxsYmFja1xuICAgICAgICAgKiB0byBiZSBmaXJlZCBpbiBXZWJLaXQgYXMgc29vbiBhcyB0aGUgZWxlbWVudFxuICAgICAgICAgKiBpcyB2aXNpYmxlLiBJZiB3ZSB1c2VkIHRoZSBkZWZhdWx0IHJvb3QgdmFsdWVcbiAgICAgICAgICogdGhlbiBXZWJLaXQgd291bGQgb25seSBmaXJlIHRoZSBJTyBjYWxsYmFja1xuICAgICAgICAgKiBhZnRlciBhbnkgYW5pbWF0aW9ucyAoc3VjaCBhcyBhIG1vZGFsIHRyYW5zaXRpb24pXG4gICAgICAgICAqIGZpbmlzaGVkLCBhbmQgdGhlcmUgd291bGQgcG90ZW50aWFsbHkgYmUgYSBmbGlja2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKHZpc2libGVDYWxsYmFjaywgeyB0aHJlc2hvbGQ6IDAuMDAxLCByb290OiB0aGlzLnBhcmVudEVsIH0pLm9ic2VydmUodGhpcy5lbCk7XG4gICAgICAgIGlmIChwYXJlbnRFbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVE9ETyhGVy0yODMyKTogdHlwZVxuICAgICAgICAgICAgcGFyZW50RWwuYWRkRXZlbnRMaXN0ZW5lcignaW9uSW5wdXRNb2RlQ2hhbmdlJywgKGV2KSA9PiB0aGlzLmlucHV0TW9kZUNoYW5nZShldikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBlbCwgYWN0aXZlSXRlbSwgaXNDb2x1bW5WaXNpYmxlLCB2YWx1ZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKGlzQ29sdW1uVmlzaWJsZSAmJiAhYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RPcHRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCdpb24tcGlja2VyLWNvbHVtbi1vcHRpb24nKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIHBpY2tlciBjb2x1bW4gZG9lcyBub3QgaGF2ZSBhbiBhY3RpdmUgaXRlbSBhbmQgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgICAqIGRvZXMgbm90IG1hdGNoIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBwaWNrZXIgY29sdW1uLCB0aGF0IG1lYW5zXG4gICAgICAgICAgICAgKiB0aGUgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcy4gSW4gdGhpcyBjYXNlLCB3ZSBhc3NpZ24gdGhlIHZhbHVlIHRvIHRoZVxuICAgICAgICAgICAgICogZmlyc3QgaXRlbSB0byBtYXRjaCB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBjb2x1bW4uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZmlyc3RPcHRpb24gIT09IG51bGwgJiYgZmlyc3RPcHRpb24udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShmaXJzdE9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAgKi9cbiAgICBhc3luYyBzY3JvbGxBY3RpdmVJdGVtSW50b1ZpZXcoc21vb3RoID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlRWwgPSB0aGlzLmFjdGl2ZUl0ZW07XG4gICAgICAgIGlmIChhY3RpdmVFbCkge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJQaWNrZXJJdGVtSW5WaWV3KGFjdGl2ZUVsLCBzbW9vdGgsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBwcm9wIGFuZCBmaXJlcyB0aGUgaW9uQ2hhbmdlIGV2ZW50LlxuICAgICAqIFRoaXMgaXMgdXNlZCB3aGVuIHdlIG5lZWQgdG8gZmlyZSBpb25DaGFuZ2UgZnJvbVxuICAgICAqIHVzZXItZ2VuZXJhdGVkIGV2ZW50cyB0aGF0IGNhbm5vdCBiZSBjYXVnaHQgd2l0aCBub3JtYWxcbiAgICAgKiBpbnB1dC9jaGFuZ2UgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkID09PSB0cnVlIHx8IHRoaXMudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlvbkNoYW5nZS5lbWl0KHsgdmFsdWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgZm9jdXMgb24gdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIHdpdGhpbiB0aGUgcGlja2VyIGNvbHVtbi5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiB0aGUgZ2xvYmFsIGBwaWNrZXJDb2x1bW4uZm9jdXMoKWAuXG4gICAgICovXG4gICAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmFzc2lzdGl2ZUZvY3VzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5hc3Npc3RpdmVGb2N1c2FibGUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmFyaWFMYWJlbCA9IChfYSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdTZWxlY3QgYSB2YWx1ZSc7XG4gICAgfVxuICAgIGdldCBhY3RpdmVJdGVtKCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gQXJyYXkuZnJvbSh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1waWNrZXItY29sdW1uLW9wdGlvbicpKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmluZCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSB3aG9sZSBwaWNrZXIgY29sdW1uIGlzIGRpc2FibGVkLCB0aGUgY3VycmVudCB2YWx1ZSBzaG91bGQgYXBwZWFyIGFjdGl2ZVxuICAgICAgICAgICAgICogSWYgdGhlIGN1cnJlbnQgdmFsdWUgaXRlbSBpcyBzcGVjaWZpY2FsbHkgZGlzYWJsZWQsIGl0IHNob3VsZCBub3QgYXBwZWFyIGFjdGl2ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgb3B0aW9uLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIGRpc2FibGVkLCBpc0FjdGl2ZSwgbnVtZXJpY0lucHV0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsga2V5OiAnZWEwMjgwMzU1YjJmODc4OTViZjdkZGRkMjg5Y2NmNDczYWE3NTlmMycsIGNsYXNzOiBjcmVhdGVDb2xvckNsYXNzZXMoY29sb3IsIHtcbiAgICAgICAgICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgICAgICAgICAgWydwaWNrZXItY29sdW1uLWFjdGl2ZSddOiBpc0FjdGl2ZSxcbiAgICAgICAgICAgICAgICBbJ3BpY2tlci1jb2x1bW4tbnVtZXJpYy1pbnB1dCddOiBudW1lcmljSW5wdXQsXG4gICAgICAgICAgICAgICAgWydwaWNrZXItY29sdW1uLWRpc2FibGVkJ106IGRpc2FibGVkLFxuICAgICAgICAgICAgfSkgfSwgdGhpcy5yZW5kZXJBc3Npc3RpdmVGb2N1c2FibGUoKSwgaChcInNsb3RcIiwgeyBrZXk6ICc0ODI5OTIxMzFjZGViODViMWY2MTQzMGQ3ZmUxMzIyYTE2MzQ1NzY5JywgbmFtZTogXCJwcmVmaXhcIiB9KSwgaChcImRpdlwiLCB7IGtleTogJzQzZjdmODBkNjIxZDQxMWVmMzY2YjNjYTEzOTYyOTllOGM5YTBjOTcnLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjbGFzczogXCJwaWNrZXItb3B0c1wiLCByZWY6IChlbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWwgPSBlbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYW4gZWxlbWVudCBoYXMgYW4gb3ZlcmxheSBzY3JvbGwgc3R5bGUgYW5kXG4gICAgICAgICAgICAgKiBhIGZpeGVkIGhlaWdodCwgRmlyZWZveCB3aWxsIGZvY3VzIHRoZSBzY3JvbGxhYmxlXG4gICAgICAgICAgICAgKiBjb250YWluZXIgaWYgdGhlIGNvbnRlbnQgZXhjZWVkcyB0aGUgY29udGFpbmVyJ3NcbiAgICAgICAgICAgICAqIGRpbWVuc2lvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhpcyBjYXVzZXMga2V5Ym9hcmQgbmF2aWdhdGlvbiB0byBmb2N1cyB0byB0aGlzXG4gICAgICAgICAgICAgKiBlbGVtZW50IGluc3RlYWQgb2YgZ29pbmcgdG8gdGhlIG5leHQgZWxlbWVudCBpblxuICAgICAgICAgICAgICogdGhlIHRhYiBvcmRlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgZGVzaXJlZCBiZWhhdmlvciBpcyBmb3IgdGhlIHVzZXIgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgICAgICogZm9jdXMgdGhlIGFzc2lzdGl2ZSBmb2N1c2FibGUgZWxlbWVudCBhbmQgdGFiIHRvXG4gICAgICAgICAgICAgKiB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSB0YWIgb3JkZXIuIEluc3RlYWQgb2YgdGFiYmluZ1xuICAgICAgICAgICAgICogdG8gdGhpcyBlbGVtZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRvIHByZXZlbnQgdGhpcywgd2Ugc2V0IHRoZSB0YWJJbmRleCB0byAtMS4gVGhpc1xuICAgICAgICAgICAgICogd2lsbCBtYXRjaCB0aGUgYmVoYXZpb3Igb2YgdGhlIG90aGVyIGJyb3dzZXJzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0YWJJbmRleDogLTEgfSwgaChcImRpdlwiLCB7IGtleTogJzEzYTllZTY4NjEzMmFmMzIyNDA3MTA3MzA3NjVkZTRjMDAwM2E5ZTgnLCBjbGFzczogXCJwaWNrZXItaXRlbS1lbXB0eVwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIFwiXFx1MDBBMFwiKSwgaChcImRpdlwiLCB7IGtleTogJ2RiY2NiYTQ5MjA4MzNjZmNlYmU5YjBmYzc2MzQ1OGVjMzA1MzcwNWEnLCBjbGFzczogXCJwaWNrZXItaXRlbS1lbXB0eVwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIFwiXFx1MDBBMFwiKSwgaChcImRpdlwiLCB7IGtleTogJzY4MmI0M2Y4M2E1ZWEyZTQ2MDY3NDU3ZjNhZjExODUzNWUxMTFlZGInLCBjbGFzczogXCJwaWNrZXItaXRlbS1lbXB0eVwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIFwiXFx1MDBBMFwiKSwgaChcInNsb3RcIiwgeyBrZXk6ICdkMjdlMWUxZGMwNTA0YjJmNDYyN2EyOTkxMmEwNWJiOTFlOGU0MTNhJyB9KSwgaChcImRpdlwiLCB7IGtleTogJzYxYzk0OGRiYjljZjc0NjlhZWQzMDE4NTQyYmMwOTU0MjExNTg1YmEnLCBjbGFzczogXCJwaWNrZXItaXRlbS1lbXB0eVwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIFwiXFx1MDBBMFwiKSwgaChcImRpdlwiLCB7IGtleTogJ2NmNDZjMjc3ZmJlZTY1ZTM1ZmY0NGNlMGQ1M2NlMTJhYTljYmY5ZGInLCBjbGFzczogXCJwaWNrZXItaXRlbS1lbXB0eVwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIFwiXFx1MDBBMFwiKSwgaChcImRpdlwiLCB7IGtleTogJ2JiYzBlMmQ0OTFkM2Y4MzZhYjg0OTQ5M2FkZTJmN2ZhNmFkOTI0NGUnLCBjbGFzczogXCJwaWNrZXItaXRlbS1lbXB0eVwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIFwiXFx1MDBBMFwiKSksIGgoXCJzbG90XCIsIHsga2V5OiAnZDI1Y2JiZTE0YjI5MTRmZTdiODc4ZDQzYjRlM2Y0YThjODE3N2QyNCcsIG5hbWU6IFwic3VmZml4XCIgfSkpKTtcbiAgICB9XG4gICAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICAgIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBbXCJhcmlhTGFiZWxDaGFuZ2VkXCJdLFxuICAgICAgICBcInZhbHVlXCI6IFtcInZhbHVlQ2hhbmdlXCJdXG4gICAgfTsgfVxufTtcbmNvbnN0IFBJQ0tFUl9JVEVNX0FDVElWRV9DTEFTUyA9ICdvcHRpb24tYWN0aXZlJztcblBpY2tlckNvbHVtbi5zdHlsZSA9IHBpY2tlckNvbHVtbkNzcztcblxuZXhwb3J0IHsgUGlja2VyQ29sdW1uIGFzIGlvbl9waWNrZXJfY29sdW1uIH07XG4iXSwibmFtZXMiOlsiciIsInJlZ2lzdGVySW5zdGFuY2UiLCJkIiwiY3JlYXRlRXZlbnQiLCJhIiwiaXNQbGF0Zm9ybSIsImgiLCJlIiwiZ2V0SW9uTW9kZSIsImoiLCJIb3N0IiwiayIsImdldEVsZW1lbnQiLCJkb2MiLCJyYWYiLCJnIiwiZ2V0RWxlbWVudFJvb3QiLCJiIiwiaGFwdGljU2VsZWN0aW9uU3RhcnQiLCJoYXB0aWNTZWxlY3Rpb25DaGFuZ2VkIiwiaGFwdGljU2VsZWN0aW9uRW5kIiwiYyIsImNyZWF0ZUNvbG9yQ2xhc3NlcyIsInBpY2tlckNvbHVtbkNzcyIsIlBpY2tlckNvbHVtbiIsImNvbnN0cnVjdG9yIiwiaG9zdFJlZiIsImlvbkNoYW5nZSIsImlzU2Nyb2xsaW5nIiwiaXNDb2x1bW5WaXNpYmxlIiwiY2FuRXhpdElucHV0TW9kZSIsInVwZGF0ZVZhbHVlVGV4dE9uU2Nyb2xsIiwiYXJpYUxhYmVsIiwiaXNBY3RpdmUiLCJkaXNhYmxlZCIsImNvbG9yIiwibnVtZXJpY0lucHV0IiwiY2VudGVyUGlja2VySXRlbUluVmlldyIsInRhcmdldCIsInNtb290aCIsInNjcm9sbEVsIiwidG9wIiwib2Zmc2V0VG9wIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsIiwibGVmdCIsImJlaGF2aW9yIiwidW5kZWZpbmVkIiwic2V0UGlja2VySXRlbUFjdGl2ZVN0YXRlIiwiaXRlbSIsImNsYXNzTGlzdCIsImFkZCIsIlBJQ0tFUl9JVEVNX0FDVElWRV9DTEFTUyIsInJlbW92ZSIsImlucHV0TW9kZUNoYW5nZSIsImV2IiwidXNlSW5wdXRNb2RlIiwiaW5wdXRNb2RlQ29sdW1uIiwiZGV0YWlsIiwiaXNDb2x1bW5BY3RpdmUiLCJlbCIsInNldElucHV0TW9kZUFjdGl2ZSIsInN0YXRlIiwic2Nyb2xsRW5kQ2FsbGJhY2siLCJpbml0aWFsaXplU2Nyb2xsTGlzdGVuZXIiLCJlbmFibGVIYXB0aWNzIiwidGltZW91dCIsImFjdGl2ZUVsIiwiYWN0aXZlSXRlbSIsInNjcm9sbENhbGxiYWNrIiwiX2EiLCJjbGVhclRpbWVvdXQiLCJiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2VudGVyWCIsIngiLCJ3aWR0aCIsImNlbnRlclkiLCJ5IiwiaGVpZ2h0Iiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsImhhc1BhcmVudFNoYWRvdyIsIlNoYWRvd1Jvb3QiLCJyZWZlcmVuY2VOb2RlIiwiZWxlbWVudHNBdFBvaW50IiwiZWxlbWVudHNGcm9tUG9pbnQiLCJuZXdBY3RpdmVFbGVtZW50IiwiZmluZCIsInRhZ05hbWUiLCJmYWxsYmFja0FjdGl2ZUVsZW1lbnQiLCJlbGVtZW50RnJvbVBvaW50IiwiZXhpdElucHV0TW9kZSIsImFzc2lzdGl2ZUZvY3VzYWJsZSIsInNldEF0dHJpYnV0ZSIsImdldE9wdGlvblZhbHVlVGV4dCIsInNldFRpbWVvdXQiLCJzZXRWYWx1ZSIsInZhbHVlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRlc3Ryb3lTY3JvbGxMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXJlbnRFbCIsImZpbmROZXh0T3B0aW9uIiwic3RyaWRlIiwicHJldk5vZGUiLCJub2RlIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiZmluZFByZXZpb3VzT3B0aW9uIiwibmV4dE5vZGUiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwib25LZXlEb3duIiwibW9iaWxlIiwibmV3T3B0aW9uIiwia2V5IiwicXVlcnlTZWxlY3RvciIsInByZXZlbnREZWZhdWx0IiwiZ2V0QXR0cmlidXRlIiwiaW5uZXJUZXh0IiwicmVuZGVyQXNzaXN0aXZlRm9jdXNhYmxlIiwidmFsdWVUZXh0IiwicmVmIiwiY2xhc3MiLCJyb2xlIiwidGFiaW5kZXgiLCJhcmlhTGFiZWxDaGFuZ2VkIiwibmV3VmFsdWUiLCJ2YWx1ZUNoYW5nZSIsInNjcm9sbEFjdGl2ZUl0ZW1JbnRvVmlldyIsImNvbXBvbmVudFdpbGxMb2FkIiwiY2xvc2VzdCIsInZpc2libGVDYWxsYmFjayIsImVudHJpZXMiLCJsZW5ndGgiLCJpc0ludGVyc2VjdGluZyIsIm9sZEFjdGl2ZSIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwidGhyZXNob2xkIiwicm9vdCIsIm9ic2VydmUiLCJjb21wb25lbnREaWRSZW5kZXIiLCJmaXJzdE9wdGlvbiIsIl90aGlzIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJhcHBseSIsImFyZ3VtZW50cyIsIl90aGlzMiIsImVtaXQiLCJzZXRGb2N1cyIsIl90aGlzMyIsImZvY3VzIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJvcHRpb25zIiwiQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsIm9wdGlvbiIsInJlbmRlciIsIm1vZGUiLCJuYW1lIiwidGFiSW5kZXgiLCJ3YXRjaGVycyIsInN0eWxlIiwiaW9uX3BpY2tlcl9jb2x1bW4iXSwic291cmNlUm9vdCI6IndlYnBhY2s6Ly8vIiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzBdfQ==