"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ionic_core_dist_esm_data-GIsHsYIB_js"],{

/***/ 1279:
/*!************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/data-GIsHsYIB.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getClosestValidDate),
/* harmony export */   B: () => (/* binding */ generateMonths),
/* harmony export */   C: () => (/* binding */ getNumDaysInMonth),
/* harmony export */   D: () => (/* binding */ getCombinedDateColumnData),
/* harmony export */   E: () => (/* binding */ getMonthColumnData),
/* harmony export */   F: () => (/* binding */ getDayColumnData),
/* harmony export */   G: () => (/* binding */ getYearColumnData),
/* harmony export */   H: () => (/* binding */ isMonthFirstLocale),
/* harmony export */   I: () => (/* binding */ getTimeColumnsData),
/* harmony export */   J: () => (/* binding */ isLocaleDayPeriodRTL),
/* harmony export */   K: () => (/* binding */ calculateHourFromAMPM),
/* harmony export */   L: () => (/* binding */ getDaysOfWeek),
/* harmony export */   M: () => (/* binding */ getMonthAndYear),
/* harmony export */   N: () => (/* binding */ getDaysOfMonth),
/* harmony export */   O: () => (/* binding */ getHourCycle),
/* harmony export */   P: () => (/* binding */ getLocalizedTime),
/* harmony export */   Q: () => (/* binding */ getLocalizedDateTime),
/* harmony export */   R: () => (/* binding */ formatValue),
/* harmony export */   a: () => (/* binding */ isAfter),
/* harmony export */   b: () => (/* binding */ getNextMonth),
/* harmony export */   c: () => (/* binding */ isSameDay),
/* harmony export */   d: () => (/* binding */ getDay),
/* harmony export */   e: () => (/* binding */ generateDayAriaLabel),
/* harmony export */   f: () => (/* binding */ getPartsFromCalendarDay),
/* harmony export */   g: () => (/* binding */ getPreviousMonth),
/* harmony export */   h: () => (/* binding */ getNextYear),
/* harmony export */   i: () => (/* binding */ isBefore),
/* harmony export */   j: () => (/* binding */ getPreviousYear),
/* harmony export */   k: () => (/* binding */ getEndOfWeek),
/* harmony export */   l: () => (/* binding */ getStartOfWeek),
/* harmony export */   m: () => (/* binding */ getPreviousDay),
/* harmony export */   n: () => (/* binding */ getNextDay),
/* harmony export */   o: () => (/* binding */ getPreviousWeek),
/* harmony export */   p: () => (/* binding */ getNextWeek),
/* harmony export */   q: () => (/* binding */ parseMinParts),
/* harmony export */   r: () => (/* binding */ parseMaxParts),
/* harmony export */   s: () => (/* binding */ parseDate),
/* harmony export */   t: () => (/* binding */ parseAmPm),
/* harmony export */   u: () => (/* binding */ clampDate),
/* harmony export */   v: () => (/* binding */ validateParts),
/* harmony export */   w: () => (/* binding */ warnIfValueOutOfBounds),
/* harmony export */   x: () => (/* binding */ convertToArrayOfNumbers),
/* harmony export */   y: () => (/* binding */ convertDataToISO),
/* harmony export */   z: () => (/* binding */ getToday)
/* harmony export */ });
/* harmony import */ var _index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-B_U9CtaY.js */ 4917);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */


/**
 * Returns true if the selected day is equal to the reference day
 */
const isSameDay = (baseParts, compareParts) => {
  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;
};
/**
 * Returns true is the selected day is before the reference day.
 */
const isBefore = (baseParts, compareParts) => {
  return !!(baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day < compareParts.day);
};
/**
 * Returns true is the selected day is after the reference day.
 */
const isAfter = (baseParts, compareParts) => {
  return !!(baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day > compareParts.day);
};
const warnIfValueOutOfBounds = (value, min, max) => {
  const valueArray = Array.isArray(value) ? value : [value];
  for (const val of valueArray) {
    if (min !== undefined && isBefore(val, min) || max !== undefined && isAfter(val, max)) {
      (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_0__.m)('[ion-datetime] - The value provided to ion-datetime is out of bounds.\n\n' + `Min: ${JSON.stringify(min)}\n` + `Max: ${JSON.stringify(max)}\n` + `Value: ${JSON.stringify(value)}`);
      break;
    }
  }
};

/**
 * Determines if given year is a
 * leap year. Returns `true` if year
 * is a leap year. Returns `false`
 * otherwise.
 */
const isLeapYear = year => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
/**
 * Determines the hour cycle for a user.
 * If the hour cycle is explicitly defined, just use that.
 * Otherwise, we try to derive it from either the specified
 * locale extension tags or from Intl.DateTimeFormat directly.
 */
const getHourCycle = (locale, hourCycle) => {
  /**
   * If developer has explicitly enabled 24-hour time
   * then return early and do not look at the system default.
   */
  if (hourCycle !== undefined) {
    return hourCycle;
  }
  /**
   * If hourCycle was not specified, check the locale
   * that is set on the user's device. We first check the
   * Intl.DateTimeFormat hourCycle option as developers can encode this
   * option into the locale string. Example: `en-US-u-hc-h23`
   */
  const formatted = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  });
  const options = formatted.resolvedOptions();
  if (options.hourCycle !== undefined) {
    return options.hourCycle;
  }
  /**
   * If hourCycle is not specified (either through lack
   * of browser support or locale information) then fall
   * back to this slower hourCycle check.
   */
  const date = new Date('5/18/2021 00:00');
  const parts = formatted.formatToParts(date);
  const hour = parts.find(p => p.type === 'hour');
  if (!hour) {
    throw new Error('Hour value not found from DateTimeFormat');
  }
  /**
   * Midnight for h11 starts at 0:00am
   * Midnight for h12 starts at 12:00am
   * Midnight for h23 starts at 00:00
   * Midnight for h24 starts at 24:00
   */
  switch (hour.value) {
    case '0':
      return 'h11';
    case '12':
      return 'h12';
    case '00':
      return 'h23';
    case '24':
      return 'h24';
    default:
      throw new Error(`Invalid hour cycle "${hourCycle}"`);
  }
};
/**
 * Determine if the hour cycle uses a 24-hour format.
 * Returns true for h23 and h24. Returns false otherwise.
 * If you don't know the hourCycle, use getHourCycle above
 * and pass the result into this function.
 */
const is24Hour = hourCycle => {
  return hourCycle === 'h23' || hourCycle === 'h24';
};
/**
 * Given a date object, returns the number
 * of days in that month.
 * Month value begin at 1, not 0.
 * i.e. January = month 1.
 */
const getNumDaysInMonth = (month, year) => {
  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear(year) ? 29 : 28 : 31;
};
/**
 * Certain locales display month then year while
 * others display year then month.
 * We can use Intl.DateTimeFormat to determine
 * the ordering for each locale.
 * The formatOptions param can be used to customize
 * which pieces of a date to compare against the month
 * with. For example, some locales render dd/mm/yyyy
 * while others render mm/dd/yyyy. This function can be
 * used for variations of the same "month first" check.
 */
const isMonthFirstLocale = (locale, formatOptions = {
  month: 'numeric',
  year: 'numeric'
}) => {
  /**
   * By setting month and year we guarantee that only
   * month, year, and literal (slashes '/', for example)
   * values are included in the formatToParts results.
   *
   * The ordering of the parts will be determined by
   * the locale. So if the month is the first value,
   * then we know month should be shown first. If the
   * year is the first value, then we know year should be shown first.
   *
   * This ordering can be controlled by customizing the locale property.
   */
  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());
  return parts[0].type === 'month';
};
/**
 * Determines if the given locale formats the day period (am/pm) to the
 * left or right of the hour.
 * @param locale The locale to check.
 * @returns `true` if the locale formats the day period to the left of the hour.
 */
const isLocaleDayPeriodRTL = locale => {
  const parts = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  }).formatToParts(new Date());
  return parts[0].type === 'dayPeriod';
};
const ISO_8601_REGEXP =
// eslint-disable-next-line no-useless-escape
/^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
// eslint-disable-next-line no-useless-escape
const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
/**
 * Use to convert a string of comma separated numbers or
 * an array of numbers, and clean up any user input
 */
const convertToArrayOfNumbers = input => {
  if (input === undefined) {
    return;
  }
  let processedInput = input;
  if (typeof input === 'string') {
    // convert the string to an array of strings
    // auto remove any whitespace and [] characters
    processedInput = input.replace(/\[|\]|\s/g, '').split(',');
  }
  let values;
  if (Array.isArray(processedInput)) {
    // ensure each value is an actual number in the returned array
    values = processedInput.map(num => parseInt(num, 10)).filter(isFinite);
  } else {
    values = [processedInput];
  }
  return values;
};
/**
 * Extracts date information
 * from a .calendar-day element
 * into DatetimeParts.
 */
const getPartsFromCalendarDay = el => {
  return {
    month: parseInt(el.getAttribute('data-month'), 10),
    day: parseInt(el.getAttribute('data-day'), 10),
    year: parseInt(el.getAttribute('data-year'), 10),
    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10)
  };
};
function parseDate(val) {
  if (Array.isArray(val)) {
    const parsedArray = [];
    for (const valStr of val) {
      const parsedVal = parseDate(valStr);
      /**
       * If any of the values weren't parsed correctly, consider
       * the entire batch incorrect. This simplifies the type
       * signatures by having "undefined" be a general error case
       * instead of returning (Datetime | undefined)[], which is
       * harder for TS to perform type narrowing on.
       */
      if (!parsedVal) {
        return undefined;
      }
      parsedArray.push(parsedVal);
    }
    return parsedArray;
  }
  // manually parse IS0 cuz Date.parse cannot be trusted
  // ISO 8601 format: 1994-12-15T13:47:20Z
  let parse = null;
  if (val != null && val !== '') {
    // try parsing for just time first, HH:MM
    parse = TIME_REGEXP.exec(val);
    if (parse) {
      // adjust the array so it fits nicely with the datetime parse
      parse.unshift(undefined, undefined);
      parse[2] = parse[3] = undefined;
    } else {
      // try parsing for full ISO datetime
      parse = ISO_8601_REGEXP.exec(val);
    }
  }
  if (parse === null) {
    // wasn't able to parse the ISO datetime
    (0,_index_B_U9CtaY_js__WEBPACK_IMPORTED_MODULE_0__.m)(`[ion-datetime] - Unable to parse date string: ${val}. Please provide a valid ISO 8601 datetime string.`);
    return undefined;
  }
  // ensure all the parse values exist with at least 0
  for (let i = 1; i < 8; i++) {
    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;
  }
  // can also get second and millisecond from parse[6] and parse[7] if needed
  return {
    year: parse[1],
    month: parse[2],
    day: parse[3],
    hour: parse[4],
    minute: parse[5],
    ampm: parse[4] < 12 ? 'am' : 'pm'
  };
}
const clampDate = (dateParts, minParts, maxParts) => {
  if (minParts && isBefore(dateParts, minParts)) {
    return minParts;
  } else if (maxParts && isAfter(dateParts, maxParts)) {
    return maxParts;
  }
  return dateParts;
};
/**
 * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).
 * @param hour The hour to format, should be 0-23
 * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.
 */
const parseAmPm = hour => {
  return hour >= 12 ? 'pm' : 'am';
};
/**
 * Takes a max date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, max="2012" would fill in the missing
 * month, day, hour, and minute information.
 */
const parseMaxParts = (max, todayParts) => {
  const result = parseDate(max);
  /**
   * If min was not a valid date then return undefined.
   */
  if (result === undefined) {
    return;
  }
  const {
    month,
    day,
    year,
    hour,
    minute
  } = result;
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */
  const yearValue = year !== null && year !== void 0 ? year : todayParts.year;
  const monthValue = month !== null && month !== void 0 ? month : 12;
  return {
    month: monthValue,
    day: day !== null && day !== void 0 ? day : getNumDaysInMonth(monthValue, yearValue),
    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: yearValue,
    hour: hour !== null && hour !== void 0 ? hour : 23,
    minute: minute !== null && minute !== void 0 ? minute : 59
  };
};
/**
 * Takes a min date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, min="2012" would fill in the missing
 * month, day, hour, and minute information.
 */
const parseMinParts = (min, todayParts) => {
  const result = parseDate(min);
  /**
   * If min was not a valid date then return undefined.
   */
  if (result === undefined) {
    return;
  }
  const {
    month,
    day,
    year,
    hour,
    minute
  } = result;
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */
  return {
    month: month !== null && month !== void 0 ? month : 1,
    day: day !== null && day !== void 0 ? day : 1,
    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: year !== null && year !== void 0 ? year : todayParts.year,
    hour: hour !== null && hour !== void 0 ? hour : 0,
    minute: minute !== null && minute !== void 0 ? minute : 0
  };
};
const twoDigit = val => {
  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);
};
const fourDigit = val => {
  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);
};
function convertDataToISO(data) {
  if (Array.isArray(data)) {
    return data.map(parts => convertDataToISO(parts));
  }
  // https://www.w3.org/TR/NOTE-datetime
  let rtn = '';
  if (data.year !== undefined) {
    // YYYY
    rtn = fourDigit(data.year);
    if (data.month !== undefined) {
      // YYYY-MM
      rtn += '-' + twoDigit(data.month);
      if (data.day !== undefined) {
        // YYYY-MM-DD
        rtn += '-' + twoDigit(data.day);
        if (data.hour !== undefined) {
          // YYYY-MM-DDTHH:mm:SS
          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;
        }
      }
    }
  } else if (data.hour !== undefined) {
    // HH:mm
    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
  }
  return rtn;
}
/**
 * Converts an 12 hour value to 24 hours.
 */
const convert12HourTo24Hour = (hour, ampm) => {
  if (ampm === undefined) {
    return hour;
  }
  /**
   * If AM and 12am
   * then return 00:00.
   * Otherwise just return
   * the hour since it is
   * already in 24 hour format.
   */
  if (ampm === 'am') {
    if (hour === 12) {
      return 0;
    }
    return hour;
  }
  /**
   * If PM and 12pm
   * just return 12:00
   * since it is already
   * in 24 hour format.
   * Otherwise add 12 hours
   * to the time.
   */
  if (hour === 12) {
    return 12;
  }
  return hour + 12;
};
const getStartOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;
  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }
  return subtractDays(refParts, dayOfWeek);
};
const getEndOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;
  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }
  return addDays(refParts, 6 - dayOfWeek);
};
const getNextDay = refParts => {
  return addDays(refParts, 1);
};
const getPreviousDay = refParts => {
  return subtractDays(refParts, 1);
};
const getPreviousWeek = refParts => {
  return subtractDays(refParts, 7);
};
const getNextWeek = refParts => {
  return addDays(refParts, 7);
};
/**
 * Given datetime parts, subtract
 * numDays from the date.
 * Returns a new DatetimeParts object
 * Currently can only go backward at most 1 month.
 */
const subtractDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;
  if (day === null) {
    throw new Error('No day provided');
  }
  const workingParts = {
    month,
    day,
    year
  };
  workingParts.day = day - numDays;
  /**
   * If wrapping to previous month
   * update days and decrement month
   */
  if (workingParts.day < 1) {
    workingParts.month -= 1;
  }
  /**
   * If moving to previous year, reset
   * month to December and decrement year
   */
  if (workingParts.month < 1) {
    workingParts.month = 12;
    workingParts.year -= 1;
  }
  /**
   * Determine how many days are in the current
   * month
   */
  if (workingParts.day < 1) {
    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);
    /**
     * Take num days in month and add the
     * number of underflow days. This number will
     * be negative.
     * Example: 1 week before Jan 2, 2021 is
     * December 26, 2021 so:
     * 2 - 7 = -5
     * 31 + (-5) = 26
     */
    workingParts.day = daysInMonth + workingParts.day;
  }
  return workingParts;
};
/**
 * Given datetime parts, add
 * numDays to the date.
 * Returns a new DatetimeParts object
 * Currently can only go forward at most 1 month.
 */
const addDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;
  if (day === null) {
    throw new Error('No day provided');
  }
  const workingParts = {
    month,
    day,
    year
  };
  const daysInMonth = getNumDaysInMonth(month, year);
  workingParts.day = day + numDays;
  /**
   * If wrapping to next month
   * update days and increment month
   */
  if (workingParts.day > daysInMonth) {
    workingParts.day -= daysInMonth;
    workingParts.month += 1;
  }
  /**
   * If moving to next year, reset
   * month to January and increment year
   */
  if (workingParts.month > 12) {
    workingParts.month = 1;
    workingParts.year += 1;
  }
  return workingParts;
};
/**
 * Given DatetimeParts, generate the previous month.
 */
const getPreviousMonth = refParts => {
  /**
   * If current month is January, wrap backwards
   *  to December of the previous year.
   */
  const month = refParts.month === 1 ? 12 : refParts.month - 1;
  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the next month.
 */
const getNextMonth = refParts => {
  /**
   * If current month is December, wrap forwards
   *  to January of the next year.
   */
  const month = refParts.month === 12 ? 1 : refParts.month + 1;
  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
const changeYear = (refParts, yearDelta) => {
  const month = refParts.month;
  const year = refParts.year + yearDelta;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the previous year.
 */
const getPreviousYear = refParts => {
  return changeYear(refParts, -1);
};
/**
 * Given DatetimeParts, generate the next year.
 */
const getNextYear = refParts => {
  return changeYear(refParts, 1);
};
/**
 * If PM, then internal value should
 * be converted to 24-hr time.
 * Does not apply when public
 * values are already 24-hr time.
 */
const getInternalHourValue = (hour, use24Hour, ampm) => {
  if (use24Hour) {
    return hour;
  }
  return convert12HourTo24Hour(hour, ampm);
};
/**
 * Unless otherwise stated, all month values are
 * 1 indexed instead of the typical 0 index in JS Date.
 * Example:
 *   January = Month 0 when using JS Date
 *   January = Month 1 when using this datetime util
 */
/**
 * Given the current datetime parts and a new AM/PM value
 * calculate what the hour should be in 24-hour time format.
 * Used when toggling the AM/PM segment since we store our hours
 * in 24-hour time format internally.
 */
const calculateHourFromAMPM = (currentParts, newAMPM) => {
  const {
    ampm: currentAMPM,
    hour
  } = currentParts;
  let newHour = hour;
  /**
   * If going from AM --> PM, need to update the
   *
   */
  if (currentAMPM === 'am' && newAMPM === 'pm') {
    newHour = convert12HourTo24Hour(newHour, 'pm');
    /**
     * If going from PM --> AM
     */
  } else if (currentAMPM === 'pm' && newAMPM === 'am') {
    newHour = Math.abs(newHour - 12);
  }
  return newHour;
};
/**
 * Updates parts to ensure that month and day
 * values are valid. For days that do not exist,
 * or are outside the min/max bounds, the closest
 * valid day is used.
 */
const validateParts = (parts, minParts, maxParts) => {
  const {
    month,
    day,
    year
  } = parts;
  const partsCopy = clampDate(Object.assign({}, parts), minParts, maxParts);
  const numDays = getNumDaysInMonth(month, year);
  /**
   * If the max number of days
   * is greater than the day we want
   * to set, update the DatetimeParts
   * day field to be the max days.
   */
  if (day !== null && numDays < day) {
    partsCopy.day = numDays;
  }
  /**
   * If value is same day as min day,
   * make sure the time value is in bounds.
   */
  if (minParts !== undefined && isSameDay(partsCopy, minParts)) {
    /**
     * If the hour is out of bounds,
     * update both the hour and minute.
     * This is done so that the new time
     * is closest to what the user selected.
     */
    if (partsCopy.hour !== undefined && minParts.hour !== undefined) {
      if (partsCopy.hour < minParts.hour) {
        partsCopy.hour = minParts.hour;
        partsCopy.minute = minParts.minute;
        /**
         * If only the minute is out of bounds,
         * set it to the min minute.
         */
      } else if (partsCopy.hour === minParts.hour && partsCopy.minute !== undefined && minParts.minute !== undefined && partsCopy.minute < minParts.minute) {
        partsCopy.minute = minParts.minute;
      }
    }
  }
  /**
   * If value is same day as max day,
   * make sure the time value is in bounds.
   */
  if (maxParts !== undefined && isSameDay(parts, maxParts)) {
    /**
     * If the hour is out of bounds,
     * update both the hour and minute.
     * This is done so that the new time
     * is closest to what the user selected.
     */
    if (partsCopy.hour !== undefined && maxParts.hour !== undefined) {
      if (partsCopy.hour > maxParts.hour) {
        partsCopy.hour = maxParts.hour;
        partsCopy.minute = maxParts.minute;
        /**
         * If only the minute is out of bounds,
         * set it to the max minute.
         */
      } else if (partsCopy.hour === maxParts.hour && partsCopy.minute !== undefined && maxParts.minute !== undefined && partsCopy.minute > maxParts.minute) {
        partsCopy.minute = maxParts.minute;
      }
    }
  }
  return partsCopy;
};
/**
 * Returns the closest date to refParts
 * that also meets the constraints of
 * the *Values params.
 */
const getClosestValidDate = ({
  refParts,
  monthValues,
  dayValues,
  yearValues,
  hourValues,
  minuteValues,
  minParts,
  maxParts
}) => {
  const {
    hour,
    minute,
    day,
    month,
    year
  } = refParts;
  const copyParts = Object.assign(Object.assign({}, refParts), {
    dayOfWeek: undefined
  });
  if (yearValues !== undefined) {
    // Filters out years that are out of the min/max bounds
    const filteredYears = yearValues.filter(year => {
      if (minParts !== undefined && year < minParts.year) {
        return false;
      }
      if (maxParts !== undefined && year > maxParts.year) {
        return false;
      }
      return true;
    });
    copyParts.year = findClosestValue(year, filteredYears);
  }
  if (monthValues !== undefined) {
    // Filters out months that are out of the min/max bounds
    const filteredMonths = monthValues.filter(month => {
      if (minParts !== undefined && copyParts.year === minParts.year && month < minParts.month) {
        return false;
      }
      if (maxParts !== undefined && copyParts.year === maxParts.year && month > maxParts.month) {
        return false;
      }
      return true;
    });
    copyParts.month = findClosestValue(month, filteredMonths);
  }
  // Day is nullable but cannot be undefined
  if (day !== null && dayValues !== undefined) {
    // Filters out days that are out of the min/max bounds
    const filteredDays = dayValues.filter(day => {
      if (minParts !== undefined && isBefore(Object.assign(Object.assign({}, copyParts), {
        day
      }), minParts)) {
        return false;
      }
      if (maxParts !== undefined && isAfter(Object.assign(Object.assign({}, copyParts), {
        day
      }), maxParts)) {
        return false;
      }
      return true;
    });
    copyParts.day = findClosestValue(day, filteredDays);
  }
  if (hour !== undefined && hourValues !== undefined) {
    // Filters out hours that are out of the min/max bounds
    const filteredHours = hourValues.filter(hour => {
      if ((minParts === null || minParts === void 0 ? void 0 : minParts.hour) !== undefined && isSameDay(copyParts, minParts) && hour < minParts.hour) {
        return false;
      }
      if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.hour) !== undefined && isSameDay(copyParts, maxParts) && hour > maxParts.hour) {
        return false;
      }
      return true;
    });
    copyParts.hour = findClosestValue(hour, filteredHours);
    copyParts.ampm = parseAmPm(copyParts.hour);
  }
  if (minute !== undefined && minuteValues !== undefined) {
    // Filters out minutes that are out of the min/max bounds
    const filteredMinutes = minuteValues.filter(minute => {
      if ((minParts === null || minParts === void 0 ? void 0 : minParts.minute) !== undefined && isSameDay(copyParts, minParts) && copyParts.hour === minParts.hour && minute < minParts.minute) {
        return false;
      }
      if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.minute) !== undefined && isSameDay(copyParts, maxParts) && copyParts.hour === maxParts.hour && minute > maxParts.minute) {
        return false;
      }
      return true;
    });
    copyParts.minute = findClosestValue(minute, filteredMinutes);
  }
  return copyParts;
};
/**
 * Finds the value in "values" that is
 * numerically closest to "reference".
 * This function assumes that "values" is
 * already sorted in ascending order.
 * @param reference The reference number to use
 * when finding the closest value
 * @param values The allowed values that will be
 * searched to find the closest value to "reference"
 */
const findClosestValue = (reference, values) => {
  let closestValue = values[0];
  let rank = Math.abs(closestValue - reference);
  for (let i = 1; i < values.length; i++) {
    const value = values[i];
    /**
     * This code prioritizes the first
     * closest result. Given two values
     * with the same distance from reference,
     * this code will prioritize the smaller of
     * the two values.
     */
    const valueRank = Math.abs(value - reference);
    if (valueRank < rank) {
      closestValue = value;
      rank = valueRank;
    }
  }
  return closestValue;
};
const getFormattedDayPeriod = dayPeriod => {
  if (dayPeriod === undefined) {
    return '';
  }
  return dayPeriod.toUpperCase();
};
/**
 * Including time zone options may lead to the rendered text showing a
 * different time from what was selected in the Datetime, which could cause
 * confusion.
 */
const stripTimeZone = formatOptions => {
  return Object.assign(Object.assign({}, formatOptions), {
    /**
     * Setting the time zone to UTC ensures that the value shown is always the
     * same as what was selected and safeguards against older Safari bugs with
     * Intl.DateTimeFormat.
     */
    timeZone: 'UTC',
    /**
     * We do not want to display the time zone name
     */
    timeZoneName: undefined
  });
};
const getLocalizedTime = (locale, refParts, hourCycle, formatOptions = {
  hour: 'numeric',
  minute: 'numeric'
}) => {
  const timeParts = {
    hour: refParts.hour,
    minute: refParts.minute
  };
  if (timeParts.hour === undefined || timeParts.minute === undefined) {
    return 'Invalid Time';
  }
  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, stripTimeZone(formatOptions)), {
    /**
     * We use hourCycle here instead of hour12 due to:
     * https://bugs.chromium.org/p/chromium/issues/detail?id=1347316&q=hour12&can=2
     */
    hourCycle
  })).format(new Date(convertDataToISO(Object.assign({
    /**
     * JS uses a simplified ISO 8601 format which allows for
     * date-only formats and date-time formats, but not
     * time-only formats: https://tc39.es/ecma262/#sec-date-time-string-format
     * As a result, developers who only pass a time will get
     * an "Invalid Date" error. To account for this, we make sure that
     * year/day/month values are set when passing to new Date().
     * The Intl.DateTimeFormat call above only uses the hour/minute
     * values, so passing these date values should have no impact
     * on the time output.
     */
    year: 2023,
    day: 1,
    month: 1
  }, timeParts)) + 'Z'));
};
/**
 * Adds padding to a time value so
 * that it is always 2 digits.
 */
const addTimePadding = value => {
  const valueToString = value.toString();
  if (valueToString.length > 1) {
    return valueToString;
  }
  return `0${valueToString}`;
};
/**
 * Formats 24 hour times so that
 * it always has 2 digits. For
 * 12 hour times it ensures that
 * hour 0 is formatted as '12'.
 */
const getFormattedHour = (hour, hourCycle) => {
  /**
   * Midnight for h11 starts at 0:00am
   * Midnight for h12 starts at 12:00am
   * Midnight for h23 starts at 00:00
   * Midnight for h24 starts at 24:00
   */
  if (hour === 0) {
    switch (hourCycle) {
      case 'h11':
        return '0';
      case 'h12':
        return '12';
      case 'h23':
        return '00';
      case 'h24':
        return '24';
      default:
        throw new Error(`Invalid hour cycle "${hourCycle}"`);
    }
  }
  const use24Hour = is24Hour(hourCycle);
  /**
   * h23 and h24 use 24 hour times.
   */
  if (use24Hour) {
    return addTimePadding(hour);
  }
  return hour.toString();
};
/**
 * Generates an aria-label to be read by screen readers
 * given a local, a date, and whether or not that date is
 * today's date.
 */
const generateDayAriaLabel = (locale, today, refParts) => {
  if (refParts.day === null) {
    return null;
  }
  /**
   * MM/DD/YYYY will return midnight in the user's timezone.
   */
  const date = getNormalizedDate(refParts);
  const labelString = new Intl.DateTimeFormat(locale, {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
  /**
   * If date is today, prepend "Today" so screen readers indicate
   * that the date is today.
   */
  return today ? `Today, ${labelString}` : labelString;
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the month name and full year.
 * Example: May 2021
 */
const getMonthAndYear = (locale, refParts) => {
  const date = getNormalizedDate(refParts);
  return new Intl.DateTimeFormat(locale, {
    month: 'long',
    year: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric day.
 * Note: Some languages will add literal characters
 * to the end. This function removes those literals.
 * Example: 29
 */
const getDay = (locale, refParts) => {
  return getLocalizedDateTimeParts(locale, refParts, {
    day: 'numeric'
  }).find(obj => obj.type === 'day').value;
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric year.
 * Example: 2022
 */
const getYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    year: 'numeric'
  });
};
/**
 * Given reference parts, return a JS Date object
 * with a normalized time.
 */
const getNormalizedDate = refParts => {
  var _a, _b, _c;
  const timeString = refParts.hour !== undefined && refParts.minute !== undefined ? ` ${refParts.hour}:${refParts.minute}` : '';
  /**
   * We use / notation here for the date
   * so we do not need to do extra work and pad values with zeroes.
   * Values such as YYYY-MM are still valid, so
   * we add fallback values so we still get
   * a valid date otherwise we will pass in a string
   * like "//2023". Some browsers, such as Chrome, will
   * account for this and still return a valid date. However,
   * this is not a consistent behavior across all browsers.
   */
  return new Date(`${(_a = refParts.month) !== null && _a !== void 0 ? _a : 1}/${(_b = refParts.day) !== null && _b !== void 0 ? _b : 1}/${(_c = refParts.year) !== null && _c !== void 0 ? _c : 2023}${timeString} GMT+0000`);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns a string. If
 * you want an array of the individual pieces
 * that make up the localized date string, use
 * getLocalizedDateTimeParts.
 */
const getLocalizedDateTime = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, stripTimeZone(options)).format(date);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns an array of
 * each piece of the date.
 */
const getLocalizedDateTimeParts = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).formatToParts(date);
};
/**
 * Wrapper function for Intl.DateTimeFormat.
 * Allows developers to apply an allowed format to DatetimeParts.
 * This function also has built in safeguards for older browser bugs
 * with Intl.DateTimeFormat.
 */
const getDateTimeFormat = (locale, options) => {
  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), {
    timeZone: 'UTC'
  }));
};
/**
 * Gets a localized version of "Today"
 * Falls back to "Today" in English for
 * browsers that do not support RelativeTimeFormat.
 */
const getTodayLabel = locale => {
  if ('RelativeTimeFormat' in Intl) {
    const label = new Intl.RelativeTimeFormat(locale, {
      numeric: 'auto'
    }).format(0, 'day');
    return label.charAt(0).toUpperCase() + label.slice(1);
  } else {
    return 'Today';
  }
};
/**
 * When calling toISOString(), the browser
 * will convert the date to UTC time by either adding
 * or subtracting the time zone offset.
 * To work around this, we need to either add
 * or subtract the time zone offset to the Date
 * object prior to calling toISOString().
 * This allows us to get an ISO string
 * that is in the user's time zone.
 *
 * Example:
 * Time zone offset is 240
 * Meaning: The browser needs to add 240 minutes
 * to the Date object to get UTC time.
 * What Ionic does: We subtract 240 minutes
 * from the Date object. The browser then adds
 * 240 minutes in toISOString(). The result
 * is a time that is in the user's time zone
 * and not UTC.
 *
 * Note: Some timezones include minute adjustments
 * such as 30 or 45 minutes. This is why we use setMinutes
 * instead of setHours.
 * Example: India Standard Time
 * Timezone offset: -330 = -5.5 hours.
 *
 * List of timezones with 30 and 45 minute timezones:
 * https://www.timeanddate.com/time/time-zones-interesting.html
 */
const removeDateTzOffset = date => {
  const tzOffset = date.getTimezoneOffset();
  date.setMinutes(date.getMinutes() - tzOffset);
  return date;
};
const DATE_AM = removeDateTzOffset(new Date('2022T01:00'));
const DATE_PM = removeDateTzOffset(new Date('2022T13:00'));
/**
 * Formats the locale's string representation of the day period (am/pm) for a given
 * ref parts day period.
 *
 * @param locale The locale to format the day period in.
 * @param value The date string, in ISO format.
 * @returns The localized day period (am/pm) representation of the given value.
 */
const getLocalizedDayPeriod = (locale, dayPeriod) => {
  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;
  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    timeZone: 'UTC'
  }).formatToParts(date).find(part => part.type === 'dayPeriod');
  if (localizedDayPeriod) {
    return localizedDayPeriod.value;
  }
  return getFormattedDayPeriod(dayPeriod);
};
/**
 * Formats the datetime's value to a string, for use in the native input.
 *
 * @param value The value to format, either an ISO string or an array thereof.
 */
const formatValue = value => {
  return Array.isArray(value) ? value.join(',') : value;
};

/**
 * Returns the current date as
 * an ISO string in the user's
 * time zone.
 */
const getToday = () => {
  /**
   * ion-datetime intentionally does not
   * parse time zones/do automatic time zone
   * conversion when accepting user input.
   * However when we get today's date string,
   * we want it formatted relative to the user's
   * time zone.
   *
   * When calling toISOString(), the browser
   * will convert the date to UTC time by either adding
   * or subtracting the time zone offset.
   * To work around this, we need to either add
   * or subtract the time zone offset to the Date
   * object prior to calling toISOString().
   * This allows us to get an ISO string
   * that is in the user's time zone.
   */
  return removeDateTzOffset(new Date()).toISOString();
};
const minutes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59];
// h11 hour system uses 0-11. Midnight starts at 0:00am.
const hour11 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
// h12 hour system uses 0-12. Midnight starts at 12:00am.
const hour12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
// h23 hour system uses 0-23. Midnight starts at 0:00.
const hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
// h24 hour system uses 1-24. Midnight starts at 24:00.
const hour24 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 0];
/**
 * Given a locale and a mode,
 * return an array with formatted days
 * of the week. iOS should display days
 * such as "Mon" or "Tue".
 * MD should display days such as "M"
 * or "T".
 */
const getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {
  /**
   * Nov 1st, 2020 starts on a Sunday.
   * ion-datetime assumes weeks start on Sunday,
   * but is configurable via `firstDayOfWeek`.
   */
  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';
  const intl = new Intl.DateTimeFormat(locale, {
    weekday: weekdayFormat
  });
  const startDate = new Date('11/01/2020');
  const daysOfWeek = [];
  /**
   * For each day of the week,
   * get the day name.
   */
  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(currentDate.getDate() + i);
    daysOfWeek.push(intl.format(currentDate));
  }
  return daysOfWeek;
};
/**
 * Returns an array containing all of the
 * days in a month for a given year. Values are
 * aligned with a week calendar starting on
 * the firstDayOfWeek value (Sunday by default)
 * using null values.
 */
const getDaysOfMonth = (month, year, firstDayOfWeek, showAdjacentDays = false) => {
  const numDays = getNumDaysInMonth(month, year);
  let previousNumDays; //previous month number of days
  if (month === 1) {
    // If the current month is January, the previous month should be December of the previous year.
    previousNumDays = getNumDaysInMonth(12, year - 1);
  } else {
    // Otherwise, the previous month should be the current month - 1 of the same year.
    previousNumDays = getNumDaysInMonth(month - 1, year);
  }
  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();
  /**
   * To get the first day of the month aligned on the correct
   * day of the week, we need to determine how many "filler" days
   * to generate. These filler days as empty/disabled buttons
   * that fill the space of the days of the week before the first
   * of the month.
   *
   * There are two cases here:
   *
   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset
   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,
   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have
   * the first day of the month.
   *
   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset
   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,
   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have
   * the first day of the month.
   */
  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);
  let days = [];
  for (let i = 1; i <= numDays; i++) {
    days.push({
      day: i,
      dayOfWeek: (offset + i) % 7,
      isAdjacentDay: false
    });
  }
  if (showAdjacentDays) {
    for (let i = 0; i <= offset; i++) {
      // Using offset create previous month adjacent day, starting from last day
      days = [{
        day: previousNumDays - i,
        dayOfWeek: (previousNumDays - i) % 7,
        isAdjacentDay: true
      }, ...days];
    }
    // Calculate positiveOffset
    // The calendar will display 42 days (6 rows of 7 columns)
    // Knowing this the offset is 41 (we start at index 0)
    // minus (the previous offset + the current month days)
    const positiveOffset = 41 - (numDays + offset);
    for (let i = 0; i < positiveOffset; i++) {
      days.push({
        day: i + 1,
        dayOfWeek: (numDays + offset + i) % 7,
        isAdjacentDay: true
      });
    }
  } else {
    for (let i = 0; i <= offset; i++) {
      days = [{
        day: null,
        dayOfWeek: null,
        isAdjacentDay: false
      }, ...days];
    }
  }
  return days;
};
/**
 * Returns an array of pre-defined hour
 * values based on the provided hourCycle.
 */
const getHourData = hourCycle => {
  switch (hourCycle) {
    case 'h11':
      return hour11;
    case 'h12':
      return hour12;
    case 'h23':
      return hour23;
    case 'h24':
      return hour24;
    default:
      throw new Error(`Invalid hour cycle "${hourCycle}"`);
  }
};
/**
 * Given a local, reference datetime parts and option
 * max/min bound datetime parts, calculate the acceptable
 * hour and minute values according to the bounds and locale.
 */
const generateTime = (locale, refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {
  const computedHourCycle = getHourCycle(locale, hourCycle);
  const use24Hour = is24Hour(computedHourCycle);
  let processedHours = getHourData(computedHourCycle);
  let processedMinutes = minutes;
  let isAMAllowed = true;
  let isPMAllowed = true;
  if (hourValues) {
    processedHours = processedHours.filter(hour => hourValues.includes(hour));
  }
  if (minuteValues) {
    processedMinutes = processedMinutes.filter(minute => minuteValues.includes(minute));
  }
  if (minParts) {
    /**
     * If ref day is the same as the
     * minimum allowed day, filter hour/minute
     * values according to min hour and minute.
     */
    if (isSameDay(refParts, minParts)) {
      /**
       * Users may not always set the hour/minute for
       * min value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (minParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) >= minParts.hour;
        });
        isAMAllowed = minParts.hour < 13;
      }
      if (minParts.minute !== undefined) {
        /**
         * The minimum minute range should not be enforced when
         * the hour is greater than the min hour.
         *
         * For example with a minimum range of 09:30, users
         * should be able to select 10:00-10:29 and beyond.
         */
        let isPastMinHour = false;
        if (minParts.hour !== undefined && refParts.hour !== undefined) {
          if (refParts.hour > minParts.hour) {
            isPastMinHour = true;
          }
        }
        processedMinutes = processedMinutes.filter(minute => {
          if (isPastMinHour) {
            return true;
          }
          return minute >= minParts.minute;
        });
      }
      /**
       * If ref day is before minimum
       * day do not render any hours/minute values
       */
    } else if (isBefore(refParts, minParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }
  if (maxParts) {
    /**
     * If ref day is the same as the
     * maximum allowed day, filter hour/minute
     * values according to max hour and minute.
     */
    if (isSameDay(refParts, maxParts)) {
      /**
       * Users may not always set the hour/minute for
       * max value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (maxParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) <= maxParts.hour;
        });
        isPMAllowed = maxParts.hour >= 12;
      }
      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {
        // The available minutes should only be filtered when the hour is the same as the max hour.
        // For example if the max hour is 10:30 and the current hour is 10:00,
        // users should be able to select 00-30 minutes.
        // If the current hour is 09:00, users should be able to select 00-60 minutes.
        processedMinutes = processedMinutes.filter(minute => minute <= maxParts.minute);
      }
      /**
       * If ref day is after minimum
       * day do not render any hours/minute values
       */
    } else if (isAfter(refParts, maxParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }
  return {
    hours: processedHours,
    minutes: processedMinutes,
    am: isAMAllowed,
    pm: isPMAllowed
  };
};
/**
 * Given DatetimeParts, generate the previous,
 * current, and and next months.
 */
const generateMonths = (refParts, forcedDate) => {
  const current = {
    month: refParts.month,
    year: refParts.year,
    day: refParts.day
  };
  /**
   * If we're forcing a month to appear, and it's different from the current month,
   * ensure it appears by replacing the next or previous month as appropriate.
   */
  if (forcedDate !== undefined && (refParts.month !== forcedDate.month || refParts.year !== forcedDate.year)) {
    const forced = {
      month: forcedDate.month,
      year: forcedDate.year,
      day: forcedDate.day
    };
    const forcedMonthIsBefore = isBefore(forced, current);
    return forcedMonthIsBefore ? [forced, current, getNextMonth(refParts)] : [getPreviousMonth(refParts), current, forced];
  }
  return [getPreviousMonth(refParts), current, getNextMonth(refParts)];
};
const getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {
  month: 'long'
}) => {
  const {
    year
  } = refParts;
  const months = [];
  if (monthValues !== undefined) {
    let processedMonths = monthValues;
    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month <= maxParts.month);
    }
    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month >= minParts.month);
    }
    processedMonths.forEach(processedMonth => {
      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: processedMonth
      });
    });
  } else {
    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;
    const minMonth = minParts && minParts.year === year ? minParts.month : 1;
    for (let i = minMonth; i <= maxMonth; i++) {
      /**
       *
       * There is a bug on iOS 14 where
       * Intl.DateTimeFormat takes into account
       * the local timezone offset when formatting dates.
       *
       * Forcing the timezone to 'UTC' fixes the issue. However,
       * we should keep this workaround as it is safer. In the event
       * this breaks in another browser, we will not be impacted
       * because all dates will be interpreted in UTC.
       *
       * Example:
       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "March"
       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "April"
       *
       * In certain timezones, iOS 14 shows the wrong
       * date for .toUTCString(). To combat this, we
       * force all of the timezones to GMT+0000 (UTC).
       *
       * Example:
       * Time Zone: Central European Standard Time
       * new Date('1/1/1992').toUTCString() // "Tue, 31 Dec 1991 23:00:00 GMT"
       * new Date('1/1/1992 GMT+0000').toUTCString() // "Wed, 01 Jan 1992 00:00:00 GMT"
       */
      const date = new Date(`${i}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: i
      });
    }
  }
  return months;
};
/**
 * Returns information regarding
 * selectable dates (i.e 1st, 2nd, 3rd, etc)
 * within a reference month.
 * @param locale The locale to format the date with
 * @param refParts The reference month/year to generate dates for
 * @param minParts The minimum bound on the date that can be returned
 * @param maxParts The maximum bound on the date that can be returned
 * @param dayValues The allowed date values
 * @returns Date data to be used in ion-picker-column
 */
const getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {
  day: 'numeric'
}) => {
  const {
    month,
    year
  } = refParts;
  const days = [];
  /**
   * If we have max/min bounds that in the same
   * month/year as the refParts, we should
   * use the define day as the max/min day.
   * Otherwise, fallback to the max/min days in a month.
   */
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== null && (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== undefined && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;
  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== null && (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== undefined && minParts.year === year && minParts.month === month ? minParts.day : 1;
  if (dayValues !== undefined) {
    let processedDays = dayValues;
    processedDays = processedDays.filter(day => day >= minDay && day <= maxDay);
    processedDays.forEach(processedDay => {
      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: processedDay
      });
    });
  } else {
    for (let i = minDay; i <= maxDay; i++) {
      const date = new Date(`${month}/${i}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: i
      });
    }
  }
  return days;
};
const getYearColumnData = (locale, refParts, minParts, maxParts, yearValues) => {
  var _a, _b;
  let processedYears = [];
  if (yearValues !== undefined) {
    processedYears = yearValues;
    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year <= maxParts.year);
    }
    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year >= minParts.year);
    }
  } else {
    const {
      year
    } = refParts;
    const maxYear = (_a = maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== null && _a !== void 0 ? _a : year;
    const minYear = (_b = minParts === null || minParts === void 0 ? void 0 : minParts.year) !== null && _b !== void 0 ? _b : year - 100;
    for (let i = minYear; i <= maxYear; i++) {
      processedYears.push(i);
    }
  }
  return processedYears.map(year => ({
    text: getYear(locale, {
      year,
      month: refParts.month,
      day: refParts.day
    }),
    value: year
  }));
};
/**
 * Given a starting date and an upper bound,
 * this functions returns an array of all
 * month objects in that range.
 */
const getAllMonthsInRange = (currentParts, maxParts) => {
  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {
    return [currentParts];
  }
  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];
};
/**
 * Creates and returns picker items
 * that represent the days in a month.
 * Example: "Thu, Jun 2"
 */
const getCombinedDateColumnData = (locale, todayParts, minParts, maxParts, dayValues, monthValues) => {
  let items = [];
  let parts = [];
  /**
   * Get all month objects from the min date
   * to the max date. Note: Do not use getMonthColumnData
   * as that function only generates dates within a
   * single year.
   */
  let months = getAllMonthsInRange(minParts, maxParts);
  /**
   * Filter out any disallowed month values.
   */
  if (monthValues) {
    months = months.filter(({
      month
    }) => monthValues.includes(month));
  }
  /**
   * Get all of the days in the month.
   * From there, generate an array where
   * each item has the month, date, and day
   * of work as the text.
   */
  months.forEach(monthObject => {
    const referenceMonth = {
      month: monthObject.month,
      day: null,
      year: monthObject.year
    };
    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {
      month: 'short',
      day: 'numeric',
      weekday: 'short'
    });
    const dateParts = [];
    const dateColumnItems = [];
    monthDays.forEach(dayObject => {
      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), {
        day: dayObject.value
      }), todayParts);
      /**
       * Today's date should read as "Today" (localized)
       * not the actual date string
       */
      dateColumnItems.push({
        text: isToday ? getTodayLabel(locale) : dayObject.text,
        value: `${referenceMonth.year}-${referenceMonth.month}-${dayObject.value}`
      });
      /**
       * When selecting a date in the wheel picker
       * we need access to the raw datetime parts data.
       * The picker column only accepts values of
       * type string or number, so we need to return
       * two sets of data: A data set to be passed
       * to the picker column, and a data set to
       * be used to reference the raw data when
       * updating the picker column value.
       */
      dateParts.push({
        month: referenceMonth.month,
        year: referenceMonth.year,
        day: dayObject.value
      });
    });
    parts = [...parts, ...dateParts];
    items = [...items, ...dateColumnItems];
  });
  return {
    parts,
    items
  };
};
const getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteValues) => {
  const computedHourCycle = getHourCycle(locale, hourCycle);
  const use24Hour = is24Hour(computedHourCycle);
  const {
    hours,
    minutes,
    am,
    pm
  } = generateTime(locale, refParts, computedHourCycle, minParts, maxParts, allowedHourValues, allowedMinuteValues);
  const hoursItems = hours.map(hour => {
    return {
      text: getFormattedHour(hour, computedHourCycle),
      value: getInternalHourValue(hour, use24Hour, refParts.ampm)
    };
  });
  const minutesItems = minutes.map(minute => {
    return {
      text: addTimePadding(minute),
      value: minute
    };
  });
  const dayPeriodItems = [];
  if (am && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'am'),
      value: 'am'
    });
  }
  if (pm && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'pm'),
      value: 'pm'
    });
  }
  return {
    minutesData: minutesItems,
    hoursData: hoursItems,
    dayPeriodData: dayPeriodItems
  };
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV9kYXRhLUdJc0hzWUlCX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUMyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsU0FBUyxHQUFHQSxDQUFDQyxTQUFTLEVBQUVDLFlBQVksS0FBSztFQUMzQyxPQUFRRCxTQUFTLENBQUNFLEtBQUssS0FBS0QsWUFBWSxDQUFDQyxLQUFLLElBQUlGLFNBQVMsQ0FBQ0csR0FBRyxLQUFLRixZQUFZLENBQUNFLEdBQUcsSUFBSUgsU0FBUyxDQUFDSSxJQUFJLEtBQUtILFlBQVksQ0FBQ0csSUFBSTtBQUNoSSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsUUFBUSxHQUFHQSxDQUFDTCxTQUFTLEVBQUVDLFlBQVksS0FBSztFQUMxQyxPQUFPLENBQUMsRUFBRUQsU0FBUyxDQUFDSSxJQUFJLEdBQUdILFlBQVksQ0FBQ0csSUFBSSxJQUN2Q0osU0FBUyxDQUFDSSxJQUFJLEtBQUtILFlBQVksQ0FBQ0csSUFBSSxJQUFJSixTQUFTLENBQUNFLEtBQUssR0FBR0QsWUFBWSxDQUFDQyxLQUFNLElBQzdFRixTQUFTLENBQUNJLElBQUksS0FBS0gsWUFBWSxDQUFDRyxJQUFJLElBQ2pDSixTQUFTLENBQUNFLEtBQUssS0FBS0QsWUFBWSxDQUFDQyxLQUFLLElBQ3RDRixTQUFTLENBQUNHLEdBQUcsS0FBSyxJQUFJLElBQ3RCSCxTQUFTLENBQUNHLEdBQUcsR0FBR0YsWUFBWSxDQUFDRSxHQUFJLENBQUM7QUFDOUMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU1HLE9BQU8sR0FBR0EsQ0FBQ04sU0FBUyxFQUFFQyxZQUFZLEtBQUs7RUFDekMsT0FBTyxDQUFDLEVBQUVELFNBQVMsQ0FBQ0ksSUFBSSxHQUFHSCxZQUFZLENB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LE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO0FBQ3JEO0FBQ0EsTUFBTUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7QUFDckQ7QUFDQSxNQUFNQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztBQUNyRztBQUNBLE1BQU1DLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxhQUFhLEdBQUdBLENBQUMxSyxNQUFNLEVBQUUySyxJQUFJLEVBQUVDLGNBQWMsR0FBRyxDQUFDLEtBQUs7RUFDeEQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtFQUNJLE1BQU1DLGFBQWEsR0FBR0YsSUFBSSxLQUFLLEtBQUssR0FBRyxPQUFPLEdBQUcsUUFBUTtFQUN6RCxNQUFNRyxJQUFJLEdBQUcsSUFBSTNLLElBQUksQ0FBQ0MsY0FBYyxDQUFDSixNQUFNLEVBQUU7SUFBRXNJLE9BQU8sRUFBRXVDO0VBQWMsQ0FBQyxDQUFDO0VBQ3hFLE1BQU1FLFNBQVMsR0FBRyxJQUFJdEssSUFBSSxDQUFDLFlBQVksQ0FBQztFQUN4QyxNQUFNdUssVUFBVSxHQUFHLEVBQUU7RUFDckI7QUFDSjtBQUNBO0FBQ0E7RUFDSSxLQUFLLElBQUlsSSxDQUFDLEdBQUc4SCxjQUFjLEVBQUU5SCxDQUFDLEdBQUc4SCxjQUFjLEdBQUcsQ0FBQyxFQUFFOUgsQ0FBQyxFQUFFLEVBQUU7SUFDdEQsTUFBTW1JLFdBQVcsR0FBRyxJQUFJeEssSUFBSSxDQUFDc0ssU0FBUyxDQUFDO0lBQ3ZDRSxXQUFXLENBQUNDLE9BQU8sQ0FBQ0QsV0FBVyxDQUFDRSxPQUFPLENBQUMsQ0FBQyxHQUFHckksQ0FBQyxDQUFDO0lBQzlDa0ksVUFBVSxDQUFDdEksSUFBSSxDQUFDb0ksSUFBSSxDQUFDakQsTUFBTSxDQUFDb0QsV0FBVyxDQUFDLENBQUM7RUFDN0M7RUFDQSxPQUFPRCxVQUFVO0FBQ3JCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1JLGNBQWMsR0FBR0EsQ0FBQ3RNLEtBQUssRUFBRUUsSUFBSSxFQUFFNEwsY0FBYyxFQUFFUyxnQkFBZ0IsR0FBRyxLQUFLLEtBQUs7RUFDOUUsTUFBTXZHLE9BQU8sR0FBRzdELGlCQUFpQixDQUFDbkMsS0FBSyxFQUFFRSxJQUFJLENBQUM7RUFDOUMsSUFBSXNNLGVBQWUsQ0FBQyxDQUFDO0VBQ3JCLElBQUl4TSxLQUFLLEtBQUssQ0FBQyxFQUFFO0lBQ2I7SUFDQXdNLGVBQWUsR0FBR3JLLGlCQUFpQixDQUFDLEVBQUUsRUFBRWpDLElBQUksR0FBRyxDQUFDLENBQUM7RUFDckQsQ0FBQyxNQUNJO0lBQ0Q7SUFDQXNNLGVBQWUsR0FBR3JLLGlCQUFpQixDQUFDbkMsS0FBSyxHQUFHLENBQUMsRUFBRUUsSUFBSSxDQUFDO0VBQ3hEO0VBQ0EsTUFBTXVNLFlBQVksR0FBRyxJQUFJOUssSUFBSSxDQUFDLEdBQUczQixLQUFLLE1BQU1FLElBQUksRUFBRSxDQUFDLENBQUN3SixNQUFNLENBQUMsQ0FBQztFQUM1RDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLE1BQU1nRCxNQUFNLEdBQUdELFlBQVksSUFBSVgsY0FBYyxHQUFHVyxZQUFZLElBQUlYLGNBQWMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUlBLGNBQWMsR0FBR1csWUFBWSxDQUFDO0VBQ3pILElBQUlFLElBQUksR0FBRyxFQUFFO0VBQ2IsS0FBSyxJQUFJM0ksQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxJQUFJZ0MsT0FBTyxFQUFFaEMsQ0FBQyxFQUFFLEVBQUU7SUFDL0IySSxJQUFJLENBQUMvSSxJQUFJLENBQUM7TUFBRTNELEdBQUcsRUFBRStELENBQUM7TUFBRVQsU0FBUyxFQUFFLENBQUNtSixNQUFNLEdBQUcxSSxDQUFDLElBQUksQ0FBQztNQUFFNEksYUFBYSxFQUFFO0lBQU0sQ0FBQyxDQUFDO0VBQzVFO0VBQ0EsSUFBSUwsZ0JBQWdCLEVBQUU7SUFDbEIsS0FBSyxJQUFJdkksQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxJQUFJMEksTUFBTSxFQUFFMUksQ0FBQyxFQUFFLEVBQUU7TUFDOUI7TUFDQTJJLElBQUksR0FBRyxDQUFDO1FBQUUxTSxHQUFHLEVBQUV1TSxlQUFlLEdBQUd4SSxDQUFDO1FBQUVULFNBQVMsRUFBRSxDQUFDaUosZUFBZSxHQUFHeEksQ0FBQyxJQUFJLENBQUM7UUFBRTRJLGFBQWEsRUFBRTtNQUFLLENBQUMsRUFBRSxHQUFHRCxJQUFJLENBQUM7SUFDN0c7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU1FLGNBQWMsR0FBRyxFQUFFLElBQUk3RyxPQUFPLEdBQUcwRyxNQUFNLENBQUM7SUFDOUMsS0FBSyxJQUFJMUksQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHNkksY0FBYyxFQUFFN0ksQ0FBQyxFQUFFLEVBQUU7TUFDckMySSxJQUFJLENBQUMvSSxJQUFJLENBQUM7UUFBRTNELEdBQUcsRUFBRStELENBQUMsR0FBRyxDQUFDO1FBQUVULFNBQVMsRUFBRSxDQUFDeUMsT0FBTyxHQUFHMEcsTUFBTSxHQUFHMUksQ0FBQyxJQUFJLENBQUM7UUFBRTRJLGFBQWEsRUFBRTtNQUFLLENBQUMsQ0FBQztJQUN6RjtFQUNKLENBQUMsTUFDSTtJQUNELEtBQUssSUFBSTVJLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsSUFBSTBJLE1BQU0sRUFBRTFJLENBQUMsRUFBRSxFQUFFO01BQzlCMkksSUFBSSxHQUFHLENBQUM7UUFBRTFNLEdBQUcsRUFBRSxJQUFJO1FBQUVzRCxTQUFTLEVBQUUsSUFBSTtRQUFFcUosYUFBYSxFQUFFO01BQU0sQ0FBQyxFQUFFLEdBQUdELElBQUksQ0FBQztJQUMxRTtFQUNKO0VBQ0EsT0FBT0EsSUFBSTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1HLFdBQVcsR0FBSTNMLFNBQVMsSUFBSztFQUMvQixRQUFRQSxTQUFTO0lBQ2IsS0FBSyxLQUFLO01BQ04sT0FBT3FLLE1BQU07SUFDakIsS0FBSyxLQUFLO01BQ04sT0FBT0MsTUFBTTtJQUNqQixLQUFLLEtBQUs7TUFDTixPQUFPQyxNQUFNO0lBQ2pCLEtBQUssS0FBSztNQUNOLE9BQU9DLE1BQU07SUFDakI7TUFDSSxNQUFNLElBQUkxSixLQUFLLENBQUMsdUJBQXVCZCxTQUFTLEdBQUcsQ0FBQztFQUM1RDtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTRMLFlBQVksR0FBR0EsQ0FBQzdMLE1BQU0sRUFBRXNFLFFBQVEsRUFBRXJFLFNBQVMsR0FBRyxLQUFLLEVBQUVrRCxRQUFRLEVBQUVDLFFBQVEsRUFBRW1ELFVBQVUsRUFBRUMsWUFBWSxLQUFLO0VBQ3hHLE1BQU1zRixpQkFBaUIsR0FBRy9MLFlBQVksQ0FBQ0MsTUFBTSxFQUFFQyxTQUFTLENBQUM7RUFDekQsTUFBTXdGLFNBQVMsR0FBR3pFLFFBQVEsQ0FBQzhLLGlCQUFpQixDQUFDO0VBQzdDLElBQUlDLGNBQWMsR0FBR0gsV0FBVyxDQUFDRSxpQkFBaUIsQ0FBQztFQUNuRCxJQUFJRSxnQkFBZ0IsR0FBRzNCLE9BQU87RUFDOUIsSUFBSTRCLFdBQVcsR0FBRyxJQUFJO0VBQ3RCLElBQUlDLFdBQVcsR0FBRyxJQUFJO0VBQ3RCLElBQUkzRixVQUFVLEVBQUU7SUFDWndGLGNBQWMsR0FBR0EsY0FBYyxDQUFDL0osTUFBTSxDQUFFM0IsSUFBSSxJQUFLa0csVUFBVSxDQUFDNEYsUUFBUSxDQUFDOUwsSUFBSSxDQUFDLENBQUM7RUFDL0U7RUFDQSxJQUFJbUcsWUFBWSxFQUFFO0lBQ2R3RixnQkFBZ0IsR0FBR0EsZ0JBQWdCLENBQUNoSyxNQUFNLENBQUVlLE1BQU0sSUFBS3lELFlBQVksQ0FBQzJGLFFBQVEsQ0FBQ3BKLE1BQU0sQ0FBQyxDQUFDO0VBQ3pGO0VBQ0EsSUFBSUksUUFBUSxFQUFFO0lBQ1Y7QUFDUjtBQUNBO0FBQ0E7QUFDQTtJQUNRLElBQUl4RSxTQUFTLENBQUMyRixRQUFRLEVBQUVuQixRQUFRLENBQUMsRUFBRTtNQUMvQjtBQUNaO0FBQ0E7QUFDQTtBQUNBO01BQ1ksSUFBSUEsUUFBUSxDQUFDOUMsSUFBSSxLQUFLVixTQUFTLEVBQUU7UUFDN0JvTSxjQUFjLEdBQUdBLGNBQWMsQ0FBQy9KLE1BQU0sQ0FBRTNCLElBQUksSUFBSztVQUM3QyxNQUFNK0wsYUFBYSxHQUFHOUgsUUFBUSxDQUFDdEIsSUFBSSxLQUFLLElBQUksR0FBRyxDQUFDM0MsSUFBSSxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUdBLElBQUk7VUFDdEUsT0FBTyxDQUFDb0YsU0FBUyxHQUFHcEYsSUFBSSxHQUFHK0wsYUFBYSxLQUFLakosUUFBUSxDQUFDOUMsSUFBSTtRQUM5RCxDQUFDLENBQUM7UUFDRjRMLFdBQVcsR0FBRzlJLFFBQVEsQ0FBQzlDLElBQUksR0FBRyxFQUFFO01BQ3BDO01BQ0EsSUFBSThDLFFBQVEsQ0FBQ0osTUFBTSxLQUFLcEQsU0FBUyxFQUFFO1FBQy9CO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtRQUNnQixJQUFJME0sYUFBYSxHQUFHLEtBQUs7UUFDekIsSUFBSWxKLFFBQVEsQ0FBQzlDLElBQUksS0FBS1YsU0FBUyxJQUFJMkUsUUFBUSxDQUFDakUsSUFBSSxLQUFLVixTQUFTLEVBQUU7VUFDNUQsSUFBSTJFLFFBQVEsQ0FBQ2pFLElBQUksR0FBRzhDLFFBQVEsQ0FBQzlDLElBQUksRUFBRTtZQUMvQmdNLGFBQWEsR0FBRyxJQUFJO1VBQ3hCO1FBQ0o7UUFDQUwsZ0JBQWdCLEdBQUdBLGdCQUFnQixDQUFDaEssTUFBTSxDQUFFZSxNQUFNLElBQUs7VUFDbkQsSUFBSXNKLGFBQWEsRUFBRTtZQUNmLE9BQU8sSUFBSTtVQUNmO1VBQ0EsT0FBT3RKLE1BQU0sSUFBSUksUUFBUSxDQUFDSixNQUFNO1FBQ3BDLENBQUMsQ0FBQztNQUNOO01BQ0E7QUFDWjtBQUNBO0FBQ0E7SUFDUSxDQUFDLE1BQ0ksSUFBSTlELFFBQVEsQ0FBQ3FGLFFBQVEsRUFBRW5CLFFBQVEsQ0FBQyxFQUFFO01BQ25DNEksY0FBYyxHQUFHLEVBQUU7TUFDbkJDLGdCQUFnQixHQUFHLEVBQUU7TUFDckJDLFdBQVcsR0FBR0MsV0FBVyxHQUFHLEtBQUs7SUFDckM7RUFDSjtFQUNBLElBQUk5SSxRQUFRLEVBQUU7SUFDVjtBQUNSO0FBQ0E7QUFDQTtBQUNBO0lBQ1EsSUFBSXpFLFNBQVMsQ0FBQzJGLFFBQVEsRUFBRWxCLFFBQVEsQ0FBQyxFQUFFO01BQy9CO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7TUFDWSxJQUFJQSxRQUFRLENBQUMvQyxJQUFJLEtBQUtWLFNBQVMsRUFBRTtRQUM3Qm9NLGNBQWMsR0FBR0EsY0FBYyxDQUFDL0osTUFBTSxDQUFFM0IsSUFBSSxJQUFLO1VBQzdDLE1BQU0rTCxhQUFhLEdBQUc5SCxRQUFRLENBQUN0QixJQUFJLEtBQUssSUFBSSxHQUFHLENBQUMzQyxJQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBR0EsSUFBSTtVQUN0RSxPQUFPLENBQUNvRixTQUFTLEdBQUdwRixJQUFJLEdBQUcrTCxhQUFhLEtBQUtoSixRQUFRLENBQUMvQyxJQUFJO1FBQzlELENBQUMsQ0FBQztRQUNGNkwsV0FBVyxHQUFHOUksUUFBUSxDQUFDL0MsSUFBSSxJQUFJLEVBQUU7TUFDckM7TUFDQSxJQUFJK0MsUUFBUSxDQUFDTCxNQUFNLEtBQUtwRCxTQUFTLElBQUkyRSxRQUFRLENBQUNqRSxJQUFJLEtBQUsrQyxRQUFRLENBQUMvQyxJQUFJLEVBQUU7UUFDbEU7UUFDQTtRQUNBO1FBQ0E7UUFDQTJMLGdCQUFnQixHQUFHQSxnQkFBZ0IsQ0FBQ2hLLE1BQU0sQ0FBRWUsTUFBTSxJQUFLQSxNQUFNLElBQUlLLFFBQVEsQ0FBQ0wsTUFBTSxDQUFDO01BQ3JGO01BQ0E7QUFDWjtBQUNBO0FBQ0E7SUFDUSxDQUFDLE1BQ0ksSUFBSTdELE9BQU8sQ0FBQ29GLFFBQVEsRUFBRWxCLFFBQVEsQ0FBQyxFQUFFO01BQ2xDMkksY0FBYyxHQUFHLEVBQUU7TUFDbkJDLGdCQUFnQixHQUFHLEVBQUU7TUFDckJDLFdBQVcsR0FBR0MsV0FBVyxHQUFHLEtBQUs7SUFDckM7RUFDSjtFQUNBLE9BQU87SUFDSEksS0FBSyxFQUFFUCxjQUFjO0lBQ3JCMUIsT0FBTyxFQUFFMkIsZ0JBQWdCO0lBQ3pCTyxFQUFFLEVBQUVOLFdBQVc7SUFDZk8sRUFBRSxFQUFFTjtFQUNSLENBQUM7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNTyxjQUFjLEdBQUdBLENBQUNuSSxRQUFRLEVBQUVvSSxVQUFVLEtBQUs7RUFDN0MsTUFBTUMsT0FBTyxHQUFHO0lBQUU3TixLQUFLLEVBQUV3RixRQUFRLENBQUN4RixLQUFLO0lBQUVFLElBQUksRUFBRXNGLFFBQVEsQ0FBQ3RGLElBQUk7SUFBRUQsR0FBRyxFQUFFdUYsUUFBUSxDQUFDdkY7RUFBSSxDQUFDO0VBQ2pGO0FBQ0o7QUFDQTtBQUNBO0VBQ0ksSUFBSTJOLFVBQVUsS0FBSy9NLFNBQVMsS0FBSzJFLFFBQVEsQ0FBQ3hGLEtBQUssS0FBSzROLFVBQVUsQ0FBQzVOLEtBQUssSUFBSXdGLFFBQVEsQ0FBQ3RGLElBQUksS0FBSzBOLFVBQVUsQ0FBQzFOLElBQUksQ0FBQyxFQUFFO0lBQ3hHLE1BQU00TixNQUFNLEdBQUc7TUFBRTlOLEtBQUssRUFBRTROLFVBQVUsQ0FBQzVOLEtBQUs7TUFBRUUsSUFBSSxFQUFFME4sVUFBVSxDQUFDMU4sSUFBSTtNQUFFRCxHQUFHLEVBQUUyTixVQUFVLENBQUMzTjtJQUFJLENBQUM7SUFDdEYsTUFBTThOLG1CQUFtQixHQUFHNU4sUUFBUSxDQUFDMk4sTUFBTSxFQUFFRCxPQUFPLENBQUM7SUFDckQsT0FBT0UsbUJBQW1CLEdBQ3BCLENBQUNELE1BQU0sRUFBRUQsT0FBTyxFQUFFeEgsWUFBWSxDQUFDYixRQUFRLENBQUMsQ0FBQyxHQUN6QyxDQUFDVyxnQkFBZ0IsQ0FBQ1gsUUFBUSxDQUFDLEVBQUVxSSxPQUFPLEVBQUVDLE1BQU0sQ0FBQztFQUN2RDtFQUNBLE9BQU8sQ0FBQzNILGdCQUFnQixDQUFDWCxRQUFRLENBQUMsRUFBRXFJLE9BQU8sRUFBRXhILFlBQVksQ0FBQ2IsUUFBUSxDQUFDLENBQUM7QUFDeEUsQ0FBQztBQUNELE1BQU13SSxrQkFBa0IsR0FBR0EsQ0FBQzlNLE1BQU0sRUFBRXNFLFFBQVEsRUFBRW5CLFFBQVEsRUFBRUMsUUFBUSxFQUFFZ0QsV0FBVyxFQUFFakYsYUFBYSxHQUFHO0VBQzNGckMsS0FBSyxFQUFFO0FBQ1gsQ0FBQyxLQUFLO0VBQ0YsTUFBTTtJQUFFRTtFQUFLLENBQUMsR0FBR3NGLFFBQVE7RUFDekIsTUFBTXlJLE1BQU0sR0FBRyxFQUFFO0VBQ2pCLElBQUkzRyxXQUFXLEtBQUt6RyxTQUFTLEVBQUU7SUFDM0IsSUFBSXFOLGVBQWUsR0FBRzVHLFdBQVc7SUFDakMsSUFBSSxDQUFDaEQsUUFBUSxLQUFLLElBQUksSUFBSUEsUUFBUSxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHQSxRQUFRLENBQUN0RSxLQUFLLE1BQU1hLFNBQVMsRUFBRTtNQUNwRnFOLGVBQWUsR0FBR0EsZUFBZSxDQUFDaEwsTUFBTSxDQUFFbEQsS0FBSyxJQUFLQSxLQUFLLElBQUlzRSxRQUFRLENBQUN0RSxLQUFLLENBQUM7SUFDaEY7SUFDQSxJQUFJLENBQUNxRSxRQUFRLEtBQUssSUFBSSxJQUFJQSxRQUFRLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLFFBQVEsQ0FBQ3JFLEtBQUssTUFBTWEsU0FBUyxFQUFFO01BQ3BGcU4sZUFBZSxHQUFHQSxlQUFlLENBQUNoTCxNQUFNLENBQUVsRCxLQUFLLElBQUtBLEtBQUssSUFBSXFFLFFBQVEsQ0FBQ3JFLEtBQUssQ0FBQztJQUNoRjtJQUNBa08sZUFBZSxDQUFDQyxPQUFPLENBQUVDLGNBQWMsSUFBSztNQUN4QyxNQUFNMU0sSUFBSSxHQUFHLElBQUlDLElBQUksQ0FBQyxHQUFHeU0sY0FBYyxNQUFNbE8sSUFBSSxXQUFXLENBQUM7TUFDN0QsTUFBTW1PLFdBQVcsR0FBRyxJQUFJaE4sSUFBSSxDQUFDQyxjQUFjLENBQUNKLE1BQU0sRUFBRWlHLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRS9FLGFBQWEsQ0FBQyxFQUFFO1FBQUVzRyxRQUFRLEVBQUU7TUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDSSxNQUFNLENBQUNySCxJQUFJLENBQUM7TUFDdEl1TSxNQUFNLENBQUNySyxJQUFJLENBQUM7UUFBRTBLLElBQUksRUFBRUQsV0FBVztRQUFFL04sS0FBSyxFQUFFOE47TUFBZSxDQUFDLENBQUM7SUFDN0QsQ0FBQyxDQUFDO0VBQ04sQ0FBQyxNQUNJO0lBQ0QsTUFBTUcsUUFBUSxHQUFHakssUUFBUSxJQUFJQSxRQUFRLENBQUNwRSxJQUFJLEtBQUtBLElBQUksR0FBR29FLFFBQVEsQ0FBQ3RFLEtBQUssR0FBRyxFQUFFO0lBQ3pFLE1BQU13TyxRQUFRLEdBQUduSyxRQUFRLElBQUlBLFFBQVEsQ0FBQ25FLElBQUksS0FBS0EsSUFBSSxHQUFHbUUsUUFBUSxDQUFDckUsS0FBSyxHQUFHLENBQUM7SUFDeEUsS0FBSyxJQUFJZ0UsQ0FBQyxHQUFHd0ssUUFBUSxFQUFFeEssQ0FBQyxJQUFJdUssUUFBUSxFQUFFdkssQ0FBQyxFQUFFLEVBQUU7TUFDdkM7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO01BQ1ksTUFBTXRDLElBQUksR0FBRyxJQUFJQyxJQUFJLENBQUMsR0FBR3FDLENBQUMsTUFBTTlELElBQUksV0FBVyxDQUFDO01BQ2hELE1BQU1tTyxXQUFXLEdBQUcsSUFBSWhOLElBQUksQ0FBQ0MsY0FBYyxDQUFDSixNQUFNLEVBQUVpRyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUvRSxhQUFhLENBQUMsRUFBRTtRQUFFc0csUUFBUSxFQUFFO01BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQ0ksTUFBTSxDQUFDckgsSUFBSSxDQUFDO01BQ3RJdU0sTUFBTSxDQUFDckssSUFBSSxDQUFDO1FBQUUwSyxJQUFJLEVBQUVELFdBQVc7UUFBRS9OLEtBQUssRUFBRTBEO01BQUUsQ0FBQyxDQUFDO0lBQ2hEO0VBQ0o7RUFDQSxPQUFPaUssTUFBTTtBQUNqQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1RLGdCQUFnQixHQUFHQSxDQUFDdk4sTUFBTSxFQUFFc0UsUUFBUSxFQUFFbkIsUUFBUSxFQUFFQyxRQUFRLEVBQUVpRCxTQUFTLEVBQUVsRixhQUFhLEdBQUc7RUFDdkZwQyxHQUFHLEVBQUU7QUFDVCxDQUFDLEtBQUs7RUFDRixNQUFNO0lBQUVELEtBQUs7SUFBRUU7RUFBSyxDQUFDLEdBQUdzRixRQUFRO0VBQ2hDLE1BQU1tSCxJQUFJLEdBQUcsRUFBRTtFQUNmO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLE1BQU12RyxjQUFjLEdBQUdqRSxpQkFBaUIsQ0FBQ25DLEtBQUssRUFBRUUsSUFBSSxDQUFDO0VBQ3JELE1BQU13TyxNQUFNLEdBQUcsQ0FBQ3BLLFFBQVEsS0FBSyxJQUFJLElBQUlBLFFBQVEsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBR0EsUUFBUSxDQUFDckUsR0FBRyxNQUFNLElBQUksSUFBSSxDQUFDcUUsUUFBUSxLQUFLLElBQUksSUFBSUEsUUFBUSxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHQSxRQUFRLENBQUNyRSxHQUFHLE1BQU1ZLFNBQVMsSUFBSXlELFFBQVEsQ0FBQ3BFLElBQUksS0FBS0EsSUFBSSxJQUFJb0UsUUFBUSxDQUFDdEUsS0FBSyxLQUFLQSxLQUFLLEdBQzlOc0UsUUFBUSxDQUFDckUsR0FBRyxHQUNabUcsY0FBYztFQUNwQixNQUFNdUksTUFBTSxHQUFHLENBQUN0SyxRQUFRLEtBQUssSUFBSSxJQUFJQSxRQUFRLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLFFBQVEsQ0FBQ3BFLEdBQUcsTUFBTSxJQUFJLElBQUksQ0FBQ29FLFFBQVEsS0FBSyxJQUFJLElBQUlBLFFBQVEsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBR0EsUUFBUSxDQUFDcEUsR0FBRyxNQUFNWSxTQUFTLElBQUl3RCxRQUFRLENBQUNuRSxJQUFJLEtBQUtBLElBQUksSUFBSW1FLFFBQVEsQ0FBQ3JFLEtBQUssS0FBS0EsS0FBSyxHQUM5TnFFLFFBQVEsQ0FBQ3BFLEdBQUcsR0FDWixDQUFDO0VBQ1AsSUFBSXNILFNBQVMsS0FBSzFHLFNBQVMsRUFBRTtJQUN6QixJQUFJK04sYUFBYSxHQUFHckgsU0FBUztJQUM3QnFILGFBQWEsR0FBR0EsYUFBYSxDQUFDMUwsTUFBTSxDQUFFakQsR0FBRyxJQUFLQSxHQUFHLElBQUkwTyxNQUFNLElBQUkxTyxHQUFHLElBQUl5TyxNQUFNLENBQUM7SUFDN0VFLGFBQWEsQ0FBQ1QsT0FBTyxDQUFFVSxZQUFZLElBQUs7TUFDcEMsTUFBTW5OLElBQUksR0FBRyxJQUFJQyxJQUFJLENBQUMsR0FBRzNCLEtBQUssSUFBSTZPLFlBQVksSUFBSTNPLElBQUksV0FBVyxDQUFDO01BQ2xFLE1BQU00TyxTQUFTLEdBQUcsSUFBSXpOLElBQUksQ0FBQ0MsY0FBYyxDQUFDSixNQUFNLEVBQUVpRyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUvRSxhQUFhLENBQUMsRUFBRTtRQUFFc0csUUFBUSxFQUFFO01BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQ0ksTUFBTSxDQUFDckgsSUFBSSxDQUFDO01BQ3BJaUwsSUFBSSxDQUFDL0ksSUFBSSxDQUFDO1FBQUUwSyxJQUFJLEVBQUVRLFNBQVM7UUFBRXhPLEtBQUssRUFBRXVPO01BQWEsQ0FBQyxDQUFDO0lBQ3ZELENBQUMsQ0FBQztFQUNOLENBQUMsTUFDSTtJQUNELEtBQUssSUFBSTdLLENBQUMsR0FBRzJLLE1BQU0sRUFBRTNLLENBQUMsSUFBSTBLLE1BQU0sRUFBRTFLLENBQUMsRUFBRSxFQUFFO01BQ25DLE1BQU10QyxJQUFJLEdBQUcsSUFBSUMsSUFBSSxDQUFDLEdBQUczQixLQUFLLElBQUlnRSxDQUFDLElBQUk5RCxJQUFJLFdBQVcsQ0FBQztNQUN2RCxNQUFNNE8sU0FBUyxHQUFHLElBQUl6TixJQUFJLENBQUNDLGNBQWMsQ0FBQ0osTUFBTSxFQUFFaUcsTUFBTSxDQUFDQyxNQUFNLENBQUNELE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFL0UsYUFBYSxDQUFDLEVBQUU7UUFBRXNHLFFBQVEsRUFBRTtNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUNJLE1BQU0sQ0FBQ3JILElBQUksQ0FBQztNQUNwSWlMLElBQUksQ0FBQy9JLElBQUksQ0FBQztRQUFFMEssSUFBSSxFQUFFUSxTQUFTO1FBQUV4TyxLQUFLLEVBQUUwRDtNQUFFLENBQUMsQ0FBQztJQUM1QztFQUNKO0VBQ0EsT0FBTzJJLElBQUk7QUFDZixDQUFDO0FBQ0QsTUFBTW9DLGlCQUFpQixHQUFHQSxDQUFDN04sTUFBTSxFQUFFc0UsUUFBUSxFQUFFbkIsUUFBUSxFQUFFQyxRQUFRLEVBQUVrRCxVQUFVLEtBQUs7RUFDNUUsSUFBSXVDLEVBQUUsRUFBRUMsRUFBRTtFQUNWLElBQUlnRixjQUFjLEdBQUcsRUFBRTtFQUN2QixJQUFJeEgsVUFBVSxLQUFLM0csU0FBUyxFQUFFO0lBQzFCbU8sY0FBYyxHQUFHeEgsVUFBVTtJQUMzQixJQUFJLENBQUNsRCxRQUFRLEtBQUssSUFBSSxJQUFJQSxRQUFRLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLFFBQVEsQ0FBQ3BFLElBQUksTUFBTVcsU0FBUyxFQUFFO01BQ25GbU8sY0FBYyxHQUFHQSxjQUFjLENBQUM5TCxNQUFNLENBQUVoRCxJQUFJLElBQUtBLElBQUksSUFBSW9FLFFBQVEsQ0FBQ3BFLElBQUksQ0FBQztJQUMzRTtJQUNBLElBQUksQ0FBQ21FLFFBQVEsS0FBSyxJQUFJLElBQUlBLFFBQVEsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBR0EsUUFBUSxDQUFDbkUsSUFBSSxNQUFNVyxTQUFTLEVBQUU7TUFDbkZtTyxjQUFjLEdBQUdBLGNBQWMsQ0FBQzlMLE1BQU0sQ0FBRWhELElBQUksSUFBS0EsSUFBSSxJQUFJbUUsUUFBUSxDQUFDbkUsSUFBSSxDQUFDO0lBQzNFO0VBQ0osQ0FBQyxNQUNJO0lBQ0QsTUFBTTtNQUFFQTtJQUFLLENBQUMsR0FBR3NGLFFBQVE7SUFDekIsTUFBTXlKLE9BQU8sR0FBRyxDQUFDbEYsRUFBRSxHQUFHekYsUUFBUSxLQUFLLElBQUksSUFBSUEsUUFBUSxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHQSxRQUFRLENBQUNwRSxJQUFJLE1BQU0sSUFBSSxJQUFJNkosRUFBRSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxFQUFFLEdBQUc3SixJQUFJO0lBQzlILE1BQU1nUCxPQUFPLEdBQUcsQ0FBQ2xGLEVBQUUsR0FBRzNGLFFBQVEsS0FBSyxJQUFJLElBQUlBLFFBQVEsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBR0EsUUFBUSxDQUFDbkUsSUFBSSxNQUFNLElBQUksSUFBSThKLEVBQUUsS0FBSyxLQUFLLENBQUMsR0FBR0EsRUFBRSxHQUFHOUosSUFBSSxHQUFHLEdBQUc7SUFDcEksS0FBSyxJQUFJOEQsQ0FBQyxHQUFHa0wsT0FBTyxFQUFFbEwsQ0FBQyxJQUFJaUwsT0FBTyxFQUFFakwsQ0FBQyxFQUFFLEVBQUU7TUFDckNnTCxjQUFjLENBQUNwTCxJQUFJLENBQUNJLENBQUMsQ0FBQztJQUMxQjtFQUNKO0VBQ0EsT0FBT2dMLGNBQWMsQ0FBQ2pNLEdBQUcsQ0FBRTdDLElBQUksS0FBTTtJQUNqQ29PLElBQUksRUFBRXpFLE9BQU8sQ0FBQzNJLE1BQU0sRUFBRTtNQUFFaEIsSUFBSTtNQUFFRixLQUFLLEVBQUV3RixRQUFRLENBQUN4RixLQUFLO01BQUVDLEdBQUcsRUFBRXVGLFFBQVEsQ0FBQ3ZGO0lBQUksQ0FBQyxDQUFDO0lBQ3pFSyxLQUFLLEVBQUVKO0VBQ1gsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1pUCxtQkFBbUIsR0FBR0EsQ0FBQ3RJLFlBQVksRUFBRXZDLFFBQVEsS0FBSztFQUNwRCxJQUFJdUMsWUFBWSxDQUFDN0csS0FBSyxLQUFLc0UsUUFBUSxDQUFDdEUsS0FBSyxJQUFJNkcsWUFBWSxDQUFDM0csSUFBSSxLQUFLb0UsUUFBUSxDQUFDcEUsSUFBSSxFQUFFO0lBQzlFLE9BQU8sQ0FBQzJHLFlBQVksQ0FBQztFQUN6QjtFQUNBLE9BQU8sQ0FBQ0EsWUFBWSxFQUFFLEdBQUdzSSxtQkFBbUIsQ0FBQzlJLFlBQVksQ0FBQ1EsWUFBWSxDQUFDLEVBQUV2QyxRQUFRLENBQUMsQ0FBQztBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU04Syx5QkFBeUIsR0FBR0EsQ0FBQ2xPLE1BQU0sRUFBRXVELFVBQVUsRUFBRUosUUFBUSxFQUFFQyxRQUFRLEVBQUVpRCxTQUFTLEVBQUVELFdBQVcsS0FBSztFQUNsRyxJQUFJK0gsS0FBSyxHQUFHLEVBQUU7RUFDZCxJQUFJek4sS0FBSyxHQUFHLEVBQUU7RUFDZDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJcU0sTUFBTSxHQUFHa0IsbUJBQW1CLENBQUM5SyxRQUFRLEVBQUVDLFFBQVEsQ0FBQztFQUNwRDtBQUNKO0FBQ0E7RUFDSSxJQUFJZ0QsV0FBVyxFQUFFO0lBQ2IyRyxNQUFNLEdBQUdBLE1BQU0sQ0FBQy9LLE1BQU0sQ0FBQyxDQUFDO01BQUVsRDtJQUFNLENBQUMsS0FBS3NILFdBQVcsQ0FBQytGLFFBQVEsQ0FBQ3JOLEtBQUssQ0FBQyxDQUFDO0VBQ3RFO0VBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lpTyxNQUFNLENBQUNFLE9BQU8sQ0FBRW1CLFdBQVcsSUFBSztJQUM1QixNQUFNQyxjQUFjLEdBQUc7TUFBRXZQLEtBQUssRUFBRXNQLFdBQVcsQ0FBQ3RQLEtBQUs7TUFBRUMsR0FBRyxFQUFFLElBQUk7TUFBRUMsSUFBSSxFQUFFb1AsV0FBVyxDQUFDcFA7SUFBSyxDQUFDO0lBQ3RGLE1BQU1zUCxTQUFTLEdBQUdmLGdCQUFnQixDQUFDdk4sTUFBTSxFQUFFcU8sY0FBYyxFQUFFbEwsUUFBUSxFQUFFQyxRQUFRLEVBQUVpRCxTQUFTLEVBQUU7TUFDdEZ2SCxLQUFLLEVBQUUsT0FBTztNQUNkQyxHQUFHLEVBQUUsU0FBUztNQUNkdUosT0FBTyxFQUFFO0lBQ2IsQ0FBQyxDQUFDO0lBQ0YsTUFBTXBGLFNBQVMsR0FBRyxFQUFFO0lBQ3BCLE1BQU1xTCxlQUFlLEdBQUcsRUFBRTtJQUMxQkQsU0FBUyxDQUFDckIsT0FBTyxDQUFFdUIsU0FBUyxJQUFLO01BQzdCLE1BQU1DLE9BQU8sR0FBRzlQLFNBQVMsQ0FBQ3NILE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRW1JLGNBQWMsQ0FBQyxFQUFFO1FBQUV0UCxHQUFHLEVBQUV5UCxTQUFTLENBQUNwUDtNQUFNLENBQUMsQ0FBQyxFQUFFbUUsVUFBVSxDQUFDO01BQ2pIO0FBQ1o7QUFDQTtBQUNBO01BQ1lnTCxlQUFlLENBQUM3TCxJQUFJLENBQUM7UUFDakIwSyxJQUFJLEVBQUVxQixPQUFPLEdBQUd2RixhQUFhLENBQUNsSixNQUFNLENBQUMsR0FBR3dPLFNBQVMsQ0FBQ3BCLElBQUk7UUFDdERoTyxLQUFLLEVBQUUsR0FBR2lQLGNBQWMsQ0FBQ3JQLElBQUksSUFBSXFQLGNBQWMsQ0FBQ3ZQLEtBQUssSUFBSTBQLFNBQVMsQ0FBQ3BQLEtBQUs7TUFDNUUsQ0FBQyxDQUFDO01BQ0Y7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7TUFDWThELFNBQVMsQ0FBQ1IsSUFBSSxDQUFDO1FBQ1g1RCxLQUFLLEVBQUV1UCxjQUFjLENBQUN2UCxLQUFLO1FBQzNCRSxJQUFJLEVBQUVxUCxjQUFjLENBQUNyUCxJQUFJO1FBQ3pCRCxHQUFHLEVBQUV5UCxTQUFTLENBQUNwUDtNQUNuQixDQUFDLENBQUM7SUFDTixDQUFDLENBQUM7SUFDRnNCLEtBQUssR0FBRyxDQUFDLEdBQUdBLEtBQUssRUFBRSxHQUFHd0MsU0FBUyxDQUFDO0lBQ2hDaUwsS0FBSyxHQUFHLENBQUMsR0FBR0EsS0FBSyxFQUFFLEdBQUdJLGVBQWUsQ0FBQztFQUMxQyxDQUFDLENBQUM7RUFDRixPQUFPO0lBQ0g3TixLQUFLO0lBQ0x5TjtFQUNKLENBQUM7QUFDTCxDQUFDO0FBQ0QsTUFBTU8sa0JBQWtCLEdBQUdBLENBQUMxTyxNQUFNLEVBQUVzRSxRQUFRLEVBQUVyRSxTQUFTLEVBQUVrRCxRQUFRLEVBQUVDLFFBQVEsRUFBRXVMLGlCQUFpQixFQUFFQyxtQkFBbUIsS0FBSztFQUNwSCxNQUFNOUMsaUJBQWlCLEdBQUcvTCxZQUFZLENBQUNDLE1BQU0sRUFBRUMsU0FBUyxDQUFDO0VBQ3pELE1BQU13RixTQUFTLEdBQUd6RSxRQUFRLENBQUM4SyxpQkFBaUIsQ0FBQztFQUM3QyxNQUFNO0lBQUVRLEtBQUs7SUFBRWpDLE9BQU87SUFBRWtDLEVBQUU7SUFBRUM7RUFBRyxDQUFDLEdBQUdYLFlBQVksQ0FBQzdMLE1BQU0sRUFBRXNFLFFBQVEsRUFBRXdILGlCQUFpQixFQUFFM0ksUUFBUSxFQUFFQyxRQUFRLEVBQUV1TCxpQkFBaUIsRUFBRUMsbUJBQW1CLENBQUM7RUFDaEosTUFBTUMsVUFBVSxHQUFHdkMsS0FBSyxDQUFDekssR0FBRyxDQUFFeEIsSUFBSSxJQUFLO0lBQ25DLE9BQU87TUFDSCtNLElBQUksRUFBRW5GLGdCQUFnQixDQUFDNUgsSUFBSSxFQUFFeUwsaUJBQWlCLENBQUM7TUFDL0MxTSxLQUFLLEVBQUVvRyxvQkFBb0IsQ0FBQ25GLElBQUksRUFBRW9GLFNBQVMsRUFBRW5CLFFBQVEsQ0FBQ3RCLElBQUk7SUFDOUQsQ0FBQztFQUNMLENBQUMsQ0FBQztFQUNGLE1BQU04TCxZQUFZLEdBQUd6RSxPQUFPLENBQUN4SSxHQUFHLENBQUVrQixNQUFNLElBQUs7SUFDekMsT0FBTztNQUNIcUssSUFBSSxFQUFFdEYsY0FBYyxDQUFDL0UsTUFBTSxDQUFDO01BQzVCM0QsS0FBSyxFQUFFMkQ7SUFDWCxDQUFDO0VBQ0wsQ0FBQyxDQUFDO0VBQ0YsTUFBTWdNLGNBQWMsR0FBRyxFQUFFO0VBQ3pCLElBQUl4QyxFQUFFLElBQUksQ0FBQzlHLFNBQVMsRUFBRTtJQUNsQnNKLGNBQWMsQ0FBQ3JNLElBQUksQ0FBQztNQUNoQjBLLElBQUksRUFBRXRELHFCQUFxQixDQUFDOUosTUFBTSxFQUFFLElBQUksQ0FBQztNQUN6Q1osS0FBSyxFQUFFO0lBQ1gsQ0FBQyxDQUFDO0VBQ047RUFDQSxJQUFJb04sRUFBRSxJQUFJLENBQUMvRyxTQUFTLEVBQUU7SUFDbEJzSixjQUFjLENBQUNyTSxJQUFJLENBQUM7TUFDaEIwSyxJQUFJLEVBQUV0RCxxQkFBcUIsQ0FBQzlKLE1BQU0sRUFBRSxJQUFJLENBQUM7TUFDekNaLEtBQUssRUFBRTtJQUNYLENBQUMsQ0FBQztFQUNOO0VBQ0EsT0FBTztJQUNINFAsV0FBVyxFQUFFRixZQUFZO0lBQ3pCRyxTQUFTLEVBQUVKLFVBQVU7SUFDckJLLGFBQWEsRUFBRUg7RUFDbkIsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzIjpbIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2RhdGEtR0lzSHNZSUIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IG0gYXMgcHJpbnRJb25XYXJuaW5nIH0gZnJvbSAnLi9pbmRleC1CX1U5Q3RhWS5qcyc7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZWxlY3RlZCBkYXkgaXMgZXF1YWwgdG8gdGhlIHJlZmVyZW5jZSBkYXlcbiAqL1xuY29uc3QgaXNTYW1lRGF5ID0gKGJhc2VQYXJ0cywgY29tcGFyZVBhcnRzKSA9PiB7XG4gICAgcmV0dXJuIChiYXNlUGFydHMubW9udGggPT09IGNvbXBhcmVQYXJ0cy5tb250aCAmJiBiYXNlUGFydHMuZGF5ID09PSBjb21wYXJlUGFydHMuZGF5ICYmIGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhcik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaXMgdGhlIHNlbGVjdGVkIGRheSBpcyBiZWZvcmUgdGhlIHJlZmVyZW5jZSBkYXkuXG4gKi9cbmNvbnN0IGlzQmVmb3JlID0gKGJhc2VQYXJ0cywgY29tcGFyZVBhcnRzKSA9PiB7XG4gICAgcmV0dXJuICEhKGJhc2VQYXJ0cy55ZWFyIDwgY29tcGFyZVBhcnRzLnllYXIgfHxcbiAgICAgICAgKGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhciAmJiBiYXNlUGFydHMubW9udGggPCBjb21wYXJlUGFydHMubW9udGgpIHx8XG4gICAgICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiZcbiAgICAgICAgICAgIGJhc2VQYXJ0cy5tb250aCA9PT0gY29tcGFyZVBhcnRzLm1vbnRoICYmXG4gICAgICAgICAgICBiYXNlUGFydHMuZGF5ICE9PSBudWxsICYmXG4gICAgICAgICAgICBiYXNlUGFydHMuZGF5IDwgY29tcGFyZVBhcnRzLmRheSkpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlzIHRoZSBzZWxlY3RlZCBkYXkgaXMgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBkYXkuXG4gKi9cbmNvbnN0IGlzQWZ0ZXIgPSAoYmFzZVBhcnRzLCBjb21wYXJlUGFydHMpID0+IHtcbiAgICByZXR1cm4gISEoYmFzZVBhcnRzLnllYXIgPiBjb21wYXJlUGFydHMueWVhciB8fFxuICAgICAgICAoYmFzZVBhcnRzLnllYXIgPT09IGNvbXBhcmVQYXJ0cy55ZWFyICYmIGJhc2VQYXJ0cy5tb250aCA+IGNvbXBhcmVQYXJ0cy5tb250aCkgfHxcbiAgICAgICAgKGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhciAmJlxuICAgICAgICAgICAgYmFzZVBhcnRzLm1vbnRoID09PSBjb21wYXJlUGFydHMubW9udGggJiZcbiAgICAgICAgICAgIGJhc2VQYXJ0cy5kYXkgIT09IG51bGwgJiZcbiAgICAgICAgICAgIGJhc2VQYXJ0cy5kYXkgPiBjb21wYXJlUGFydHMuZGF5KSk7XG59O1xuY29uc3Qgd2FybklmVmFsdWVPdXRPZkJvdW5kcyA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICBjb25zdCB2YWx1ZUFycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdmFsdWVBcnJheSkge1xuICAgICAgICBpZiAoKG1pbiAhPT0gdW5kZWZpbmVkICYmIGlzQmVmb3JlKHZhbCwgbWluKSkgfHwgKG1heCAhPT0gdW5kZWZpbmVkICYmIGlzQWZ0ZXIodmFsLCBtYXgpKSkge1xuICAgICAgICAgICAgcHJpbnRJb25XYXJuaW5nKCdbaW9uLWRhdGV0aW1lXSAtIFRoZSB2YWx1ZSBwcm92aWRlZCB0byBpb24tZGF0ZXRpbWUgaXMgb3V0IG9mIGJvdW5kcy5cXG5cXG4nICtcbiAgICAgICAgICAgICAgICBgTWluOiAke0pTT04uc3RyaW5naWZ5KG1pbil9XFxuYCArXG4gICAgICAgICAgICAgICAgYE1heDogJHtKU09OLnN0cmluZ2lmeShtYXgpfVxcbmAgK1xuICAgICAgICAgICAgICAgIGBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBnaXZlbiB5ZWFyIGlzIGFcbiAqIGxlYXAgeWVhci4gUmV0dXJucyBgdHJ1ZWAgaWYgeWVhclxuICogaXMgYSBsZWFwIHllYXIuIFJldHVybnMgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICovXG5jb25zdCBpc0xlYXBZZWFyID0gKHllYXIpID0+IHtcbiAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBob3VyIGN5Y2xlIGZvciBhIHVzZXIuXG4gKiBJZiB0aGUgaG91ciBjeWNsZSBpcyBleHBsaWNpdGx5IGRlZmluZWQsIGp1c3QgdXNlIHRoYXQuXG4gKiBPdGhlcndpc2UsIHdlIHRyeSB0byBkZXJpdmUgaXQgZnJvbSBlaXRoZXIgdGhlIHNwZWNpZmllZFxuICogbG9jYWxlIGV4dGVuc2lvbiB0YWdzIG9yIGZyb20gSW50bC5EYXRlVGltZUZvcm1hdCBkaXJlY3RseS5cbiAqL1xuY29uc3QgZ2V0SG91ckN5Y2xlID0gKGxvY2FsZSwgaG91ckN5Y2xlKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgZGV2ZWxvcGVyIGhhcyBleHBsaWNpdGx5IGVuYWJsZWQgMjQtaG91ciB0aW1lXG4gICAgICogdGhlbiByZXR1cm4gZWFybHkgYW5kIGRvIG5vdCBsb29rIGF0IHRoZSBzeXN0ZW0gZGVmYXVsdC5cbiAgICAgKi9cbiAgICBpZiAoaG91ckN5Y2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhvdXJDeWNsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgaG91ckN5Y2xlIHdhcyBub3Qgc3BlY2lmaWVkLCBjaGVjayB0aGUgbG9jYWxlXG4gICAgICogdGhhdCBpcyBzZXQgb24gdGhlIHVzZXIncyBkZXZpY2UuIFdlIGZpcnN0IGNoZWNrIHRoZVxuICAgICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgaG91ckN5Y2xlIG9wdGlvbiBhcyBkZXZlbG9wZXJzIGNhbiBlbmNvZGUgdGhpc1xuICAgICAqIG9wdGlvbiBpbnRvIHRoZSBsb2NhbGUgc3RyaW5nLiBFeGFtcGxlOiBgZW4tVVMtdS1oYy1oMjNgXG4gICAgICovXG4gICAgY29uc3QgZm9ybWF0dGVkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IGhvdXI6ICdudW1lcmljJyB9KTtcbiAgICBjb25zdCBvcHRpb25zID0gZm9ybWF0dGVkLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIGlmIChvcHRpb25zLmhvdXJDeWNsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmhvdXJDeWNsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgaG91ckN5Y2xlIGlzIG5vdCBzcGVjaWZpZWQgKGVpdGhlciB0aHJvdWdoIGxhY2tcbiAgICAgKiBvZiBicm93c2VyIHN1cHBvcnQgb3IgbG9jYWxlIGluZm9ybWF0aW9uKSB0aGVuIGZhbGxcbiAgICAgKiBiYWNrIHRvIHRoaXMgc2xvd2VyIGhvdXJDeWNsZSBjaGVjay5cbiAgICAgKi9cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoJzUvMTgvMjAyMSAwMDowMCcpO1xuICAgIGNvbnN0IHBhcnRzID0gZm9ybWF0dGVkLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gICAgY29uc3QgaG91ciA9IHBhcnRzLmZpbmQoKHApID0+IHAudHlwZSA9PT0gJ2hvdXInKTtcbiAgICBpZiAoIWhvdXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb3VyIHZhbHVlIG5vdCBmb3VuZCBmcm9tIERhdGVUaW1lRm9ybWF0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1pZG5pZ2h0IGZvciBoMTEgc3RhcnRzIGF0IDA6MDBhbVxuICAgICAqIE1pZG5pZ2h0IGZvciBoMTIgc3RhcnRzIGF0IDEyOjAwYW1cbiAgICAgKiBNaWRuaWdodCBmb3IgaDIzIHN0YXJ0cyBhdCAwMDowMFxuICAgICAqIE1pZG5pZ2h0IGZvciBoMjQgc3RhcnRzIGF0IDI0OjAwXG4gICAgICovXG4gICAgc3dpdGNoIChob3VyLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgcmV0dXJuICdoMTEnO1xuICAgICAgICBjYXNlICcxMic6XG4gICAgICAgICAgICByZXR1cm4gJ2gxMic7XG4gICAgICAgIGNhc2UgJzAwJzpcbiAgICAgICAgICAgIHJldHVybiAnaDIzJztcbiAgICAgICAgY2FzZSAnMjQnOlxuICAgICAgICAgICAgcmV0dXJuICdoMjQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhvdXIgY3ljbGUgXCIke2hvdXJDeWNsZX1cImApO1xuICAgIH1cbn07XG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgaG91ciBjeWNsZSB1c2VzIGEgMjQtaG91ciBmb3JtYXQuXG4gKiBSZXR1cm5zIHRydWUgZm9yIGgyMyBhbmQgaDI0LiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAqIElmIHlvdSBkb24ndCBrbm93IHRoZSBob3VyQ3ljbGUsIHVzZSBnZXRIb3VyQ3ljbGUgYWJvdmVcbiAqIGFuZCBwYXNzIHRoZSByZXN1bHQgaW50byB0aGlzIGZ1bmN0aW9uLlxuICovXG5jb25zdCBpczI0SG91ciA9IChob3VyQ3ljbGUpID0+IHtcbiAgICByZXR1cm4gaG91ckN5Y2xlID09PSAnaDIzJyB8fCBob3VyQ3ljbGUgPT09ICdoMjQnO1xufTtcbi8qKlxuICogR2l2ZW4gYSBkYXRlIG9iamVjdCwgcmV0dXJucyB0aGUgbnVtYmVyXG4gKiBvZiBkYXlzIGluIHRoYXQgbW9udGguXG4gKiBNb250aCB2YWx1ZSBiZWdpbiBhdCAxLCBub3QgMC5cbiAqIGkuZS4gSmFudWFyeSA9IG1vbnRoIDEuXG4gKi9cbmNvbnN0IGdldE51bURheXNJbk1vbnRoID0gKG1vbnRoLCB5ZWFyKSA9PiB7XG4gICAgcmV0dXJuIG1vbnRoID09PSA0IHx8IG1vbnRoID09PSA2IHx8IG1vbnRoID09PSA5IHx8IG1vbnRoID09PSAxMVxuICAgICAgICA/IDMwXG4gICAgICAgIDogbW9udGggPT09IDJcbiAgICAgICAgICAgID8gaXNMZWFwWWVhcih5ZWFyKVxuICAgICAgICAgICAgICAgID8gMjlcbiAgICAgICAgICAgICAgICA6IDI4XG4gICAgICAgICAgICA6IDMxO1xufTtcbi8qKlxuICogQ2VydGFpbiBsb2NhbGVzIGRpc3BsYXkgbW9udGggdGhlbiB5ZWFyIHdoaWxlXG4gKiBvdGhlcnMgZGlzcGxheSB5ZWFyIHRoZW4gbW9udGguXG4gKiBXZSBjYW4gdXNlIEludGwuRGF0ZVRpbWVGb3JtYXQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgb3JkZXJpbmcgZm9yIGVhY2ggbG9jYWxlLlxuICogVGhlIGZvcm1hdE9wdGlvbnMgcGFyYW0gY2FuIGJlIHVzZWQgdG8gY3VzdG9taXplXG4gKiB3aGljaCBwaWVjZXMgb2YgYSBkYXRlIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgbW9udGhcbiAqIHdpdGguIEZvciBleGFtcGxlLCBzb21lIGxvY2FsZXMgcmVuZGVyIGRkL21tL3l5eXlcbiAqIHdoaWxlIG90aGVycyByZW5kZXIgbW0vZGQveXl5eS4gVGhpcyBmdW5jdGlvbiBjYW4gYmVcbiAqIHVzZWQgZm9yIHZhcmlhdGlvbnMgb2YgdGhlIHNhbWUgXCJtb250aCBmaXJzdFwiIGNoZWNrLlxuICovXG5jb25zdCBpc01vbnRoRmlyc3RMb2NhbGUgPSAobG9jYWxlLCBmb3JtYXRPcHRpb25zID0ge1xuICAgIG1vbnRoOiAnbnVtZXJpYycsXG4gICAgeWVhcjogJ251bWVyaWMnLFxufSkgPT4ge1xuICAgIC8qKlxuICAgICAqIEJ5IHNldHRpbmcgbW9udGggYW5kIHllYXIgd2UgZ3VhcmFudGVlIHRoYXQgb25seVxuICAgICAqIG1vbnRoLCB5ZWFyLCBhbmQgbGl0ZXJhbCAoc2xhc2hlcyAnLycsIGZvciBleGFtcGxlKVxuICAgICAqIHZhbHVlcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGZvcm1hdFRvUGFydHMgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmRlcmluZyBvZiB0aGUgcGFydHMgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5XG4gICAgICogdGhlIGxvY2FsZS4gU28gaWYgdGhlIG1vbnRoIGlzIHRoZSBmaXJzdCB2YWx1ZSxcbiAgICAgKiB0aGVuIHdlIGtub3cgbW9udGggc2hvdWxkIGJlIHNob3duIGZpcnN0LiBJZiB0aGVcbiAgICAgKiB5ZWFyIGlzIHRoZSBmaXJzdCB2YWx1ZSwgdGhlbiB3ZSBrbm93IHllYXIgc2hvdWxkIGJlIHNob3duIGZpcnN0LlxuICAgICAqXG4gICAgICogVGhpcyBvcmRlcmluZyBjYW4gYmUgY29udHJvbGxlZCBieSBjdXN0b21pemluZyB0aGUgbG9jYWxlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGNvbnN0IHBhcnRzID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBmb3JtYXRPcHRpb25zKS5mb3JtYXRUb1BhcnRzKG5ldyBEYXRlKCkpO1xuICAgIHJldHVybiBwYXJ0c1swXS50eXBlID09PSAnbW9udGgnO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gbG9jYWxlIGZvcm1hdHMgdGhlIGRheSBwZXJpb2QgKGFtL3BtKSB0byB0aGVcbiAqIGxlZnQgb3IgcmlnaHQgb2YgdGhlIGhvdXIuXG4gKiBAcGFyYW0gbG9jYWxlIFRoZSBsb2NhbGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGxvY2FsZSBmb3JtYXRzIHRoZSBkYXkgcGVyaW9kIHRvIHRoZSBsZWZ0IG9mIHRoZSBob3VyLlxuICovXG5jb25zdCBpc0xvY2FsZURheVBlcmlvZFJUTCA9IChsb2NhbGUpID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyBob3VyOiAnbnVtZXJpYycgfSkuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgpKTtcbiAgICByZXR1cm4gcGFydHNbMF0udHlwZSA9PT0gJ2RheVBlcmlvZCc7XG59O1xuXG5jb25zdCBJU09fODYwMV9SRUdFWFAgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuL14oXFxkezR9fFsrXFwtXVxcZHs2fSkoPzotKFxcZHsyfSkoPzotKFxcZHsyfSkpPyk/KD86VChcXGR7Mn0pOihcXGR7Mn0pKD86OihcXGR7Mn0pKD86XFwuKFxcZHszfSkpPyk/KD86KFopfChbK1xcLV0pKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyk/KT8kLztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuY29uc3QgVElNRV9SRUdFWFAgPSAvXigoXFxkezJ9KTooXFxkezJ9KSg/OjooXFxkezJ9KSg/OlxcLihcXGR7M30pKT8pPyg/OihaKXwoWytcXC1dKShcXGR7Mn0pKD86OihcXGR7Mn0pKT8pPyk/JC87XG4vKipcbiAqIFVzZSB0byBjb252ZXJ0IGEgc3RyaW5nIG9mIGNvbW1hIHNlcGFyYXRlZCBudW1iZXJzIG9yXG4gKiBhbiBhcnJheSBvZiBudW1iZXJzLCBhbmQgY2xlYW4gdXAgYW55IHVzZXIgaW5wdXRcbiAqL1xuY29uc3QgY29udmVydFRvQXJyYXlPZk51bWJlcnMgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcm9jZXNzZWRJbnB1dCA9IGlucHV0O1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgIC8vIGF1dG8gcmVtb3ZlIGFueSB3aGl0ZXNwYWNlIGFuZCBbXSBjaGFyYWN0ZXJzXG4gICAgICAgIHByb2Nlc3NlZElucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxbfFxcXXxcXHMvZywgJycpLnNwbGl0KCcsJyk7XG4gICAgfVxuICAgIGxldCB2YWx1ZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvY2Vzc2VkSW5wdXQpKSB7XG4gICAgICAgIC8vIGVuc3VyZSBlYWNoIHZhbHVlIGlzIGFuIGFjdHVhbCBudW1iZXIgaW4gdGhlIHJldHVybmVkIGFycmF5XG4gICAgICAgIHZhbHVlcyA9IHByb2Nlc3NlZElucHV0Lm1hcCgobnVtKSA9PiBwYXJzZUludChudW0sIDEwKSkuZmlsdGVyKGlzRmluaXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlcyA9IFtwcm9jZXNzZWRJbnB1dF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuLyoqXG4gKiBFeHRyYWN0cyBkYXRlIGluZm9ybWF0aW9uXG4gKiBmcm9tIGEgLmNhbGVuZGFyLWRheSBlbGVtZW50XG4gKiBpbnRvIERhdGV0aW1lUGFydHMuXG4gKi9cbmNvbnN0IGdldFBhcnRzRnJvbUNhbGVuZGFyRGF5ID0gKGVsKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbW9udGg6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1tb250aCcpLCAxMCksXG4gICAgICAgIGRheTogcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRheScpLCAxMCksXG4gICAgICAgIHllYXI6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS15ZWFyJyksIDEwKSxcbiAgICAgICAgZGF5T2ZXZWVrOiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF5LW9mLXdlZWsnKSwgMTApLFxuICAgIH07XG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlKHZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB2YWxTdHIgb2YgdmFsKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWwgPSBwYXJzZURhdGUodmFsU3RyKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgYW55IG9mIHRoZSB2YWx1ZXMgd2VyZW4ndCBwYXJzZWQgY29ycmVjdGx5LCBjb25zaWRlclxuICAgICAgICAgICAgICogdGhlIGVudGlyZSBiYXRjaCBpbmNvcnJlY3QuIFRoaXMgc2ltcGxpZmllcyB0aGUgdHlwZVxuICAgICAgICAgICAgICogc2lnbmF0dXJlcyBieSBoYXZpbmcgXCJ1bmRlZmluZWRcIiBiZSBhIGdlbmVyYWwgZXJyb3IgY2FzZVxuICAgICAgICAgICAgICogaW5zdGVhZCBvZiByZXR1cm5pbmcgKERhdGV0aW1lIHwgdW5kZWZpbmVkKVtdLCB3aGljaCBpc1xuICAgICAgICAgICAgICogaGFyZGVyIGZvciBUUyB0byBwZXJmb3JtIHR5cGUgbmFycm93aW5nIG9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXBhcnNlZFZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWRBcnJheS5wdXNoKHBhcnNlZFZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZEFycmF5O1xuICAgIH1cbiAgICAvLyBtYW51YWxseSBwYXJzZSBJUzAgY3V6IERhdGUucGFyc2UgY2Fubm90IGJlIHRydXN0ZWRcbiAgICAvLyBJU08gODYwMSBmb3JtYXQ6IDE5OTQtMTItMTVUMTM6NDc6MjBaXG4gICAgbGV0IHBhcnNlID0gbnVsbDtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsICE9PSAnJykge1xuICAgICAgICAvLyB0cnkgcGFyc2luZyBmb3IganVzdCB0aW1lIGZpcnN0LCBISDpNTVxuICAgICAgICBwYXJzZSA9IFRJTUVfUkVHRVhQLmV4ZWModmFsKTtcbiAgICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgICAgICAvLyBhZGp1c3QgdGhlIGFycmF5IHNvIGl0IGZpdHMgbmljZWx5IHdpdGggdGhlIGRhdGV0aW1lIHBhcnNlXG4gICAgICAgICAgICBwYXJzZS51bnNoaWZ0KHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHBhcnNlWzJdID0gcGFyc2VbM10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0cnkgcGFyc2luZyBmb3IgZnVsbCBJU08gZGF0ZXRpbWVcbiAgICAgICAgICAgIHBhcnNlID0gSVNPXzg2MDFfUkVHRVhQLmV4ZWModmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2UgPT09IG51bGwpIHtcbiAgICAgICAgLy8gd2Fzbid0IGFibGUgdG8gcGFyc2UgdGhlIElTTyBkYXRldGltZVxuICAgICAgICBwcmludElvbldhcm5pbmcoYFtpb24tZGF0ZXRpbWVdIC0gVW5hYmxlIHRvIHBhcnNlIGRhdGUgc3RyaW5nOiAke3ZhbH0uIFBsZWFzZSBwcm92aWRlIGEgdmFsaWQgSVNPIDg2MDEgZGF0ZXRpbWUgc3RyaW5nLmApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYWxsIHRoZSBwYXJzZSB2YWx1ZXMgZXhpc3Qgd2l0aCBhdCBsZWFzdCAwXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgcGFyc2VbaV0gPSBwYXJzZVtpXSAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQocGFyc2VbaV0sIDEwKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gY2FuIGFsc28gZ2V0IHNlY29uZCBhbmQgbWlsbGlzZWNvbmQgZnJvbSBwYXJzZVs2XSBhbmQgcGFyc2VbN10gaWYgbmVlZGVkXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogcGFyc2VbMV0sXG4gICAgICAgIG1vbnRoOiBwYXJzZVsyXSxcbiAgICAgICAgZGF5OiBwYXJzZVszXSxcbiAgICAgICAgaG91cjogcGFyc2VbNF0sXG4gICAgICAgIG1pbnV0ZTogcGFyc2VbNV0sXG4gICAgICAgIGFtcG06IHBhcnNlWzRdIDwgMTIgPyAnYW0nIDogJ3BtJyxcbiAgICB9O1xufVxuY29uc3QgY2xhbXBEYXRlID0gKGRhdGVQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzKSA9PiB7XG4gICAgaWYgKG1pblBhcnRzICYmIGlzQmVmb3JlKGRhdGVQYXJ0cywgbWluUGFydHMpKSB7XG4gICAgICAgIHJldHVybiBtaW5QYXJ0cztcbiAgICB9XG4gICAgZWxzZSBpZiAobWF4UGFydHMgJiYgaXNBZnRlcihkYXRlUGFydHMsIG1heFBhcnRzKSkge1xuICAgICAgICByZXR1cm4gbWF4UGFydHM7XG4gICAgfVxuICAgIHJldHVybiBkYXRlUGFydHM7XG59O1xuLyoqXG4gKiBQYXJzZXMgYW4gaG91ciBhbmQgcmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgaW4gdGhlIG1vcm5pbmcgKGFtKSBvciBhZnRlcm5vb24gKHBtKS5cbiAqIEBwYXJhbSBob3VyIFRoZSBob3VyIHRvIGZvcm1hdCwgc2hvdWxkIGJlIDAtMjNcbiAqIEByZXR1cm5zIGBwbWAgaWYgdGhlIGhvdXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEyLCBgYW1gIGlmIGxlc3MgdGhhbiAxMi5cbiAqL1xuY29uc3QgcGFyc2VBbVBtID0gKGhvdXIpID0+IHtcbiAgICByZXR1cm4gaG91ciA+PSAxMiA/ICdwbScgOiAnYW0nO1xufTtcbi8qKlxuICogVGFrZXMgYSBtYXggZGF0ZSBzdHJpbmcgYW5kIGNyZWF0ZXMgYSBEYXRldGltZVBhcnRzXG4gKiBvYmplY3QsIGZpbGxpbmcgaW4gYW55IG1pc3NpbmcgaW5mb3JtYXRpb24uXG4gKiBGb3IgZXhhbXBsZSwgbWF4PVwiMjAxMlwiIHdvdWxkIGZpbGwgaW4gdGhlIG1pc3NpbmdcbiAqIG1vbnRoLCBkYXksIGhvdXIsIGFuZCBtaW51dGUgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IHBhcnNlTWF4UGFydHMgPSAobWF4LCB0b2RheVBhcnRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VEYXRlKG1heCk7XG4gICAgLyoqXG4gICAgICogSWYgbWluIHdhcyBub3QgYSB2YWxpZCBkYXRlIHRoZW4gcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIsIGhvdXIsIG1pbnV0ZSB9ID0gcmVzdWx0O1xuICAgIC8qKlxuICAgICAqIFdoZW4gcGFzc2luZyBpbiBgbWF4YCBvciBgbWluYCwgZGV2ZWxvcGVyc1xuICAgICAqIGNhbiBwYXNzIGluIGFueSBJU08tODYwMSBzdHJpbmcuIFRoaXMgbWVhbnNcbiAgICAgKiB0aGF0IG5vdCBhbGwgb2YgdGhlIGRhdGUvdGltZSBmaWVsZHMgYXJlIGRlZmluZWQuXG4gICAgICogRm9yIGV4YW1wbGUsIHBhc3NpbmcgbWF4PVwiMjAxMlwiIGlzIHZhbGlkIGV2ZW4gdGhvdWdoXG4gICAgICogdGhlcmUgaXMgbm8gbW9udGgsIGRheSwgaG91ciwgb3IgbWludXRlIGRhdGEuXG4gICAgICogSG93ZXZlciwgYWxsIG9mIHRoaXMgZGF0YSBpcyByZXF1aXJlZCB3aGVuIGNsYW1waW5nIHRoZSBkYXRlXG4gICAgICogc28gdGhhdCB0aGUgY29ycmVjdCBpbml0aWFsIHZhbHVlIGNhbiBiZSBzZWxlY3RlZC4gQXMgYSByZXN1bHQsXG4gICAgICogd2UgbmVlZCB0byBmaWxsIGluIGFueSBvbWl0dGVkIGRhdGEgd2l0aCB0aGUgbWluIG9yIG1heCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3QgeWVhclZhbHVlID0geWVhciAhPT0gbnVsbCAmJiB5ZWFyICE9PSB2b2lkIDAgPyB5ZWFyIDogdG9kYXlQYXJ0cy55ZWFyO1xuICAgIGNvbnN0IG1vbnRoVmFsdWUgPSBtb250aCAhPT0gbnVsbCAmJiBtb250aCAhPT0gdm9pZCAwID8gbW9udGggOiAxMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBtb250aDogbW9udGhWYWx1ZSxcbiAgICAgICAgZGF5OiBkYXkgIT09IG51bGwgJiYgZGF5ICE9PSB2b2lkIDAgPyBkYXkgOiBnZXROdW1EYXlzSW5Nb250aChtb250aFZhbHVlLCB5ZWFyVmFsdWUpLFxuICAgICAgICAvKipcbiAgICAgICAgICogUGFzc2luZyBpbiBcIkhIOm1tXCIgaXMgYSB2YWxpZCBJU08tODYwMVxuICAgICAgICAgKiBzdHJpbmcsIHNvIHdlIGp1c3QgZGVmYXVsdCB0byB0aGUgY3VycmVudCB5ZWFyXG4gICAgICAgICAqIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICovXG4gICAgICAgIHllYXI6IHllYXJWYWx1ZSxcbiAgICAgICAgaG91cjogaG91ciAhPT0gbnVsbCAmJiBob3VyICE9PSB2b2lkIDAgPyBob3VyIDogMjMsXG4gICAgICAgIG1pbnV0ZTogbWludXRlICE9PSBudWxsICYmIG1pbnV0ZSAhPT0gdm9pZCAwID8gbWludXRlIDogNTksXG4gICAgfTtcbn07XG4vKipcbiAqIFRha2VzIGEgbWluIGRhdGUgc3RyaW5nIGFuZCBjcmVhdGVzIGEgRGF0ZXRpbWVQYXJ0c1xuICogb2JqZWN0LCBmaWxsaW5nIGluIGFueSBtaXNzaW5nIGluZm9ybWF0aW9uLlxuICogRm9yIGV4YW1wbGUsIG1pbj1cIjIwMTJcIiB3b3VsZCBmaWxsIGluIHRoZSBtaXNzaW5nXG4gKiBtb250aCwgZGF5LCBob3VyLCBhbmQgbWludXRlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBwYXJzZU1pblBhcnRzID0gKG1pbiwgdG9kYXlQYXJ0cykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlRGF0ZShtaW4pO1xuICAgIC8qKlxuICAgICAqIElmIG1pbiB3YXMgbm90IGEgdmFsaWQgZGF0ZSB0aGVuIHJldHVybiB1bmRlZmluZWQuXG4gICAgICovXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyLCBob3VyLCBtaW51dGUgfSA9IHJlc3VsdDtcbiAgICAvKipcbiAgICAgKiBXaGVuIHBhc3NpbmcgaW4gYG1heGAgb3IgYG1pbmAsIGRldmVsb3BlcnNcbiAgICAgKiBjYW4gcGFzcyBpbiBhbnkgSVNPLTg2MDEgc3RyaW5nLiBUaGlzIG1lYW5zXG4gICAgICogdGhhdCBub3QgYWxsIG9mIHRoZSBkYXRlL3RpbWUgZmllbGRzIGFyZSBkZWZpbmVkLlxuICAgICAqIEZvciBleGFtcGxlLCBwYXNzaW5nIG1heD1cIjIwMTJcIiBpcyB2YWxpZCBldmVuIHRob3VnaFxuICAgICAqIHRoZXJlIGlzIG5vIG1vbnRoLCBkYXksIGhvdXIsIG9yIG1pbnV0ZSBkYXRhLlxuICAgICAqIEhvd2V2ZXIsIGFsbCBvZiB0aGlzIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiBjbGFtcGluZyB0aGUgZGF0ZVxuICAgICAqIHNvIHRoYXQgdGhlIGNvcnJlY3QgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgc2VsZWN0ZWQuIEFzIGEgcmVzdWx0LFxuICAgICAqIHdlIG5lZWQgdG8gZmlsbCBpbiBhbnkgb21pdHRlZCBkYXRhIHdpdGggdGhlIG1pbiBvciBtYXggdmFsdWVzLlxuICAgICAqL1xuICAgIHJldHVybiB7XG4gICAgICAgIG1vbnRoOiBtb250aCAhPT0gbnVsbCAmJiBtb250aCAhPT0gdm9pZCAwID8gbW9udGggOiAxLFxuICAgICAgICBkYXk6IGRheSAhPT0gbnVsbCAmJiBkYXkgIT09IHZvaWQgMCA/IGRheSA6IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzaW5nIGluIFwiSEg6bW1cIiBpcyBhIHZhbGlkIElTTy04NjAxXG4gICAgICAgICAqIHN0cmluZywgc28gd2UganVzdCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IHllYXJcbiAgICAgICAgICogaW4gdGhpcyBjYXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgeWVhcjogeWVhciAhPT0gbnVsbCAmJiB5ZWFyICE9PSB2b2lkIDAgPyB5ZWFyIDogdG9kYXlQYXJ0cy55ZWFyLFxuICAgICAgICBob3VyOiBob3VyICE9PSBudWxsICYmIGhvdXIgIT09IHZvaWQgMCA/IGhvdXIgOiAwLFxuICAgICAgICBtaW51dGU6IG1pbnV0ZSAhPT0gbnVsbCAmJiBtaW51dGUgIT09IHZvaWQgMCA/IG1pbnV0ZSA6IDAsXG4gICAgfTtcbn07XG5cbmNvbnN0IHR3b0RpZ2l0ID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiAoJzAnICsgKHZhbCAhPT0gdW5kZWZpbmVkID8gTWF0aC5hYnModmFsKSA6ICcwJykpLnNsaWNlKC0yKTtcbn07XG5jb25zdCBmb3VyRGlnaXQgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuICgnMDAwJyArICh2YWwgIT09IHVuZGVmaW5lZCA/IE1hdGguYWJzKHZhbCkgOiAnMCcpKS5zbGljZSgtNCk7XG59O1xuZnVuY3Rpb24gY29udmVydERhdGFUb0lTTyhkYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChwYXJ0cykgPT4gY29udmVydERhdGFUb0lTTyhwYXJ0cykpO1xuICAgIH1cbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvTk9URS1kYXRldGltZVxuICAgIGxldCBydG4gPSAnJztcbiAgICBpZiAoZGF0YS55ZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gWVlZWVxuICAgICAgICBydG4gPSBmb3VyRGlnaXQoZGF0YS55ZWFyKTtcbiAgICAgICAgaWYgKGRhdGEubW9udGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gWVlZWS1NTVxuICAgICAgICAgICAgcnRuICs9ICctJyArIHR3b0RpZ2l0KGRhdGEubW9udGgpO1xuICAgICAgICAgICAgaWYgKGRhdGEuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBZWVlZLU1NLUREXG4gICAgICAgICAgICAgICAgcnRuICs9ICctJyArIHR3b0RpZ2l0KGRhdGEuZGF5KTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWVlZWS1NTS1ERFRISDptbTpTU1xuICAgICAgICAgICAgICAgICAgICBydG4gKz0gYFQke3R3b0RpZ2l0KGRhdGEuaG91cil9OiR7dHdvRGlnaXQoZGF0YS5taW51dGUpfTowMGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEhIOm1tXG4gICAgICAgIHJ0biA9IHR3b0RpZ2l0KGRhdGEuaG91cikgKyAnOicgKyB0d29EaWdpdChkYXRhLm1pbnV0ZSk7XG4gICAgfVxuICAgIHJldHVybiBydG47XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIDEyIGhvdXIgdmFsdWUgdG8gMjQgaG91cnMuXG4gKi9cbmNvbnN0IGNvbnZlcnQxMkhvdXJUbzI0SG91ciA9IChob3VyLCBhbXBtKSA9PiB7XG4gICAgaWYgKGFtcG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgQU0gYW5kIDEyYW1cbiAgICAgKiB0aGVuIHJldHVybiAwMDowMC5cbiAgICAgKiBPdGhlcndpc2UganVzdCByZXR1cm5cbiAgICAgKiB0aGUgaG91ciBzaW5jZSBpdCBpc1xuICAgICAqIGFscmVhZHkgaW4gMjQgaG91ciBmb3JtYXQuXG4gICAgICovXG4gICAgaWYgKGFtcG0gPT09ICdhbScpIHtcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgUE0gYW5kIDEycG1cbiAgICAgKiBqdXN0IHJldHVybiAxMjowMFxuICAgICAqIHNpbmNlIGl0IGlzIGFscmVhZHlcbiAgICAgKiBpbiAyNCBob3VyIGZvcm1hdC5cbiAgICAgKiBPdGhlcndpc2UgYWRkIDEyIGhvdXJzXG4gICAgICogdG8gdGhlIHRpbWUuXG4gICAgICovXG4gICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgcmV0dXJuIGhvdXIgKyAxMjtcbn07XG5jb25zdCBnZXRTdGFydE9mV2VlayA9IChyZWZQYXJ0cykgPT4ge1xuICAgIGNvbnN0IHsgZGF5T2ZXZWVrIH0gPSByZWZQYXJ0cztcbiAgICBpZiAoZGF5T2ZXZWVrID09PSBudWxsIHx8IGRheU9mV2VlayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF5IG9mIHdlZWsgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnRyYWN0RGF5cyhyZWZQYXJ0cywgZGF5T2ZXZWVrKTtcbn07XG5jb25zdCBnZXRFbmRPZldlZWsgPSAocmVmUGFydHMpID0+IHtcbiAgICBjb25zdCB7IGRheU9mV2VlayB9ID0gcmVmUGFydHM7XG4gICAgaWYgKGRheU9mV2VlayA9PT0gbnVsbCB8fCBkYXlPZldlZWsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBvZiB3ZWVrIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBhZGREYXlzKHJlZlBhcnRzLCA2IC0gZGF5T2ZXZWVrKTtcbn07XG5jb25zdCBnZXROZXh0RGF5ID0gKHJlZlBhcnRzKSA9PiB7XG4gICAgcmV0dXJuIGFkZERheXMocmVmUGFydHMsIDEpO1xufTtcbmNvbnN0IGdldFByZXZpb3VzRGF5ID0gKHJlZlBhcnRzKSA9PiB7XG4gICAgcmV0dXJuIHN1YnRyYWN0RGF5cyhyZWZQYXJ0cywgMSk7XG59O1xuY29uc3QgZ2V0UHJldmlvdXNXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gICAgcmV0dXJuIHN1YnRyYWN0RGF5cyhyZWZQYXJ0cywgNyk7XG59O1xuY29uc3QgZ2V0TmV4dFdlZWsgPSAocmVmUGFydHMpID0+IHtcbiAgICByZXR1cm4gYWRkRGF5cyhyZWZQYXJ0cywgNyk7XG59O1xuLyoqXG4gKiBHaXZlbiBkYXRldGltZSBwYXJ0cywgc3VidHJhY3RcbiAqIG51bURheXMgZnJvbSB0aGUgZGF0ZS5cbiAqIFJldHVybnMgYSBuZXcgRGF0ZXRpbWVQYXJ0cyBvYmplY3RcbiAqIEN1cnJlbnRseSBjYW4gb25seSBnbyBiYWNrd2FyZCBhdCBtb3N0IDEgbW9udGguXG4gKi9cbmNvbnN0IHN1YnRyYWN0RGF5cyA9IChyZWZQYXJ0cywgbnVtRGF5cykgPT4ge1xuICAgIGNvbnN0IHsgbW9udGgsIGRheSwgeWVhciB9ID0gcmVmUGFydHM7XG4gICAgaWYgKGRheSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBjb25zdCB3b3JraW5nUGFydHMgPSB7XG4gICAgICAgIG1vbnRoLFxuICAgICAgICBkYXksXG4gICAgICAgIHllYXIsXG4gICAgfTtcbiAgICB3b3JraW5nUGFydHMuZGF5ID0gZGF5IC0gbnVtRGF5cztcbiAgICAvKipcbiAgICAgKiBJZiB3cmFwcGluZyB0byBwcmV2aW91cyBtb250aFxuICAgICAqIHVwZGF0ZSBkYXlzIGFuZCBkZWNyZW1lbnQgbW9udGhcbiAgICAgKi9cbiAgICBpZiAod29ya2luZ1BhcnRzLmRheSA8IDEpIHtcbiAgICAgICAgd29ya2luZ1BhcnRzLm1vbnRoIC09IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIG1vdmluZyB0byBwcmV2aW91cyB5ZWFyLCByZXNldFxuICAgICAqIG1vbnRoIHRvIERlY2VtYmVyIGFuZCBkZWNyZW1lbnQgeWVhclxuICAgICAqL1xuICAgIGlmICh3b3JraW5nUGFydHMubW9udGggPCAxKSB7XG4gICAgICAgIHdvcmtpbmdQYXJ0cy5tb250aCA9IDEyO1xuICAgICAgICB3b3JraW5nUGFydHMueWVhciAtPSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaG93IG1hbnkgZGF5cyBhcmUgaW4gdGhlIGN1cnJlbnRcbiAgICAgKiBtb250aFxuICAgICAqL1xuICAgIGlmICh3b3JraW5nUGFydHMuZGF5IDwgMSkge1xuICAgICAgICBjb25zdCBkYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKHdvcmtpbmdQYXJ0cy5tb250aCwgd29ya2luZ1BhcnRzLnllYXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZSBudW0gZGF5cyBpbiBtb250aCBhbmQgYWRkIHRoZVxuICAgICAgICAgKiBudW1iZXIgb2YgdW5kZXJmbG93IGRheXMuIFRoaXMgbnVtYmVyIHdpbGxcbiAgICAgICAgICogYmUgbmVnYXRpdmUuXG4gICAgICAgICAqIEV4YW1wbGU6IDEgd2VlayBiZWZvcmUgSmFuIDIsIDIwMjEgaXNcbiAgICAgICAgICogRGVjZW1iZXIgMjYsIDIwMjEgc286XG4gICAgICAgICAqIDIgLSA3ID0gLTVcbiAgICAgICAgICogMzEgKyAoLTUpID0gMjZcbiAgICAgICAgICovXG4gICAgICAgIHdvcmtpbmdQYXJ0cy5kYXkgPSBkYXlzSW5Nb250aCArIHdvcmtpbmdQYXJ0cy5kYXk7XG4gICAgfVxuICAgIHJldHVybiB3b3JraW5nUGFydHM7XG59O1xuLyoqXG4gKiBHaXZlbiBkYXRldGltZSBwYXJ0cywgYWRkXG4gKiBudW1EYXlzIHRvIHRoZSBkYXRlLlxuICogUmV0dXJucyBhIG5ldyBEYXRldGltZVBhcnRzIG9iamVjdFxuICogQ3VycmVudGx5IGNhbiBvbmx5IGdvIGZvcndhcmQgYXQgbW9zdCAxIG1vbnRoLlxuICovXG5jb25zdCBhZGREYXlzID0gKHJlZlBhcnRzLCBudW1EYXlzKSA9PiB7XG4gICAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgICBpZiAoZGF5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF5IHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtpbmdQYXJ0cyA9IHtcbiAgICAgICAgbW9udGgsXG4gICAgICAgIGRheSxcbiAgICAgICAgeWVhcixcbiAgICB9O1xuICAgIGNvbnN0IGRheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICAgIHdvcmtpbmdQYXJ0cy5kYXkgPSBkYXkgKyBudW1EYXlzO1xuICAgIC8qKlxuICAgICAqIElmIHdyYXBwaW5nIHRvIG5leHQgbW9udGhcbiAgICAgKiB1cGRhdGUgZGF5cyBhbmQgaW5jcmVtZW50IG1vbnRoXG4gICAgICovXG4gICAgaWYgKHdvcmtpbmdQYXJ0cy5kYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICB3b3JraW5nUGFydHMuZGF5IC09IGRheXNJbk1vbnRoO1xuICAgICAgICB3b3JraW5nUGFydHMubW9udGggKz0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgbW92aW5nIHRvIG5leHQgeWVhciwgcmVzZXRcbiAgICAgKiBtb250aCB0byBKYW51YXJ5IGFuZCBpbmNyZW1lbnQgeWVhclxuICAgICAqL1xuICAgIGlmICh3b3JraW5nUGFydHMubW9udGggPiAxMikge1xuICAgICAgICB3b3JraW5nUGFydHMubW9udGggPSAxO1xuICAgICAgICB3b3JraW5nUGFydHMueWVhciArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2luZ1BhcnRzO1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIHByZXZpb3VzIG1vbnRoLlxuICovXG5jb25zdCBnZXRQcmV2aW91c01vbnRoID0gKHJlZlBhcnRzKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgY3VycmVudCBtb250aCBpcyBKYW51YXJ5LCB3cmFwIGJhY2t3YXJkc1xuICAgICAqICB0byBEZWNlbWJlciBvZiB0aGUgcHJldmlvdXMgeWVhci5cbiAgICAgKi9cbiAgICBjb25zdCBtb250aCA9IHJlZlBhcnRzLm1vbnRoID09PSAxID8gMTIgOiByZWZQYXJ0cy5tb250aCAtIDE7XG4gICAgY29uc3QgeWVhciA9IHJlZlBhcnRzLm1vbnRoID09PSAxID8gcmVmUGFydHMueWVhciAtIDEgOiByZWZQYXJ0cy55ZWFyO1xuICAgIGNvbnN0IG51bURheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICAgIGNvbnN0IGRheSA9IG51bURheXNJbk1vbnRoIDwgcmVmUGFydHMuZGF5ID8gbnVtRGF5c0luTW9udGggOiByZWZQYXJ0cy5kYXk7XG4gICAgcmV0dXJuIHsgbW9udGgsIHllYXIsIGRheSB9O1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIG5leHQgbW9udGguXG4gKi9cbmNvbnN0IGdldE5leHRNb250aCA9IChyZWZQYXJ0cykgPT4ge1xuICAgIC8qKlxuICAgICAqIElmIGN1cnJlbnQgbW9udGggaXMgRGVjZW1iZXIsIHdyYXAgZm9yd2FyZHNcbiAgICAgKiAgdG8gSmFudWFyeSBvZiB0aGUgbmV4dCB5ZWFyLlxuICAgICAqL1xuICAgIGNvbnN0IG1vbnRoID0gcmVmUGFydHMubW9udGggPT09IDEyID8gMSA6IHJlZlBhcnRzLm1vbnRoICsgMTtcbiAgICBjb25zdCB5ZWFyID0gcmVmUGFydHMubW9udGggPT09IDEyID8gcmVmUGFydHMueWVhciArIDEgOiByZWZQYXJ0cy55ZWFyO1xuICAgIGNvbnN0IG51bURheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICAgIGNvbnN0IGRheSA9IG51bURheXNJbk1vbnRoIDwgcmVmUGFydHMuZGF5ID8gbnVtRGF5c0luTW9udGggOiByZWZQYXJ0cy5kYXk7XG4gICAgcmV0dXJuIHsgbW9udGgsIHllYXIsIGRheSB9O1xufTtcbmNvbnN0IGNoYW5nZVllYXIgPSAocmVmUGFydHMsIHllYXJEZWx0YSkgPT4ge1xuICAgIGNvbnN0IG1vbnRoID0gcmVmUGFydHMubW9udGg7XG4gICAgY29uc3QgeWVhciA9IHJlZlBhcnRzLnllYXIgKyB5ZWFyRGVsdGE7XG4gICAgY29uc3QgbnVtRGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gICAgY29uc3QgZGF5ID0gbnVtRGF5c0luTW9udGggPCByZWZQYXJ0cy5kYXkgPyBudW1EYXlzSW5Nb250aCA6IHJlZlBhcnRzLmRheTtcbiAgICByZXR1cm4geyBtb250aCwgeWVhciwgZGF5IH07XG59O1xuLyoqXG4gKiBHaXZlbiBEYXRldGltZVBhcnRzLCBnZW5lcmF0ZSB0aGUgcHJldmlvdXMgeWVhci5cbiAqL1xuY29uc3QgZ2V0UHJldmlvdXNZZWFyID0gKHJlZlBhcnRzKSA9PiB7XG4gICAgcmV0dXJuIGNoYW5nZVllYXIocmVmUGFydHMsIC0xKTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBuZXh0IHllYXIuXG4gKi9cbmNvbnN0IGdldE5leHRZZWFyID0gKHJlZlBhcnRzKSA9PiB7XG4gICAgcmV0dXJuIGNoYW5nZVllYXIocmVmUGFydHMsIDEpO1xufTtcbi8qKlxuICogSWYgUE0sIHRoZW4gaW50ZXJuYWwgdmFsdWUgc2hvdWxkXG4gKiBiZSBjb252ZXJ0ZWQgdG8gMjQtaHIgdGltZS5cbiAqIERvZXMgbm90IGFwcGx5IHdoZW4gcHVibGljXG4gKiB2YWx1ZXMgYXJlIGFscmVhZHkgMjQtaHIgdGltZS5cbiAqL1xuY29uc3QgZ2V0SW50ZXJuYWxIb3VyVmFsdWUgPSAoaG91ciwgdXNlMjRIb3VyLCBhbXBtKSA9PiB7XG4gICAgaWYgKHVzZTI0SG91cikge1xuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnQxMkhvdXJUbzI0SG91cihob3VyLCBhbXBtKTtcbn07XG4vKipcbiAqIFVubGVzcyBvdGhlcndpc2Ugc3RhdGVkLCBhbGwgbW9udGggdmFsdWVzIGFyZVxuICogMSBpbmRleGVkIGluc3RlYWQgb2YgdGhlIHR5cGljYWwgMCBpbmRleCBpbiBKUyBEYXRlLlxuICogRXhhbXBsZTpcbiAqICAgSmFudWFyeSA9IE1vbnRoIDAgd2hlbiB1c2luZyBKUyBEYXRlXG4gKiAgIEphbnVhcnkgPSBNb250aCAxIHdoZW4gdXNpbmcgdGhpcyBkYXRldGltZSB1dGlsXG4gKi9cbi8qKlxuICogR2l2ZW4gdGhlIGN1cnJlbnQgZGF0ZXRpbWUgcGFydHMgYW5kIGEgbmV3IEFNL1BNIHZhbHVlXG4gKiBjYWxjdWxhdGUgd2hhdCB0aGUgaG91ciBzaG91bGQgYmUgaW4gMjQtaG91ciB0aW1lIGZvcm1hdC5cbiAqIFVzZWQgd2hlbiB0b2dnbGluZyB0aGUgQU0vUE0gc2VnbWVudCBzaW5jZSB3ZSBzdG9yZSBvdXIgaG91cnNcbiAqIGluIDI0LWhvdXIgdGltZSBmb3JtYXQgaW50ZXJuYWxseS5cbiAqL1xuY29uc3QgY2FsY3VsYXRlSG91ckZyb21BTVBNID0gKGN1cnJlbnRQYXJ0cywgbmV3QU1QTSkgPT4ge1xuICAgIGNvbnN0IHsgYW1wbTogY3VycmVudEFNUE0sIGhvdXIgfSA9IGN1cnJlbnRQYXJ0cztcbiAgICBsZXQgbmV3SG91ciA9IGhvdXI7XG4gICAgLyoqXG4gICAgICogSWYgZ29pbmcgZnJvbSBBTSAtLT4gUE0sIG5lZWQgdG8gdXBkYXRlIHRoZVxuICAgICAqXG4gICAgICovXG4gICAgaWYgKGN1cnJlbnRBTVBNID09PSAnYW0nICYmIG5ld0FNUE0gPT09ICdwbScpIHtcbiAgICAgICAgbmV3SG91ciA9IGNvbnZlcnQxMkhvdXJUbzI0SG91cihuZXdIb3VyLCAncG0nKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGdvaW5nIGZyb20gUE0gLS0+IEFNXG4gICAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW50QU1QTSA9PT0gJ3BtJyAmJiBuZXdBTVBNID09PSAnYW0nKSB7XG4gICAgICAgIG5ld0hvdXIgPSBNYXRoLmFicyhuZXdIb3VyIC0gMTIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3SG91cjtcbn07XG4vKipcbiAqIFVwZGF0ZXMgcGFydHMgdG8gZW5zdXJlIHRoYXQgbW9udGggYW5kIGRheVxuICogdmFsdWVzIGFyZSB2YWxpZC4gRm9yIGRheXMgdGhhdCBkbyBub3QgZXhpc3QsXG4gKiBvciBhcmUgb3V0c2lkZSB0aGUgbWluL21heCBib3VuZHMsIHRoZSBjbG9zZXN0XG4gKiB2YWxpZCBkYXkgaXMgdXNlZC5cbiAqL1xuY29uc3QgdmFsaWRhdGVQYXJ0cyA9IChwYXJ0cywgbWluUGFydHMsIG1heFBhcnRzKSA9PiB7XG4gICAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyIH0gPSBwYXJ0cztcbiAgICBjb25zdCBwYXJ0c0NvcHkgPSBjbGFtcERhdGUoT2JqZWN0LmFzc2lnbih7fSwgcGFydHMpLCBtaW5QYXJ0cywgbWF4UGFydHMpO1xuICAgIGNvbnN0IG51bURheXMgPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIG1heCBudW1iZXIgb2YgZGF5c1xuICAgICAqIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZGF5IHdlIHdhbnRcbiAgICAgKiB0byBzZXQsIHVwZGF0ZSB0aGUgRGF0ZXRpbWVQYXJ0c1xuICAgICAqIGRheSBmaWVsZCB0byBiZSB0aGUgbWF4IGRheXMuXG4gICAgICovXG4gICAgaWYgKGRheSAhPT0gbnVsbCAmJiBudW1EYXlzIDwgZGF5KSB7XG4gICAgICAgIHBhcnRzQ29weS5kYXkgPSBudW1EYXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZSBpcyBzYW1lIGRheSBhcyBtaW4gZGF5LFxuICAgICAqIG1ha2Ugc3VyZSB0aGUgdGltZSB2YWx1ZSBpcyBpbiBib3VuZHMuXG4gICAgICovXG4gICAgaWYgKG1pblBhcnRzICE9PSB1bmRlZmluZWQgJiYgaXNTYW1lRGF5KHBhcnRzQ29weSwgbWluUGFydHMpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgaG91ciBpcyBvdXQgb2YgYm91bmRzLFxuICAgICAgICAgKiB1cGRhdGUgYm90aCB0aGUgaG91ciBhbmQgbWludXRlLlxuICAgICAgICAgKiBUaGlzIGlzIGRvbmUgc28gdGhhdCB0aGUgbmV3IHRpbWVcbiAgICAgICAgICogaXMgY2xvc2VzdCB0byB3aGF0IHRoZSB1c2VyIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHBhcnRzQ29weS5ob3VyICE9PSB1bmRlZmluZWQgJiYgbWluUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocGFydHNDb3B5LmhvdXIgPCBtaW5QYXJ0cy5ob3VyKSB7XG4gICAgICAgICAgICAgICAgcGFydHNDb3B5LmhvdXIgPSBtaW5QYXJ0cy5ob3VyO1xuICAgICAgICAgICAgICAgIHBhcnRzQ29weS5taW51dGUgPSBtaW5QYXJ0cy5taW51dGU7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgb25seSB0aGUgbWludXRlIGlzIG91dCBvZiBib3VuZHMsXG4gICAgICAgICAgICAgICAgICogc2V0IGl0IHRvIHRoZSBtaW4gbWludXRlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydHNDb3B5LmhvdXIgPT09IG1pblBhcnRzLmhvdXIgJiZcbiAgICAgICAgICAgICAgICBwYXJ0c0NvcHkubWludXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBtaW5QYXJ0cy5taW51dGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHBhcnRzQ29weS5taW51dGUgPCBtaW5QYXJ0cy5taW51dGUpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c0NvcHkubWludXRlID0gbWluUGFydHMubWludXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHZhbHVlIGlzIHNhbWUgZGF5IGFzIG1heCBkYXksXG4gICAgICogbWFrZSBzdXJlIHRoZSB0aW1lIHZhbHVlIGlzIGluIGJvdW5kcy5cbiAgICAgKi9cbiAgICBpZiAobWF4UGFydHMgIT09IHVuZGVmaW5lZCAmJiBpc1NhbWVEYXkocGFydHMsIG1heFBhcnRzKSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGhvdXIgaXMgb3V0IG9mIGJvdW5kcyxcbiAgICAgICAgICogdXBkYXRlIGJvdGggdGhlIGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgICAgICogVGhpcyBpcyBkb25lIHNvIHRoYXQgdGhlIG5ldyB0aW1lXG4gICAgICAgICAqIGlzIGNsb3Nlc3QgdG8gd2hhdCB0aGUgdXNlciBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwYXJ0c0NvcHkuaG91ciAhPT0gdW5kZWZpbmVkICYmIG1heFBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHBhcnRzQ29weS5ob3VyID4gbWF4UGFydHMuaG91cikge1xuICAgICAgICAgICAgICAgIHBhcnRzQ29weS5ob3VyID0gbWF4UGFydHMuaG91cjtcbiAgICAgICAgICAgICAgICBwYXJ0c0NvcHkubWludXRlID0gbWF4UGFydHMubWludXRlO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIG9ubHkgdGhlIG1pbnV0ZSBpcyBvdXQgb2YgYm91bmRzLFxuICAgICAgICAgICAgICAgICAqIHNldCBpdCB0byB0aGUgbWF4IG1pbnV0ZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzQ29weS5ob3VyID09PSBtYXhQYXJ0cy5ob3VyICYmXG4gICAgICAgICAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgbWF4UGFydHMubWludXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBwYXJ0c0NvcHkubWludXRlID4gbWF4UGFydHMubWludXRlKSB7XG4gICAgICAgICAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1heFBhcnRzLm1pbnV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydHNDb3B5O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY2xvc2VzdCBkYXRlIHRvIHJlZlBhcnRzXG4gKiB0aGF0IGFsc28gbWVldHMgdGhlIGNvbnN0cmFpbnRzIG9mXG4gKiB0aGUgKlZhbHVlcyBwYXJhbXMuXG4gKi9cbmNvbnN0IGdldENsb3Nlc3RWYWxpZERhdGUgPSAoeyByZWZQYXJ0cywgbW9udGhWYWx1ZXMsIGRheVZhbHVlcywgeWVhclZhbHVlcywgaG91clZhbHVlcywgbWludXRlVmFsdWVzLCBtaW5QYXJ0cywgbWF4UGFydHMsIH0pID0+IHtcbiAgICBjb25zdCB7IGhvdXIsIG1pbnV0ZSwgZGF5LCBtb250aCwgeWVhciB9ID0gcmVmUGFydHM7XG4gICAgY29uc3QgY29weVBhcnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZQYXJ0cyksIHsgZGF5T2ZXZWVrOiB1bmRlZmluZWQgfSk7XG4gICAgaWYgKHllYXJWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBGaWx0ZXJzIG91dCB5ZWFycyB0aGF0IGFyZSBvdXQgb2YgdGhlIG1pbi9tYXggYm91bmRzXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkWWVhcnMgPSB5ZWFyVmFsdWVzLmZpbHRlcigoeWVhcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1pblBhcnRzICE9PSB1bmRlZmluZWQgJiYgeWVhciA8IG1pblBhcnRzLnllYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4UGFydHMgIT09IHVuZGVmaW5lZCAmJiB5ZWFyID4gbWF4UGFydHMueWVhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29weVBhcnRzLnllYXIgPSBmaW5kQ2xvc2VzdFZhbHVlKHllYXIsIGZpbHRlcmVkWWVhcnMpO1xuICAgIH1cbiAgICBpZiAobW9udGhWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBGaWx0ZXJzIG91dCBtb250aHMgdGhhdCBhcmUgb3V0IG9mIHRoZSBtaW4vbWF4IGJvdW5kc1xuICAgICAgICBjb25zdCBmaWx0ZXJlZE1vbnRocyA9IG1vbnRoVmFsdWVzLmZpbHRlcigobW9udGgpID0+IHtcbiAgICAgICAgICAgIGlmIChtaW5QYXJ0cyAhPT0gdW5kZWZpbmVkICYmIGNvcHlQYXJ0cy55ZWFyID09PSBtaW5QYXJ0cy55ZWFyICYmIG1vbnRoIDwgbWluUGFydHMubW9udGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4UGFydHMgIT09IHVuZGVmaW5lZCAmJiBjb3B5UGFydHMueWVhciA9PT0gbWF4UGFydHMueWVhciAmJiBtb250aCA+IG1heFBhcnRzLm1vbnRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb3B5UGFydHMubW9udGggPSBmaW5kQ2xvc2VzdFZhbHVlKG1vbnRoLCBmaWx0ZXJlZE1vbnRocyk7XG4gICAgfVxuICAgIC8vIERheSBpcyBudWxsYWJsZSBidXQgY2Fubm90IGJlIHVuZGVmaW5lZFxuICAgIGlmIChkYXkgIT09IG51bGwgJiYgZGF5VmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRmlsdGVycyBvdXQgZGF5cyB0aGF0IGFyZSBvdXQgb2YgdGhlIG1pbi9tYXggYm91bmRzXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRGF5cyA9IGRheVZhbHVlcy5maWx0ZXIoKGRheSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1pblBhcnRzICE9PSB1bmRlZmluZWQgJiYgaXNCZWZvcmUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb3B5UGFydHMpLCB7IGRheSB9KSwgbWluUGFydHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heFBhcnRzICE9PSB1bmRlZmluZWQgJiYgaXNBZnRlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvcHlQYXJ0cyksIHsgZGF5IH0pLCBtYXhQYXJ0cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvcHlQYXJ0cy5kYXkgPSBmaW5kQ2xvc2VzdFZhbHVlKGRheSwgZmlsdGVyZWREYXlzKTtcbiAgICB9XG4gICAgaWYgKGhvdXIgIT09IHVuZGVmaW5lZCAmJiBob3VyVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRmlsdGVycyBvdXQgaG91cnMgdGhhdCBhcmUgb3V0IG9mIHRoZSBtaW4vbWF4IGJvdW5kc1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEhvdXJzID0gaG91clZhbHVlcy5maWx0ZXIoKGhvdXIpID0+IHtcbiAgICAgICAgICAgIGlmICgobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLmhvdXIpICE9PSB1bmRlZmluZWQgJiYgaXNTYW1lRGF5KGNvcHlQYXJ0cywgbWluUGFydHMpICYmIGhvdXIgPCBtaW5QYXJ0cy5ob3VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMuaG91cikgIT09IHVuZGVmaW5lZCAmJiBpc1NhbWVEYXkoY29weVBhcnRzLCBtYXhQYXJ0cykgJiYgaG91ciA+IG1heFBhcnRzLmhvdXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvcHlQYXJ0cy5ob3VyID0gZmluZENsb3Nlc3RWYWx1ZShob3VyLCBmaWx0ZXJlZEhvdXJzKTtcbiAgICAgICAgY29weVBhcnRzLmFtcG0gPSBwYXJzZUFtUG0oY29weVBhcnRzLmhvdXIpO1xuICAgIH1cbiAgICBpZiAobWludXRlICE9PSB1bmRlZmluZWQgJiYgbWludXRlVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRmlsdGVycyBvdXQgbWludXRlcyB0aGF0IGFyZSBvdXQgb2YgdGhlIG1pbi9tYXggYm91bmRzXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWludXRlcyA9IG1pbnV0ZVZhbHVlcy5maWx0ZXIoKG1pbnV0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKChtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMubWludXRlKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgaXNTYW1lRGF5KGNvcHlQYXJ0cywgbWluUGFydHMpICYmXG4gICAgICAgICAgICAgICAgY29weVBhcnRzLmhvdXIgPT09IG1pblBhcnRzLmhvdXIgJiZcbiAgICAgICAgICAgICAgICBtaW51dGUgPCBtaW5QYXJ0cy5taW51dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy5taW51dGUpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVEYXkoY29weVBhcnRzLCBtYXhQYXJ0cykgJiZcbiAgICAgICAgICAgICAgICBjb3B5UGFydHMuaG91ciA9PT0gbWF4UGFydHMuaG91ciAmJlxuICAgICAgICAgICAgICAgIG1pbnV0ZSA+IG1heFBhcnRzLm1pbnV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29weVBhcnRzLm1pbnV0ZSA9IGZpbmRDbG9zZXN0VmFsdWUobWludXRlLCBmaWx0ZXJlZE1pbnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY29weVBhcnRzO1xufTtcbi8qKlxuICogRmluZHMgdGhlIHZhbHVlIGluIFwidmFsdWVzXCIgdGhhdCBpc1xuICogbnVtZXJpY2FsbHkgY2xvc2VzdCB0byBcInJlZmVyZW5jZVwiLlxuICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgXCJ2YWx1ZXNcIiBpc1xuICogYWxyZWFkeSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogQHBhcmFtIHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIG51bWJlciB0byB1c2VcbiAqIHdoZW4gZmluZGluZyB0aGUgY2xvc2VzdCB2YWx1ZVxuICogQHBhcmFtIHZhbHVlcyBUaGUgYWxsb3dlZCB2YWx1ZXMgdGhhdCB3aWxsIGJlXG4gKiBzZWFyY2hlZCB0byBmaW5kIHRoZSBjbG9zZXN0IHZhbHVlIHRvIFwicmVmZXJlbmNlXCJcbiAqL1xuY29uc3QgZmluZENsb3Nlc3RWYWx1ZSA9IChyZWZlcmVuY2UsIHZhbHVlcykgPT4ge1xuICAgIGxldCBjbG9zZXN0VmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgbGV0IHJhbmsgPSBNYXRoLmFicyhjbG9zZXN0VmFsdWUgLSByZWZlcmVuY2UpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjb2RlIHByaW9yaXRpemVzIHRoZSBmaXJzdFxuICAgICAgICAgKiBjbG9zZXN0IHJlc3VsdC4gR2l2ZW4gdHdvIHZhbHVlc1xuICAgICAgICAgKiB3aXRoIHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gcmVmZXJlbmNlLFxuICAgICAgICAgKiB0aGlzIGNvZGUgd2lsbCBwcmlvcml0aXplIHRoZSBzbWFsbGVyIG9mXG4gICAgICAgICAqIHRoZSB0d28gdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdmFsdWVSYW5rID0gTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpO1xuICAgICAgICBpZiAodmFsdWVSYW5rIDwgcmFuaykge1xuICAgICAgICAgICAgY2xvc2VzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByYW5rID0gdmFsdWVSYW5rO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0VmFsdWU7XG59O1xuXG5jb25zdCBnZXRGb3JtYXR0ZWREYXlQZXJpb2QgPSAoZGF5UGVyaW9kKSA9PiB7XG4gICAgaWYgKGRheVBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRheVBlcmlvZC50b1VwcGVyQ2FzZSgpO1xufTtcbi8qKlxuICogSW5jbHVkaW5nIHRpbWUgem9uZSBvcHRpb25zIG1heSBsZWFkIHRvIHRoZSByZW5kZXJlZCB0ZXh0IHNob3dpbmcgYVxuICogZGlmZmVyZW50IHRpbWUgZnJvbSB3aGF0IHdhcyBzZWxlY3RlZCBpbiB0aGUgRGF0ZXRpbWUsIHdoaWNoIGNvdWxkIGNhdXNlXG4gKiBjb25mdXNpb24uXG4gKi9cbmNvbnN0IHN0cmlwVGltZVpvbmUgPSAoZm9ybWF0T3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcm1hdE9wdGlvbnMpLCB7IFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dGluZyB0aGUgdGltZSB6b25lIHRvIFVUQyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIHNob3duIGlzIGFsd2F5cyB0aGVcbiAgICAgICAgICogc2FtZSBhcyB3aGF0IHdhcyBzZWxlY3RlZCBhbmQgc2FmZWd1YXJkcyBhZ2FpbnN0IG9sZGVyIFNhZmFyaSBidWdzIHdpdGhcbiAgICAgICAgICogSW50bC5EYXRlVGltZUZvcm1hdC5cbiAgICAgICAgICovXG4gICAgICAgIHRpbWVab25lOiAnVVRDJywgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBkbyBub3Qgd2FudCB0byBkaXNwbGF5IHRoZSB0aW1lIHpvbmUgbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGltZVpvbmVOYW1lOiB1bmRlZmluZWQgfSk7XG59O1xuY29uc3QgZ2V0TG9jYWxpemVkVGltZSA9IChsb2NhbGUsIHJlZlBhcnRzLCBob3VyQ3ljbGUsIGZvcm1hdE9wdGlvbnMgPSB7IGhvdXI6ICdudW1lcmljJywgbWludXRlOiAnbnVtZXJpYycgfSkgPT4ge1xuICAgIGNvbnN0IHRpbWVQYXJ0cyA9IHtcbiAgICAgICAgaG91cjogcmVmUGFydHMuaG91cixcbiAgICAgICAgbWludXRlOiByZWZQYXJ0cy5taW51dGUsXG4gICAgfTtcbiAgICBpZiAodGltZVBhcnRzLmhvdXIgPT09IHVuZGVmaW5lZCB8fCB0aW1lUGFydHMubWludXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICdJbnZhbGlkIFRpbWUnO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cmlwVGltZVpvbmUoZm9ybWF0T3B0aW9ucykpLCB7IFxuICAgICAgICAvKipcbiAgICAgICAgICogV2UgdXNlIGhvdXJDeWNsZSBoZXJlIGluc3RlYWQgb2YgaG91cjEyIGR1ZSB0bzpcbiAgICAgICAgICogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTM0NzMxNiZxPWhvdXIxMiZjYW49MlxuICAgICAgICAgKi9cbiAgICAgICAgaG91ckN5Y2xlIH0pKS5mb3JtYXQobmV3IERhdGUoY29udmVydERhdGFUb0lTTyhPYmplY3QuYXNzaWduKHsgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBKUyB1c2VzIGEgc2ltcGxpZmllZCBJU08gODYwMSBmb3JtYXQgd2hpY2ggYWxsb3dzIGZvclxuICAgICAgICAgKiBkYXRlLW9ubHkgZm9ybWF0cyBhbmQgZGF0ZS10aW1lIGZvcm1hdHMsIGJ1dCBub3RcbiAgICAgICAgICogdGltZS1vbmx5IGZvcm1hdHM6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZGF0ZS10aW1lLXN0cmluZy1mb3JtYXRcbiAgICAgICAgICogQXMgYSByZXN1bHQsIGRldmVsb3BlcnMgd2hvIG9ubHkgcGFzcyBhIHRpbWUgd2lsbCBnZXRcbiAgICAgICAgICogYW4gXCJJbnZhbGlkIERhdGVcIiBlcnJvci4gVG8gYWNjb3VudCBmb3IgdGhpcywgd2UgbWFrZSBzdXJlIHRoYXRcbiAgICAgICAgICogeWVhci9kYXkvbW9udGggdmFsdWVzIGFyZSBzZXQgd2hlbiBwYXNzaW5nIHRvIG5ldyBEYXRlKCkuXG4gICAgICAgICAqIFRoZSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNhbGwgYWJvdmUgb25seSB1c2VzIHRoZSBob3VyL21pbnV0ZVxuICAgICAgICAgKiB2YWx1ZXMsIHNvIHBhc3NpbmcgdGhlc2UgZGF0ZSB2YWx1ZXMgc2hvdWxkIGhhdmUgbm8gaW1wYWN0XG4gICAgICAgICAqIG9uIHRoZSB0aW1lIG91dHB1dC5cbiAgICAgICAgICovXG4gICAgICAgIHllYXI6IDIwMjMsIGRheTogMSwgbW9udGg6IDEgfSwgdGltZVBhcnRzKSkgKyAnWicpKTtcbn07XG4vKipcbiAqIEFkZHMgcGFkZGluZyB0byBhIHRpbWUgdmFsdWUgc29cbiAqIHRoYXQgaXQgaXMgYWx3YXlzIDIgZGlnaXRzLlxuICovXG5jb25zdCBhZGRUaW1lUGFkZGluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlVG9TdHJpbmcgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGlmICh2YWx1ZVRvU3RyaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9TdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBgMCR7dmFsdWVUb1N0cmluZ31gO1xufTtcbi8qKlxuICogRm9ybWF0cyAyNCBob3VyIHRpbWVzIHNvIHRoYXRcbiAqIGl0IGFsd2F5cyBoYXMgMiBkaWdpdHMuIEZvclxuICogMTIgaG91ciB0aW1lcyBpdCBlbnN1cmVzIHRoYXRcbiAqIGhvdXIgMCBpcyBmb3JtYXR0ZWQgYXMgJzEyJy5cbiAqL1xuY29uc3QgZ2V0Rm9ybWF0dGVkSG91ciA9IChob3VyLCBob3VyQ3ljbGUpID0+IHtcbiAgICAvKipcbiAgICAgKiBNaWRuaWdodCBmb3IgaDExIHN0YXJ0cyBhdCAwOjAwYW1cbiAgICAgKiBNaWRuaWdodCBmb3IgaDEyIHN0YXJ0cyBhdCAxMjowMGFtXG4gICAgICogTWlkbmlnaHQgZm9yIGgyMyBzdGFydHMgYXQgMDA6MDBcbiAgICAgKiBNaWRuaWdodCBmb3IgaDI0IHN0YXJ0cyBhdCAyNDowMFxuICAgICAqL1xuICAgIGlmIChob3VyID09PSAwKSB7XG4gICAgICAgIHN3aXRjaCAoaG91ckN5Y2xlKSB7XG4gICAgICAgICAgICBjYXNlICdoMTEnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgICAgICBjYXNlICdoMTInOlxuICAgICAgICAgICAgICAgIHJldHVybiAnMTInO1xuICAgICAgICAgICAgY2FzZSAnaDIzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzAwJztcbiAgICAgICAgICAgIGNhc2UgJ2gyNCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcyNCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3VyIGN5Y2xlIFwiJHtob3VyQ3ljbGV9XCJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1c2UyNEhvdXIgPSBpczI0SG91cihob3VyQ3ljbGUpO1xuICAgIC8qKlxuICAgICAqIGgyMyBhbmQgaDI0IHVzZSAyNCBob3VyIHRpbWVzLlxuICAgICAqL1xuICAgIGlmICh1c2UyNEhvdXIpIHtcbiAgICAgICAgcmV0dXJuIGFkZFRpbWVQYWRkaW5nKGhvdXIpO1xuICAgIH1cbiAgICByZXR1cm4gaG91ci50b1N0cmluZygpO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFyaWEtbGFiZWwgdG8gYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xuICogZ2l2ZW4gYSBsb2NhbCwgYSBkYXRlLCBhbmQgd2hldGhlciBvciBub3QgdGhhdCBkYXRlIGlzXG4gKiB0b2RheSdzIGRhdGUuXG4gKi9cbmNvbnN0IGdlbmVyYXRlRGF5QXJpYUxhYmVsID0gKGxvY2FsZSwgdG9kYXksIHJlZlBhcnRzKSA9PiB7XG4gICAgaWYgKHJlZlBhcnRzLmRheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTU0vREQvWVlZWSB3aWxsIHJldHVybiBtaWRuaWdodCBpbiB0aGUgdXNlcidzIHRpbWV6b25lLlxuICAgICAqL1xuICAgIGNvbnN0IGRhdGUgPSBnZXROb3JtYWxpemVkRGF0ZShyZWZQYXJ0cyk7XG4gICAgY29uc3QgbGFiZWxTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgd2Vla2RheTogJ2xvbmcnLFxuICAgICAgICBtb250aDogJ2xvbmcnLFxuICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgdGltZVpvbmU6ICdVVEMnLFxuICAgIH0pLmZvcm1hdChkYXRlKTtcbiAgICAvKipcbiAgICAgKiBJZiBkYXRlIGlzIHRvZGF5LCBwcmVwZW5kIFwiVG9kYXlcIiBzbyBzY3JlZW4gcmVhZGVycyBpbmRpY2F0ZVxuICAgICAqIHRoYXQgdGhlIGRhdGUgaXMgdG9kYXkuXG4gICAgICovXG4gICAgcmV0dXJuIHRvZGF5ID8gYFRvZGF5LCAke2xhYmVsU3RyaW5nfWAgOiBsYWJlbFN0cmluZztcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgbW9udGggbmFtZSBhbmQgZnVsbCB5ZWFyLlxuICogRXhhbXBsZTogTWF5IDIwMjFcbiAqL1xuY29uc3QgZ2V0TW9udGhBbmRZZWFyID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgICBjb25zdCBkYXRlID0gZ2V0Tm9ybWFsaXplZERhdGUocmVmUGFydHMpO1xuICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgbW9udGg6ICdsb25nJywgeWVhcjogJ251bWVyaWMnLCB0aW1lWm9uZTogJ1VUQycgfSkuZm9ybWF0KGRhdGUpO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgZGF0ZSBvYmplY3QsXG4gKiByZXR1cm4gYSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgaW5jbHVkZXNcbiAqIHRoZSBudW1lcmljIGRheS5cbiAqIE5vdGU6IFNvbWUgbGFuZ3VhZ2VzIHdpbGwgYWRkIGxpdGVyYWwgY2hhcmFjdGVyc1xuICogdG8gdGhlIGVuZC4gVGhpcyBmdW5jdGlvbiByZW1vdmVzIHRob3NlIGxpdGVyYWxzLlxuICogRXhhbXBsZTogMjlcbiAqL1xuY29uc3QgZ2V0RGF5ID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgICByZXR1cm4gZ2V0TG9jYWxpemVkRGF0ZVRpbWVQYXJ0cyhsb2NhbGUsIHJlZlBhcnRzLCB7IGRheTogJ251bWVyaWMnIH0pLmZpbmQoKG9iaikgPT4gb2JqLnR5cGUgPT09ICdkYXknKS52YWx1ZTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgbnVtZXJpYyB5ZWFyLlxuICogRXhhbXBsZTogMjAyMlxuICovXG5jb25zdCBnZXRZZWFyID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgICByZXR1cm4gZ2V0TG9jYWxpemVkRGF0ZVRpbWUobG9jYWxlLCByZWZQYXJ0cywgeyB5ZWFyOiAnbnVtZXJpYycgfSk7XG59O1xuLyoqXG4gKiBHaXZlbiByZWZlcmVuY2UgcGFydHMsIHJldHVybiBhIEpTIERhdGUgb2JqZWN0XG4gKiB3aXRoIGEgbm9ybWFsaXplZCB0aW1lLlxuICovXG5jb25zdCBnZXROb3JtYWxpemVkRGF0ZSA9IChyZWZQYXJ0cykgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHRpbWVTdHJpbmcgPSByZWZQYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQgJiYgcmVmUGFydHMubWludXRlICE9PSB1bmRlZmluZWQgPyBgICR7cmVmUGFydHMuaG91cn06JHtyZWZQYXJ0cy5taW51dGV9YCA6ICcnO1xuICAgIC8qKlxuICAgICAqIFdlIHVzZSAvIG5vdGF0aW9uIGhlcmUgZm9yIHRoZSBkYXRlXG4gICAgICogc28gd2UgZG8gbm90IG5lZWQgdG8gZG8gZXh0cmEgd29yayBhbmQgcGFkIHZhbHVlcyB3aXRoIHplcm9lcy5cbiAgICAgKiBWYWx1ZXMgc3VjaCBhcyBZWVlZLU1NIGFyZSBzdGlsbCB2YWxpZCwgc29cbiAgICAgKiB3ZSBhZGQgZmFsbGJhY2sgdmFsdWVzIHNvIHdlIHN0aWxsIGdldFxuICAgICAqIGEgdmFsaWQgZGF0ZSBvdGhlcndpc2Ugd2Ugd2lsbCBwYXNzIGluIGEgc3RyaW5nXG4gICAgICogbGlrZSBcIi8vMjAyM1wiLiBTb21lIGJyb3dzZXJzLCBzdWNoIGFzIENocm9tZSwgd2lsbFxuICAgICAqIGFjY291bnQgZm9yIHRoaXMgYW5kIHN0aWxsIHJldHVybiBhIHZhbGlkIGRhdGUuIEhvd2V2ZXIsXG4gICAgICogdGhpcyBpcyBub3QgYSBjb25zaXN0ZW50IGJlaGF2aW9yIGFjcm9zcyBhbGwgYnJvd3NlcnMuXG4gICAgICovXG4gICAgcmV0dXJuIG5ldyBEYXRlKGAkeyhfYSA9IHJlZlBhcnRzLm1vbnRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxfS8keyhfYiA9IHJlZlBhcnRzLmRheSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMX0vJHsoX2MgPSByZWZQYXJ0cy55ZWFyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAyMDIzfSR7dGltZVN0cmluZ30gR01UKzAwMDBgKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlLCBEYXRldGltZVBhcnRzLCBhbmQgb3B0aW9uc1xuICogZm9ybWF0IHRoZSBEYXRldGltZVBhcnRzIGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogYW5kIGxvY2FsZSBjb21iaW5hdGlvbi4gVGhpcyByZXR1cm5zIGEgc3RyaW5nLiBJZlxuICogeW91IHdhbnQgYW4gYXJyYXkgb2YgdGhlIGluZGl2aWR1YWwgcGllY2VzXG4gKiB0aGF0IG1ha2UgdXAgdGhlIGxvY2FsaXplZCBkYXRlIHN0cmluZywgdXNlXG4gKiBnZXRMb2NhbGl6ZWREYXRlVGltZVBhcnRzLlxuICovXG5jb25zdCBnZXRMb2NhbGl6ZWREYXRlVGltZSA9IChsb2NhbGUsIHJlZlBhcnRzLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZGF0ZSA9IGdldE5vcm1hbGl6ZWREYXRlKHJlZlBhcnRzKTtcbiAgICByZXR1cm4gZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBzdHJpcFRpbWVab25lKG9wdGlvbnMpKS5mb3JtYXQoZGF0ZSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSwgRGF0ZXRpbWVQYXJ0cywgYW5kIG9wdGlvbnNcbiAqIGZvcm1hdCB0aGUgRGF0ZXRpbWVQYXJ0cyBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqIGFuZCBsb2NhbGUgY29tYmluYXRpb24uIFRoaXMgcmV0dXJucyBhbiBhcnJheSBvZlxuICogZWFjaCBwaWVjZSBvZiB0aGUgZGF0ZS5cbiAqL1xuY29uc3QgZ2V0TG9jYWxpemVkRGF0ZVRpbWVQYXJ0cyA9IChsb2NhbGUsIHJlZlBhcnRzLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZGF0ZSA9IGdldE5vcm1hbGl6ZWREYXRlKHJlZlBhcnRzKTtcbiAgICByZXR1cm4gZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRUb1BhcnRzKGRhdGUpO1xufTtcbi8qKlxuICogV3JhcHBlciBmdW5jdGlvbiBmb3IgSW50bC5EYXRlVGltZUZvcm1hdC5cbiAqIEFsbG93cyBkZXZlbG9wZXJzIHRvIGFwcGx5IGFuIGFsbG93ZWQgZm9ybWF0IHRvIERhdGV0aW1lUGFydHMuXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gaGFzIGJ1aWx0IGluIHNhZmVndWFyZHMgZm9yIG9sZGVyIGJyb3dzZXIgYnVnc1xuICogd2l0aCBJbnRsLkRhdGVUaW1lRm9ybWF0LlxuICovXG5jb25zdCBnZXREYXRlVGltZUZvcm1hdCA9IChsb2NhbGUsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHRpbWVab25lOiAnVVRDJyB9KSk7XG59O1xuLyoqXG4gKiBHZXRzIGEgbG9jYWxpemVkIHZlcnNpb24gb2YgXCJUb2RheVwiXG4gKiBGYWxscyBiYWNrIHRvIFwiVG9kYXlcIiBpbiBFbmdsaXNoIGZvclxuICogYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBSZWxhdGl2ZVRpbWVGb3JtYXQuXG4gKi9cbmNvbnN0IGdldFRvZGF5TGFiZWwgPSAobG9jYWxlKSA9PiB7XG4gICAgaWYgKCdSZWxhdGl2ZVRpbWVGb3JtYXQnIGluIEludGwpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jYWxlLCB7IG51bWVyaWM6ICdhdXRvJyB9KS5mb3JtYXQoMCwgJ2RheScpO1xuICAgICAgICByZXR1cm4gbGFiZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsYWJlbC5zbGljZSgxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnVG9kYXknO1xuICAgIH1cbn07XG4vKipcbiAqIFdoZW4gY2FsbGluZyB0b0lTT1N0cmluZygpLCB0aGUgYnJvd3NlclxuICogd2lsbCBjb252ZXJ0IHRoZSBkYXRlIHRvIFVUQyB0aW1lIGJ5IGVpdGhlciBhZGRpbmdcbiAqIG9yIHN1YnRyYWN0aW5nIHRoZSB0aW1lIHpvbmUgb2Zmc2V0LlxuICogVG8gd29yayBhcm91bmQgdGhpcywgd2UgbmVlZCB0byBlaXRoZXIgYWRkXG4gKiBvciBzdWJ0cmFjdCB0aGUgdGltZSB6b25lIG9mZnNldCB0byB0aGUgRGF0ZVxuICogb2JqZWN0IHByaW9yIHRvIGNhbGxpbmcgdG9JU09TdHJpbmcoKS5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIGdldCBhbiBJU08gc3RyaW5nXG4gKiB0aGF0IGlzIGluIHRoZSB1c2VyJ3MgdGltZSB6b25lLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBUaW1lIHpvbmUgb2Zmc2V0IGlzIDI0MFxuICogTWVhbmluZzogVGhlIGJyb3dzZXIgbmVlZHMgdG8gYWRkIDI0MCBtaW51dGVzXG4gKiB0byB0aGUgRGF0ZSBvYmplY3QgdG8gZ2V0IFVUQyB0aW1lLlxuICogV2hhdCBJb25pYyBkb2VzOiBXZSBzdWJ0cmFjdCAyNDAgbWludXRlc1xuICogZnJvbSB0aGUgRGF0ZSBvYmplY3QuIFRoZSBicm93c2VyIHRoZW4gYWRkc1xuICogMjQwIG1pbnV0ZXMgaW4gdG9JU09TdHJpbmcoKS4gVGhlIHJlc3VsdFxuICogaXMgYSB0aW1lIHRoYXQgaXMgaW4gdGhlIHVzZXIncyB0aW1lIHpvbmVcbiAqIGFuZCBub3QgVVRDLlxuICpcbiAqIE5vdGU6IFNvbWUgdGltZXpvbmVzIGluY2x1ZGUgbWludXRlIGFkanVzdG1lbnRzXG4gKiBzdWNoIGFzIDMwIG9yIDQ1IG1pbnV0ZXMuIFRoaXMgaXMgd2h5IHdlIHVzZSBzZXRNaW51dGVzXG4gKiBpbnN0ZWFkIG9mIHNldEhvdXJzLlxuICogRXhhbXBsZTogSW5kaWEgU3RhbmRhcmQgVGltZVxuICogVGltZXpvbmUgb2Zmc2V0OiAtMzMwID0gLTUuNSBob3Vycy5cbiAqXG4gKiBMaXN0IG9mIHRpbWV6b25lcyB3aXRoIDMwIGFuZCA0NSBtaW51dGUgdGltZXpvbmVzOlxuICogaHR0cHM6Ly93d3cudGltZWFuZGRhdGUuY29tL3RpbWUvdGltZS16b25lcy1pbnRlcmVzdGluZy5odG1sXG4gKi9cbmNvbnN0IHJlbW92ZURhdGVUek9mZnNldCA9IChkYXRlKSA9PiB7XG4gICAgY29uc3QgdHpPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpIC0gdHpPZmZzZXQpO1xuICAgIHJldHVybiBkYXRlO1xufTtcbmNvbnN0IERBVEVfQU0gPSByZW1vdmVEYXRlVHpPZmZzZXQobmV3IERhdGUoJzIwMjJUMDE6MDAnKSk7XG5jb25zdCBEQVRFX1BNID0gcmVtb3ZlRGF0ZVR6T2Zmc2V0KG5ldyBEYXRlKCcyMDIyVDEzOjAwJykpO1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBsb2NhbGUncyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRheSBwZXJpb2QgKGFtL3BtKSBmb3IgYSBnaXZlblxuICogcmVmIHBhcnRzIGRheSBwZXJpb2QuXG4gKlxuICogQHBhcmFtIGxvY2FsZSBUaGUgbG9jYWxlIHRvIGZvcm1hdCB0aGUgZGF5IHBlcmlvZCBpbi5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgZGF0ZSBzdHJpbmcsIGluIElTTyBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgbG9jYWxpemVkIGRheSBwZXJpb2QgKGFtL3BtKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG4gKi9cbmNvbnN0IGdldExvY2FsaXplZERheVBlcmlvZCA9IChsb2NhbGUsIGRheVBlcmlvZCkgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBkYXlQZXJpb2QgPT09ICdhbScgPyBEQVRFX0FNIDogREFURV9QTTtcbiAgICBjb25zdCBsb2NhbGl6ZWREYXlQZXJpb2QgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICB0aW1lWm9uZTogJ1VUQycsXG4gICAgfSlcbiAgICAgICAgLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgICAgICAgLmZpbmQoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gJ2RheVBlcmlvZCcpO1xuICAgIGlmIChsb2NhbGl6ZWREYXlQZXJpb2QpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplZERheVBlcmlvZC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZERheVBlcmlvZChkYXlQZXJpb2QpO1xufTtcbi8qKlxuICogRm9ybWF0cyB0aGUgZGF0ZXRpbWUncyB2YWx1ZSB0byBhIHN0cmluZywgZm9yIHVzZSBpbiB0aGUgbmF0aXZlIGlucHV0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZm9ybWF0LCBlaXRoZXIgYW4gSVNPIHN0cmluZyBvciBhbiBhcnJheSB0aGVyZW9mLlxuICovXG5jb25zdCBmb3JtYXRWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywnKSA6IHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRhdGUgYXNcbiAqIGFuIElTTyBzdHJpbmcgaW4gdGhlIHVzZXInc1xuICogdGltZSB6b25lLlxuICovXG5jb25zdCBnZXRUb2RheSA9ICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBpb24tZGF0ZXRpbWUgaW50ZW50aW9uYWxseSBkb2VzIG5vdFxuICAgICAqIHBhcnNlIHRpbWUgem9uZXMvZG8gYXV0b21hdGljIHRpbWUgem9uZVxuICAgICAqIGNvbnZlcnNpb24gd2hlbiBhY2NlcHRpbmcgdXNlciBpbnB1dC5cbiAgICAgKiBIb3dldmVyIHdoZW4gd2UgZ2V0IHRvZGF5J3MgZGF0ZSBzdHJpbmcsXG4gICAgICogd2Ugd2FudCBpdCBmb3JtYXR0ZWQgcmVsYXRpdmUgdG8gdGhlIHVzZXInc1xuICAgICAqIHRpbWUgem9uZS5cbiAgICAgKlxuICAgICAqIFdoZW4gY2FsbGluZyB0b0lTT1N0cmluZygpLCB0aGUgYnJvd3NlclxuICAgICAqIHdpbGwgY29udmVydCB0aGUgZGF0ZSB0byBVVEMgdGltZSBieSBlaXRoZXIgYWRkaW5nXG4gICAgICogb3Igc3VidHJhY3RpbmcgdGhlIHRpbWUgem9uZSBvZmZzZXQuXG4gICAgICogVG8gd29yayBhcm91bmQgdGhpcywgd2UgbmVlZCB0byBlaXRoZXIgYWRkXG4gICAgICogb3Igc3VidHJhY3QgdGhlIHRpbWUgem9uZSBvZmZzZXQgdG8gdGhlIERhdGVcbiAgICAgKiBvYmplY3QgcHJpb3IgdG8gY2FsbGluZyB0b0lTT1N0cmluZygpLlxuICAgICAqIFRoaXMgYWxsb3dzIHVzIHRvIGdldCBhbiBJU08gc3RyaW5nXG4gICAgICogdGhhdCBpcyBpbiB0aGUgdXNlcidzIHRpbWUgem9uZS5cbiAgICAgKi9cbiAgICByZXR1cm4gcmVtb3ZlRGF0ZVR6T2Zmc2V0KG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCk7XG59O1xuY29uc3QgbWludXRlcyA9IFtcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSxcbiAgICAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSxcbl07XG4vLyBoMTEgaG91ciBzeXN0ZW0gdXNlcyAwLTExLiBNaWRuaWdodCBzdGFydHMgYXQgMDowMGFtLlxuY29uc3QgaG91cjExID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV07XG4vLyBoMTIgaG91ciBzeXN0ZW0gdXNlcyAwLTEyLiBNaWRuaWdodCBzdGFydHMgYXQgMTI6MDBhbS5cbmNvbnN0IGhvdXIxMiA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTFdO1xuLy8gaDIzIGhvdXIgc3lzdGVtIHVzZXMgMC0yMy4gTWlkbmlnaHQgc3RhcnRzIGF0IDA6MDAuXG5jb25zdCBob3VyMjMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzXTtcbi8vIGgyNCBob3VyIHN5c3RlbSB1c2VzIDEtMjQuIE1pZG5pZ2h0IHN0YXJ0cyBhdCAyNDowMC5cbmNvbnN0IGhvdXIyNCA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDBdO1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSBhbmQgYSBtb2RlLFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggZm9ybWF0dGVkIGRheXNcbiAqIG9mIHRoZSB3ZWVrLiBpT1Mgc2hvdWxkIGRpc3BsYXkgZGF5c1xuICogc3VjaCBhcyBcIk1vblwiIG9yIFwiVHVlXCIuXG4gKiBNRCBzaG91bGQgZGlzcGxheSBkYXlzIHN1Y2ggYXMgXCJNXCJcbiAqIG9yIFwiVFwiLlxuICovXG5jb25zdCBnZXREYXlzT2ZXZWVrID0gKGxvY2FsZSwgbW9kZSwgZmlyc3REYXlPZldlZWsgPSAwKSA9PiB7XG4gICAgLyoqXG4gICAgICogTm92IDFzdCwgMjAyMCBzdGFydHMgb24gYSBTdW5kYXkuXG4gICAgICogaW9uLWRhdGV0aW1lIGFzc3VtZXMgd2Vla3Mgc3RhcnQgb24gU3VuZGF5LFxuICAgICAqIGJ1dCBpcyBjb25maWd1cmFibGUgdmlhIGBmaXJzdERheU9mV2Vla2AuXG4gICAgICovXG4gICAgY29uc3Qgd2Vla2RheUZvcm1hdCA9IG1vZGUgPT09ICdpb3MnID8gJ3Nob3J0JyA6ICduYXJyb3cnO1xuICAgIGNvbnN0IGludGwgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgd2Vla2RheTogd2Vla2RheUZvcm1hdCB9KTtcbiAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgnMTEvMDEvMjAyMCcpO1xuICAgIGNvbnN0IGRheXNPZldlZWsgPSBbXTtcbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBkYXkgb2YgdGhlIHdlZWssXG4gICAgICogZ2V0IHRoZSBkYXkgbmFtZS5cbiAgICAgKi9cbiAgICBmb3IgKGxldCBpID0gZmlyc3REYXlPZldlZWs7IGkgPCBmaXJzdERheU9mV2VlayArIDc7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XG4gICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgaSk7XG4gICAgICAgIGRheXNPZldlZWsucHVzaChpbnRsLmZvcm1hdChjdXJyZW50RGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF5c09mV2Vlaztcbn07XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlXG4gKiBkYXlzIGluIGEgbW9udGggZm9yIGEgZ2l2ZW4geWVhci4gVmFsdWVzIGFyZVxuICogYWxpZ25lZCB3aXRoIGEgd2VlayBjYWxlbmRhciBzdGFydGluZyBvblxuICogdGhlIGZpcnN0RGF5T2ZXZWVrIHZhbHVlIChTdW5kYXkgYnkgZGVmYXVsdClcbiAqIHVzaW5nIG51bGwgdmFsdWVzLlxuICovXG5jb25zdCBnZXREYXlzT2ZNb250aCA9IChtb250aCwgeWVhciwgZmlyc3REYXlPZldlZWssIHNob3dBZGphY2VudERheXMgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IG51bURheXMgPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gICAgbGV0IHByZXZpb3VzTnVtRGF5czsgLy9wcmV2aW91cyBtb250aCBudW1iZXIgb2YgZGF5c1xuICAgIGlmIChtb250aCA9PT0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBtb250aCBpcyBKYW51YXJ5LCB0aGUgcHJldmlvdXMgbW9udGggc2hvdWxkIGJlIERlY2VtYmVyIG9mIHRoZSBwcmV2aW91cyB5ZWFyLlxuICAgICAgICBwcmV2aW91c051bURheXMgPSBnZXROdW1EYXlzSW5Nb250aCgxMiwgeWVhciAtIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgcHJldmlvdXMgbW9udGggc2hvdWxkIGJlIHRoZSBjdXJyZW50IG1vbnRoIC0gMSBvZiB0aGUgc2FtZSB5ZWFyLlxuICAgICAgICBwcmV2aW91c051bURheXMgPSBnZXROdW1EYXlzSW5Nb250aChtb250aCAtIDEsIHllYXIpO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE9mTW9udGggPSBuZXcgRGF0ZShgJHttb250aH0vMS8ke3llYXJ9YCkuZ2V0RGF5KCk7XG4gICAgLyoqXG4gICAgICogVG8gZ2V0IHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoIGFsaWduZWQgb24gdGhlIGNvcnJlY3RcbiAgICAgKiBkYXkgb2YgdGhlIHdlZWssIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IFwiZmlsbGVyXCIgZGF5c1xuICAgICAqIHRvIGdlbmVyYXRlLiBUaGVzZSBmaWxsZXIgZGF5cyBhcyBlbXB0eS9kaXNhYmxlZCBidXR0b25zXG4gICAgICogdGhhdCBmaWxsIHRoZSBzcGFjZSBvZiB0aGUgZGF5cyBvZiB0aGUgd2VlayBiZWZvcmUgdGhlIGZpcnN0XG4gICAgICogb2YgdGhlIG1vbnRoLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHR3byBjYXNlcyBoZXJlOlxuICAgICAqXG4gICAgICogMS4gSWYgZmlyc3RPZk1vbnRoID0gNCwgZmlyc3REYXlPZldlZWsgPSAwIHRoZW4gdGhlIG9mZnNldFxuICAgICAqIGlzICg0IC0gKDAgKyAxKSkgPSAzLiBTaW5jZSB0aGUgb2Zmc2V0IGxvb3AgZ29lcyBmcm9tIDAgdG8gMyBpbmNsdXNpdmUsXG4gICAgICogdGhpcyB3aWxsIGdlbmVyYXRlIDQgZmlsbGVyIGRheXMgKDAsIDEsIDIsIDMpLCBhbmQgdGhlbiBkYXkgb2Ygd2VlayA0IHdpbGwgaGF2ZVxuICAgICAqIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgICAqXG4gICAgICogMi4gSWYgZmlyc3RPZk1vbnRoID0gMiwgZmlyc3REYXlPZldlZWsgPSA0IHRoZW4gdGhlIG9mZnNldFxuICAgICAqIGlzICg2IC0gKDQgLSAyKSkgPSA0LiBTaW5jZSB0aGUgb2Zmc2V0IGxvb3AgZ29lcyBmcm9tIDAgdG8gNCBpbmNsdXNpdmUsXG4gICAgICogdGhpcyB3aWxsIGdlbmVyYXRlIDUgZmlsbGVyIGRheXMgKDAsIDEsIDIsIDMsIDQpLCBhbmQgdGhlbiBkYXkgb2Ygd2VlayA1IHdpbGwgaGF2ZVxuICAgICAqIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgICAqL1xuICAgIGNvbnN0IG9mZnNldCA9IGZpcnN0T2ZNb250aCA+PSBmaXJzdERheU9mV2VlayA/IGZpcnN0T2ZNb250aCAtIChmaXJzdERheU9mV2VlayArIDEpIDogNiAtIChmaXJzdERheU9mV2VlayAtIGZpcnN0T2ZNb250aCk7XG4gICAgbGV0IGRheXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1EYXlzOyBpKyspIHtcbiAgICAgICAgZGF5cy5wdXNoKHsgZGF5OiBpLCBkYXlPZldlZWs6IChvZmZzZXQgKyBpKSAlIDcsIGlzQWRqYWNlbnREYXk6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAoc2hvd0FkamFjZW50RGF5cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBvZmZzZXQ7IGkrKykge1xuICAgICAgICAgICAgLy8gVXNpbmcgb2Zmc2V0IGNyZWF0ZSBwcmV2aW91cyBtb250aCBhZGphY2VudCBkYXksIHN0YXJ0aW5nIGZyb20gbGFzdCBkYXlcbiAgICAgICAgICAgIGRheXMgPSBbeyBkYXk6IHByZXZpb3VzTnVtRGF5cyAtIGksIGRheU9mV2VlazogKHByZXZpb3VzTnVtRGF5cyAtIGkpICUgNywgaXNBZGphY2VudERheTogdHJ1ZSB9LCAuLi5kYXlzXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpdmVPZmZzZXRcbiAgICAgICAgLy8gVGhlIGNhbGVuZGFyIHdpbGwgZGlzcGxheSA0MiBkYXlzICg2IHJvd3Mgb2YgNyBjb2x1bW5zKVxuICAgICAgICAvLyBLbm93aW5nIHRoaXMgdGhlIG9mZnNldCBpcyA0MSAod2Ugc3RhcnQgYXQgaW5kZXggMClcbiAgICAgICAgLy8gbWludXMgKHRoZSBwcmV2aW91cyBvZmZzZXQgKyB0aGUgY3VycmVudCBtb250aCBkYXlzKVxuICAgICAgICBjb25zdCBwb3NpdGl2ZU9mZnNldCA9IDQxIC0gKG51bURheXMgKyBvZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aXZlT2Zmc2V0OyBpKyspIHtcbiAgICAgICAgICAgIGRheXMucHVzaCh7IGRheTogaSArIDEsIGRheU9mV2VlazogKG51bURheXMgKyBvZmZzZXQgKyBpKSAlIDcsIGlzQWRqYWNlbnREYXk6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG9mZnNldDsgaSsrKSB7XG4gICAgICAgICAgICBkYXlzID0gW3sgZGF5OiBudWxsLCBkYXlPZldlZWs6IG51bGwsIGlzQWRqYWNlbnREYXk6IGZhbHNlIH0sIC4uLmRheXNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXlzO1xufTtcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBwcmUtZGVmaW5lZCBob3VyXG4gKiB2YWx1ZXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGhvdXJDeWNsZS5cbiAqL1xuY29uc3QgZ2V0SG91ckRhdGEgPSAoaG91ckN5Y2xlKSA9PiB7XG4gICAgc3dpdGNoIChob3VyQ3ljbGUpIHtcbiAgICAgICAgY2FzZSAnaDExJzpcbiAgICAgICAgICAgIHJldHVybiBob3VyMTE7XG4gICAgICAgIGNhc2UgJ2gxMic6XG4gICAgICAgICAgICByZXR1cm4gaG91cjEyO1xuICAgICAgICBjYXNlICdoMjMnOlxuICAgICAgICAgICAgcmV0dXJuIGhvdXIyMztcbiAgICAgICAgY2FzZSAnaDI0JzpcbiAgICAgICAgICAgIHJldHVybiBob3VyMjQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaG91ciBjeWNsZSBcIiR7aG91ckN5Y2xlfVwiYCk7XG4gICAgfVxufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbCwgcmVmZXJlbmNlIGRhdGV0aW1lIHBhcnRzIGFuZCBvcHRpb25cbiAqIG1heC9taW4gYm91bmQgZGF0ZXRpbWUgcGFydHMsIGNhbGN1bGF0ZSB0aGUgYWNjZXB0YWJsZVxuICogaG91ciBhbmQgbWludXRlIHZhbHVlcyBhY2NvcmRpbmcgdG8gdGhlIGJvdW5kcyBhbmQgbG9jYWxlLlxuICovXG5jb25zdCBnZW5lcmF0ZVRpbWUgPSAobG9jYWxlLCByZWZQYXJ0cywgaG91ckN5Y2xlID0gJ2gxMicsIG1pblBhcnRzLCBtYXhQYXJ0cywgaG91clZhbHVlcywgbWludXRlVmFsdWVzKSA9PiB7XG4gICAgY29uc3QgY29tcHV0ZWRIb3VyQ3ljbGUgPSBnZXRIb3VyQ3ljbGUobG9jYWxlLCBob3VyQ3ljbGUpO1xuICAgIGNvbnN0IHVzZTI0SG91ciA9IGlzMjRIb3VyKGNvbXB1dGVkSG91ckN5Y2xlKTtcbiAgICBsZXQgcHJvY2Vzc2VkSG91cnMgPSBnZXRIb3VyRGF0YShjb21wdXRlZEhvdXJDeWNsZSk7XG4gICAgbGV0IHByb2Nlc3NlZE1pbnV0ZXMgPSBtaW51dGVzO1xuICAgIGxldCBpc0FNQWxsb3dlZCA9IHRydWU7XG4gICAgbGV0IGlzUE1BbGxvd2VkID0gdHJ1ZTtcbiAgICBpZiAoaG91clZhbHVlcykge1xuICAgICAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4gaG91clZhbHVlcy5pbmNsdWRlcyhob3VyKSk7XG4gICAgfVxuICAgIGlmIChtaW51dGVWYWx1ZXMpIHtcbiAgICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IG1pbnV0ZVZhbHVlcy5pbmNsdWRlcyhtaW51dGUpKTtcbiAgICB9XG4gICAgaWYgKG1pblBhcnRzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiByZWYgZGF5IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAgKiBtaW5pbXVtIGFsbG93ZWQgZGF5LCBmaWx0ZXIgaG91ci9taW51dGVcbiAgICAgICAgICogdmFsdWVzIGFjY29yZGluZyB0byBtaW4gaG91ciBhbmQgbWludXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzU2FtZURheShyZWZQYXJ0cywgbWluUGFydHMpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZXJzIG1heSBub3QgYWx3YXlzIHNldCB0aGUgaG91ci9taW51dGUgZm9yXG4gICAgICAgICAgICAgKiBtaW4gdmFsdWUgKGkuZS4gMjAyMS0wNi0wMikgc28gd2Ugc2hvdWxkIGFsbG93XG4gICAgICAgICAgICAgKiBhbGwgaG91cnMvbWludXRlcyBpbiB0aGF0IGNhc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChtaW5QYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRIb3VyID0gcmVmUGFydHMuYW1wbSA9PT0gJ3BtJyA/IChob3VyICsgMTIpICUgMjQgOiBob3VyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHVzZTI0SG91ciA/IGhvdXIgOiBjb252ZXJ0ZWRIb3VyKSA+PSBtaW5QYXJ0cy5ob3VyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlzQU1BbGxvd2VkID0gbWluUGFydHMuaG91ciA8IDEzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pblBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIG1pbmltdW0gbWludXRlIHJhbmdlIHNob3VsZCBub3QgYmUgZW5mb3JjZWQgd2hlblxuICAgICAgICAgICAgICAgICAqIHRoZSBob3VyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWluIGhvdXIuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBGb3IgZXhhbXBsZSB3aXRoIGEgbWluaW11bSByYW5nZSBvZiAwOTozMCwgdXNlcnNcbiAgICAgICAgICAgICAgICAgKiBzaG91bGQgYmUgYWJsZSB0byBzZWxlY3QgMTA6MDAtMTA6MjkgYW5kIGJleW9uZC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsZXQgaXNQYXN0TWluSG91ciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChtaW5QYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQgJiYgcmVmUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZQYXJ0cy5ob3VyID4gbWluUGFydHMuaG91cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXN0TWluSG91ciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFzdE1pbkhvdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW51dGUgPj0gbWluUGFydHMubWludXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiByZWYgZGF5IGlzIGJlZm9yZSBtaW5pbXVtXG4gICAgICAgICAgICAgKiBkYXkgZG8gbm90IHJlbmRlciBhbnkgaG91cnMvbWludXRlIHZhbHVlc1xuICAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCZWZvcmUocmVmUGFydHMsIG1pblBhcnRzKSkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkSG91cnMgPSBbXTtcbiAgICAgICAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBbXTtcbiAgICAgICAgICAgIGlzQU1BbGxvd2VkID0gaXNQTUFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF4UGFydHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHJlZiBkYXkgaXMgdGhlIHNhbWUgYXMgdGhlXG4gICAgICAgICAqIG1heGltdW0gYWxsb3dlZCBkYXksIGZpbHRlciBob3VyL21pbnV0ZVxuICAgICAgICAgKiB2YWx1ZXMgYWNjb3JkaW5nIHRvIG1heCBob3VyIGFuZCBtaW51dGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNTYW1lRGF5KHJlZlBhcnRzLCBtYXhQYXJ0cykpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlcnMgbWF5IG5vdCBhbHdheXMgc2V0IHRoZSBob3VyL21pbnV0ZSBmb3JcbiAgICAgICAgICAgICAqIG1heCB2YWx1ZSAoaS5lLiAyMDIxLTA2LTAyKSBzbyB3ZSBzaG91bGQgYWxsb3dcbiAgICAgICAgICAgICAqIGFsbCBob3Vycy9taW51dGVzIGluIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG1heFBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZEhvdXJzID0gcHJvY2Vzc2VkSG91cnMuZmlsdGVyKChob3VyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZEhvdXIgPSByZWZQYXJ0cy5hbXBtID09PSAncG0nID8gKGhvdXIgKyAxMikgJSAyNCA6IGhvdXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodXNlMjRIb3VyID8gaG91ciA6IGNvbnZlcnRlZEhvdXIpIDw9IG1heFBhcnRzLmhvdXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaXNQTUFsbG93ZWQgPSBtYXhQYXJ0cy5ob3VyID49IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heFBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmIHJlZlBhcnRzLmhvdXIgPT09IG1heFBhcnRzLmhvdXIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXZhaWxhYmxlIG1pbnV0ZXMgc2hvdWxkIG9ubHkgYmUgZmlsdGVyZWQgd2hlbiB0aGUgaG91ciBpcyB0aGUgc2FtZSBhcyB0aGUgbWF4IGhvdXIuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUgaWYgdGhlIG1heCBob3VyIGlzIDEwOjMwIGFuZCB0aGUgY3VycmVudCBob3VyIGlzIDEwOjAwLFxuICAgICAgICAgICAgICAgIC8vIHVzZXJzIHNob3VsZCBiZSBhYmxlIHRvIHNlbGVjdCAwMC0zMCBtaW51dGVzLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGhvdXIgaXMgMDk6MDAsIHVzZXJzIHNob3VsZCBiZSBhYmxlIHRvIHNlbGVjdCAwMC02MCBtaW51dGVzLlxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBwcm9jZXNzZWRNaW51dGVzLmZpbHRlcigobWludXRlKSA9PiBtaW51dGUgPD0gbWF4UGFydHMubWludXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgcmVmIGRheSBpcyBhZnRlciBtaW5pbXVtXG4gICAgICAgICAgICAgKiBkYXkgZG8gbm90IHJlbmRlciBhbnkgaG91cnMvbWludXRlIHZhbHVlc1xuICAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBZnRlcihyZWZQYXJ0cywgbWF4UGFydHMpKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRIb3VycyA9IFtdO1xuICAgICAgICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IFtdO1xuICAgICAgICAgICAgaXNBTUFsbG93ZWQgPSBpc1BNQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhvdXJzOiBwcm9jZXNzZWRIb3VycyxcbiAgICAgICAgbWludXRlczogcHJvY2Vzc2VkTWludXRlcyxcbiAgICAgICAgYW06IGlzQU1BbGxvd2VkLFxuICAgICAgICBwbTogaXNQTUFsbG93ZWQsXG4gICAgfTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBwcmV2aW91cyxcbiAqIGN1cnJlbnQsIGFuZCBhbmQgbmV4dCBtb250aHMuXG4gKi9cbmNvbnN0IGdlbmVyYXRlTW9udGhzID0gKHJlZlBhcnRzLCBmb3JjZWREYXRlKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHsgbW9udGg6IHJlZlBhcnRzLm1vbnRoLCB5ZWFyOiByZWZQYXJ0cy55ZWFyLCBkYXk6IHJlZlBhcnRzLmRheSB9O1xuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIGZvcmNpbmcgYSBtb250aCB0byBhcHBlYXIsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IG1vbnRoLFxuICAgICAqIGVuc3VyZSBpdCBhcHBlYXJzIGJ5IHJlcGxhY2luZyB0aGUgbmV4dCBvciBwcmV2aW91cyBtb250aCBhcyBhcHByb3ByaWF0ZS5cbiAgICAgKi9cbiAgICBpZiAoZm9yY2VkRGF0ZSAhPT0gdW5kZWZpbmVkICYmIChyZWZQYXJ0cy5tb250aCAhPT0gZm9yY2VkRGF0ZS5tb250aCB8fCByZWZQYXJ0cy55ZWFyICE9PSBmb3JjZWREYXRlLnllYXIpKSB7XG4gICAgICAgIGNvbnN0IGZvcmNlZCA9IHsgbW9udGg6IGZvcmNlZERhdGUubW9udGgsIHllYXI6IGZvcmNlZERhdGUueWVhciwgZGF5OiBmb3JjZWREYXRlLmRheSB9O1xuICAgICAgICBjb25zdCBmb3JjZWRNb250aElzQmVmb3JlID0gaXNCZWZvcmUoZm9yY2VkLCBjdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIGZvcmNlZE1vbnRoSXNCZWZvcmVcbiAgICAgICAgICAgID8gW2ZvcmNlZCwgY3VycmVudCwgZ2V0TmV4dE1vbnRoKHJlZlBhcnRzKV1cbiAgICAgICAgICAgIDogW2dldFByZXZpb3VzTW9udGgocmVmUGFydHMpLCBjdXJyZW50LCBmb3JjZWRdO1xuICAgIH1cbiAgICByZXR1cm4gW2dldFByZXZpb3VzTW9udGgocmVmUGFydHMpLCBjdXJyZW50LCBnZXROZXh0TW9udGgocmVmUGFydHMpXTtcbn07XG5jb25zdCBnZXRNb250aENvbHVtbkRhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCBtb250aFZhbHVlcywgZm9ybWF0T3B0aW9ucyA9IHtcbiAgICBtb250aDogJ2xvbmcnLFxufSkgPT4ge1xuICAgIGNvbnN0IHsgeWVhciB9ID0gcmVmUGFydHM7XG4gICAgY29uc3QgbW9udGhzID0gW107XG4gICAgaWYgKG1vbnRoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHByb2Nlc3NlZE1vbnRocyA9IG1vbnRoVmFsdWVzO1xuICAgICAgICBpZiAoKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy5tb250aCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkTW9udGhzID0gcHJvY2Vzc2VkTW9udGhzLmZpbHRlcigobW9udGgpID0+IG1vbnRoIDw9IG1heFBhcnRzLm1vbnRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy5tb250aCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkTW9udGhzID0gcHJvY2Vzc2VkTW9udGhzLmZpbHRlcigobW9udGgpID0+IG1vbnRoID49IG1pblBhcnRzLm1vbnRoKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzZWRNb250aHMuZm9yRWFjaCgocHJvY2Vzc2VkTW9udGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHtwcm9jZXNzZWRNb250aH0vMS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICAgICAgICBjb25zdCBtb250aFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgICAgICAgIG1vbnRocy5wdXNoKHsgdGV4dDogbW9udGhTdHJpbmcsIHZhbHVlOiBwcm9jZXNzZWRNb250aCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhNb250aCA9IG1heFBhcnRzICYmIG1heFBhcnRzLnllYXIgPT09IHllYXIgPyBtYXhQYXJ0cy5tb250aCA6IDEyO1xuICAgICAgICBjb25zdCBtaW5Nb250aCA9IG1pblBhcnRzICYmIG1pblBhcnRzLnllYXIgPT09IHllYXIgPyBtaW5QYXJ0cy5tb250aCA6IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSBtaW5Nb250aDsgaSA8PSBtYXhNb250aDsgaSsrKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGVyZSBpcyBhIGJ1ZyBvbiBpT1MgMTQgd2hlcmVcbiAgICAgICAgICAgICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgdGFrZXMgaW50byBhY2NvdW50XG4gICAgICAgICAgICAgKiB0aGUgbG9jYWwgdGltZXpvbmUgb2Zmc2V0IHdoZW4gZm9ybWF0dGluZyBkYXRlcy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGb3JjaW5nIHRoZSB0aW1lem9uZSB0byAnVVRDJyBmaXhlcyB0aGUgaXNzdWUuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQga2VlcCB0aGlzIHdvcmthcm91bmQgYXMgaXQgaXMgc2FmZXIuIEluIHRoZSBldmVudFxuICAgICAgICAgICAgICogdGhpcyBicmVha3MgaW4gYW5vdGhlciBicm93c2VyLCB3ZSB3aWxsIG5vdCBiZSBpbXBhY3RlZFxuICAgICAgICAgICAgICogYmVjYXVzZSBhbGwgZGF0ZXMgd2lsbCBiZSBpbnRlcnByZXRlZCBpbiBVVEMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRXhhbXBsZTpcbiAgICAgICAgICAgICAqIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHsgbW9udGg6ICdsb25nJyB9KS5mb3JtYXQobmV3IERhdGUoJ1NhdCBBcHIgMDEgMjAwNiAwMDowMDowMCBHTVQtMDQwMCAoRURUKScpKSAvLyBcIk1hcmNoXCJcbiAgICAgICAgICAgICAqIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHsgbW9udGg6ICdsb25nJywgdGltZVpvbmU6ICdVVEMnIH0pLmZvcm1hdChuZXcgRGF0ZSgnU2F0IEFwciAwMSAyMDA2IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpJykpIC8vIFwiQXByaWxcIlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIGNlcnRhaW4gdGltZXpvbmVzLCBpT1MgMTQgc2hvd3MgdGhlIHdyb25nXG4gICAgICAgICAgICAgKiBkYXRlIGZvciAudG9VVENTdHJpbmcoKS4gVG8gY29tYmF0IHRoaXMsIHdlXG4gICAgICAgICAgICAgKiBmb3JjZSBhbGwgb2YgdGhlIHRpbWV6b25lcyB0byBHTVQrMDAwMCAoVVRDKS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgICAgICogVGltZSBab25lOiBDZW50cmFsIEV1cm9wZWFuIFN0YW5kYXJkIFRpbWVcbiAgICAgICAgICAgICAqIG5ldyBEYXRlKCcxLzEvMTk5MicpLnRvVVRDU3RyaW5nKCkgLy8gXCJUdWUsIDMxIERlYyAxOTkxIDIzOjAwOjAwIEdNVFwiXG4gICAgICAgICAgICAgKiBuZXcgRGF0ZSgnMS8xLzE5OTIgR01UKzAwMDAnKS50b1VUQ1N0cmluZygpIC8vIFwiV2VkLCAwMSBKYW4gMTk5MiAwMDowMDowMCBHTVRcIlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7aX0vMS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICAgICAgICBjb25zdCBtb250aFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgICAgICAgIG1vbnRocy5wdXNoKHsgdGV4dDogbW9udGhTdHJpbmcsIHZhbHVlOiBpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb250aHM7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGluZm9ybWF0aW9uIHJlZ2FyZGluZ1xuICogc2VsZWN0YWJsZSBkYXRlcyAoaS5lIDFzdCwgMm5kLCAzcmQsIGV0YylcbiAqIHdpdGhpbiBhIHJlZmVyZW5jZSBtb250aC5cbiAqIEBwYXJhbSBsb2NhbGUgVGhlIGxvY2FsZSB0byBmb3JtYXQgdGhlIGRhdGUgd2l0aFxuICogQHBhcmFtIHJlZlBhcnRzIFRoZSByZWZlcmVuY2UgbW9udGgveWVhciB0byBnZW5lcmF0ZSBkYXRlcyBmb3JcbiAqIEBwYXJhbSBtaW5QYXJ0cyBUaGUgbWluaW11bSBib3VuZCBvbiB0aGUgZGF0ZSB0aGF0IGNhbiBiZSByZXR1cm5lZFxuICogQHBhcmFtIG1heFBhcnRzIFRoZSBtYXhpbXVtIGJvdW5kIG9uIHRoZSBkYXRlIHRoYXQgY2FuIGJlIHJldHVybmVkXG4gKiBAcGFyYW0gZGF5VmFsdWVzIFRoZSBhbGxvd2VkIGRhdGUgdmFsdWVzXG4gKiBAcmV0dXJucyBEYXRlIGRhdGEgdG8gYmUgdXNlZCBpbiBpb24tcGlja2VyLWNvbHVtblxuICovXG5jb25zdCBnZXREYXlDb2x1bW5EYXRhID0gKGxvY2FsZSwgcmVmUGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cywgZGF5VmFsdWVzLCBmb3JtYXRPcHRpb25zID0ge1xuICAgIGRheTogJ251bWVyaWMnLFxufSkgPT4ge1xuICAgIGNvbnN0IHsgbW9udGgsIHllYXIgfSA9IHJlZlBhcnRzO1xuICAgIGNvbnN0IGRheXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIG1heC9taW4gYm91bmRzIHRoYXQgaW4gdGhlIHNhbWVcbiAgICAgKiBtb250aC95ZWFyIGFzIHRoZSByZWZQYXJ0cywgd2Ugc2hvdWxkXG4gICAgICogdXNlIHRoZSBkZWZpbmUgZGF5IGFzIHRoZSBtYXgvbWluIGRheS5cbiAgICAgKiBPdGhlcndpc2UsIGZhbGxiYWNrIHRvIHRoZSBtYXgvbWluIGRheXMgaW4gYSBtb250aC5cbiAgICAgKi9cbiAgICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgICBjb25zdCBtYXhEYXkgPSAobWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLmRheSkgIT09IG51bGwgJiYgKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy5kYXkpICE9PSB1bmRlZmluZWQgJiYgbWF4UGFydHMueWVhciA9PT0geWVhciAmJiBtYXhQYXJ0cy5tb250aCA9PT0gbW9udGhcbiAgICAgICAgPyBtYXhQYXJ0cy5kYXlcbiAgICAgICAgOiBudW1EYXlzSW5Nb250aDtcbiAgICBjb25zdCBtaW5EYXkgPSAobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLmRheSkgIT09IG51bGwgJiYgKG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy5kYXkpICE9PSB1bmRlZmluZWQgJiYgbWluUGFydHMueWVhciA9PT0geWVhciAmJiBtaW5QYXJ0cy5tb250aCA9PT0gbW9udGhcbiAgICAgICAgPyBtaW5QYXJ0cy5kYXlcbiAgICAgICAgOiAxO1xuICAgIGlmIChkYXlWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcHJvY2Vzc2VkRGF5cyA9IGRheVZhbHVlcztcbiAgICAgICAgcHJvY2Vzc2VkRGF5cyA9IHByb2Nlc3NlZERheXMuZmlsdGVyKChkYXkpID0+IGRheSA+PSBtaW5EYXkgJiYgZGF5IDw9IG1heERheSk7XG4gICAgICAgIHByb2Nlc3NlZERheXMuZm9yRWFjaCgocHJvY2Vzc2VkRGF5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7bW9udGh9LyR7cHJvY2Vzc2VkRGF5fS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICAgICAgICBjb25zdCBkYXlTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0T3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKS5mb3JtYXQoZGF0ZSk7XG4gICAgICAgICAgICBkYXlzLnB1c2goeyB0ZXh0OiBkYXlTdHJpbmcsIHZhbHVlOiBwcm9jZXNzZWREYXkgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1pbkRheTsgaSA8PSBtYXhEYXk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke21vbnRofS8ke2l9LyR7eWVhcn0gR01UKzAwMDBgKTtcbiAgICAgICAgICAgIGNvbnN0IGRheVN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgICAgICAgIGRheXMucHVzaCh7IHRleHQ6IGRheVN0cmluZywgdmFsdWU6IGkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRheXM7XG59O1xuY29uc3QgZ2V0WWVhckNvbHVtbkRhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCB5ZWFyVmFsdWVzKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgcHJvY2Vzc2VkWWVhcnMgPSBbXTtcbiAgICBpZiAoeWVhclZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb2Nlc3NlZFllYXJzID0geWVhclZhbHVlcztcbiAgICAgICAgaWYgKChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMueWVhcikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkWWVhcnMgPSBwcm9jZXNzZWRZZWFycy5maWx0ZXIoKHllYXIpID0+IHllYXIgPD0gbWF4UGFydHMueWVhcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMueWVhcikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkWWVhcnMgPSBwcm9jZXNzZWRZZWFycy5maWx0ZXIoKHllYXIpID0+IHllYXIgPj0gbWluUGFydHMueWVhcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgeWVhciB9ID0gcmVmUGFydHM7XG4gICAgICAgIGNvbnN0IG1heFllYXIgPSAoX2EgPSBtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMueWVhcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeWVhcjtcbiAgICAgICAgY29uc3QgbWluWWVhciA9IChfYiA9IG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy55ZWFyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB5ZWFyIC0gMTAwO1xuICAgICAgICBmb3IgKGxldCBpID0gbWluWWVhcjsgaSA8PSBtYXhZZWFyOyBpKyspIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZFllYXJzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NlZFllYXJzLm1hcCgoeWVhcikgPT4gKHtcbiAgICAgICAgdGV4dDogZ2V0WWVhcihsb2NhbGUsIHsgeWVhciwgbW9udGg6IHJlZlBhcnRzLm1vbnRoLCBkYXk6IHJlZlBhcnRzLmRheSB9KSxcbiAgICAgICAgdmFsdWU6IHllYXIsXG4gICAgfSkpO1xufTtcbi8qKlxuICogR2l2ZW4gYSBzdGFydGluZyBkYXRlIGFuZCBhbiB1cHBlciBib3VuZCxcbiAqIHRoaXMgZnVuY3Rpb25zIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsXG4gKiBtb250aCBvYmplY3RzIGluIHRoYXQgcmFuZ2UuXG4gKi9cbmNvbnN0IGdldEFsbE1vbnRoc0luUmFuZ2UgPSAoY3VycmVudFBhcnRzLCBtYXhQYXJ0cykgPT4ge1xuICAgIGlmIChjdXJyZW50UGFydHMubW9udGggPT09IG1heFBhcnRzLm1vbnRoICYmIGN1cnJlbnRQYXJ0cy55ZWFyID09PSBtYXhQYXJ0cy55ZWFyKSB7XG4gICAgICAgIHJldHVybiBbY3VycmVudFBhcnRzXTtcbiAgICB9XG4gICAgcmV0dXJuIFtjdXJyZW50UGFydHMsIC4uLmdldEFsbE1vbnRoc0luUmFuZ2UoZ2V0TmV4dE1vbnRoKGN1cnJlbnRQYXJ0cyksIG1heFBhcnRzKV07XG59O1xuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIHBpY2tlciBpdGVtc1xuICogdGhhdCByZXByZXNlbnQgdGhlIGRheXMgaW4gYSBtb250aC5cbiAqIEV4YW1wbGU6IFwiVGh1LCBKdW4gMlwiXG4gKi9cbmNvbnN0IGdldENvbWJpbmVkRGF0ZUNvbHVtbkRhdGEgPSAobG9jYWxlLCB0b2RheVBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMsIGRheVZhbHVlcywgbW9udGhWYWx1ZXMpID0+IHtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIG1vbnRoIG9iamVjdHMgZnJvbSB0aGUgbWluIGRhdGVcbiAgICAgKiB0byB0aGUgbWF4IGRhdGUuIE5vdGU6IERvIG5vdCB1c2UgZ2V0TW9udGhDb2x1bW5EYXRhXG4gICAgICogYXMgdGhhdCBmdW5jdGlvbiBvbmx5IGdlbmVyYXRlcyBkYXRlcyB3aXRoaW4gYVxuICAgICAqIHNpbmdsZSB5ZWFyLlxuICAgICAqL1xuICAgIGxldCBtb250aHMgPSBnZXRBbGxNb250aHNJblJhbmdlKG1pblBhcnRzLCBtYXhQYXJ0cyk7XG4gICAgLyoqXG4gICAgICogRmlsdGVyIG91dCBhbnkgZGlzYWxsb3dlZCBtb250aCB2YWx1ZXMuXG4gICAgICovXG4gICAgaWYgKG1vbnRoVmFsdWVzKSB7XG4gICAgICAgIG1vbnRocyA9IG1vbnRocy5maWx0ZXIoKHsgbW9udGggfSkgPT4gbW9udGhWYWx1ZXMuaW5jbHVkZXMobW9udGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBvZiB0aGUgZGF5cyBpbiB0aGUgbW9udGguXG4gICAgICogRnJvbSB0aGVyZSwgZ2VuZXJhdGUgYW4gYXJyYXkgd2hlcmVcbiAgICAgKiBlYWNoIGl0ZW0gaGFzIHRoZSBtb250aCwgZGF0ZSwgYW5kIGRheVxuICAgICAqIG9mIHdvcmsgYXMgdGhlIHRleHQuXG4gICAgICovXG4gICAgbW9udGhzLmZvckVhY2goKG1vbnRoT2JqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZU1vbnRoID0geyBtb250aDogbW9udGhPYmplY3QubW9udGgsIGRheTogbnVsbCwgeWVhcjogbW9udGhPYmplY3QueWVhciB9O1xuICAgICAgICBjb25zdCBtb250aERheXMgPSBnZXREYXlDb2x1bW5EYXRhKGxvY2FsZSwgcmVmZXJlbmNlTW9udGgsIG1pblBhcnRzLCBtYXhQYXJ0cywgZGF5VmFsdWVzLCB7XG4gICAgICAgICAgICBtb250aDogJ3Nob3J0JyxcbiAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgd2Vla2RheTogJ3Nob3J0JyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRhdGVQYXJ0cyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRlQ29sdW1uSXRlbXMgPSBbXTtcbiAgICAgICAgbW9udGhEYXlzLmZvckVhY2goKGRheU9iamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNUb2RheSA9IGlzU2FtZURheShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZmVyZW5jZU1vbnRoKSwgeyBkYXk6IGRheU9iamVjdC52YWx1ZSB9KSwgdG9kYXlQYXJ0cyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRvZGF5J3MgZGF0ZSBzaG91bGQgcmVhZCBhcyBcIlRvZGF5XCIgKGxvY2FsaXplZClcbiAgICAgICAgICAgICAqIG5vdCB0aGUgYWN0dWFsIGRhdGUgc3RyaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRhdGVDb2x1bW5JdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBpc1RvZGF5ID8gZ2V0VG9kYXlMYWJlbChsb2NhbGUpIDogZGF5T2JqZWN0LnRleHQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3JlZmVyZW5jZU1vbnRoLnllYXJ9LSR7cmVmZXJlbmNlTW9udGgubW9udGh9LSR7ZGF5T2JqZWN0LnZhbHVlfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBzZWxlY3RpbmcgYSBkYXRlIGluIHRoZSB3aGVlbCBwaWNrZXJcbiAgICAgICAgICAgICAqIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSByYXcgZGF0ZXRpbWUgcGFydHMgZGF0YS5cbiAgICAgICAgICAgICAqIFRoZSBwaWNrZXIgY29sdW1uIG9ubHkgYWNjZXB0cyB2YWx1ZXMgb2ZcbiAgICAgICAgICAgICAqIHR5cGUgc3RyaW5nIG9yIG51bWJlciwgc28gd2UgbmVlZCB0byByZXR1cm5cbiAgICAgICAgICAgICAqIHR3byBzZXRzIG9mIGRhdGE6IEEgZGF0YSBzZXQgdG8gYmUgcGFzc2VkXG4gICAgICAgICAgICAgKiB0byB0aGUgcGlja2VyIGNvbHVtbiwgYW5kIGEgZGF0YSBzZXQgdG9cbiAgICAgICAgICAgICAqIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSByYXcgZGF0YSB3aGVuXG4gICAgICAgICAgICAgKiB1cGRhdGluZyB0aGUgcGlja2VyIGNvbHVtbiB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGF0ZVBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1vbnRoOiByZWZlcmVuY2VNb250aC5tb250aCxcbiAgICAgICAgICAgICAgICB5ZWFyOiByZWZlcmVuY2VNb250aC55ZWFyLFxuICAgICAgICAgICAgICAgIGRheTogZGF5T2JqZWN0LnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJ0cyA9IFsuLi5wYXJ0cywgLi4uZGF0ZVBhcnRzXTtcbiAgICAgICAgaXRlbXMgPSBbLi4uaXRlbXMsIC4uLmRhdGVDb2x1bW5JdGVtc107XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFydHMsXG4gICAgICAgIGl0ZW1zLFxuICAgIH07XG59O1xuY29uc3QgZ2V0VGltZUNvbHVtbnNEYXRhID0gKGxvY2FsZSwgcmVmUGFydHMsIGhvdXJDeWNsZSwgbWluUGFydHMsIG1heFBhcnRzLCBhbGxvd2VkSG91clZhbHVlcywgYWxsb3dlZE1pbnV0ZVZhbHVlcykgPT4ge1xuICAgIGNvbnN0IGNvbXB1dGVkSG91ckN5Y2xlID0gZ2V0SG91ckN5Y2xlKGxvY2FsZSwgaG91ckN5Y2xlKTtcbiAgICBjb25zdCB1c2UyNEhvdXIgPSBpczI0SG91cihjb21wdXRlZEhvdXJDeWNsZSk7XG4gICAgY29uc3QgeyBob3VycywgbWludXRlcywgYW0sIHBtIH0gPSBnZW5lcmF0ZVRpbWUobG9jYWxlLCByZWZQYXJ0cywgY29tcHV0ZWRIb3VyQ3ljbGUsIG1pblBhcnRzLCBtYXhQYXJ0cywgYWxsb3dlZEhvdXJWYWx1ZXMsIGFsbG93ZWRNaW51dGVWYWx1ZXMpO1xuICAgIGNvbnN0IGhvdXJzSXRlbXMgPSBob3Vycy5tYXAoKGhvdXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGdldEZvcm1hdHRlZEhvdXIoaG91ciwgY29tcHV0ZWRIb3VyQ3ljbGUpLFxuICAgICAgICAgICAgdmFsdWU6IGdldEludGVybmFsSG91clZhbHVlKGhvdXIsIHVzZTI0SG91ciwgcmVmUGFydHMuYW1wbSksXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgbWludXRlc0l0ZW1zID0gbWludXRlcy5tYXAoKG1pbnV0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogYWRkVGltZVBhZGRpbmcobWludXRlKSxcbiAgICAgICAgICAgIHZhbHVlOiBtaW51dGUsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGF5UGVyaW9kSXRlbXMgPSBbXTtcbiAgICBpZiAoYW0gJiYgIXVzZTI0SG91cikge1xuICAgICAgICBkYXlQZXJpb2RJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IGdldExvY2FsaXplZERheVBlcmlvZChsb2NhbGUsICdhbScpLFxuICAgICAgICAgICAgdmFsdWU6ICdhbScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocG0gJiYgIXVzZTI0SG91cikge1xuICAgICAgICBkYXlQZXJpb2RJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IGdldExvY2FsaXplZERheVBlcmlvZChsb2NhbGUsICdwbScpLFxuICAgICAgICAgICAgdmFsdWU6ICdwbScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtaW51dGVzRGF0YTogbWludXRlc0l0ZW1zLFxuICAgICAgICBob3Vyc0RhdGE6IGhvdXJzSXRlbXMsXG4gICAgICAgIGRheVBlcmlvZERhdGE6IGRheVBlcmlvZEl0ZW1zLFxuICAgIH07XG59O1xuXG5leHBvcnQgeyBnZXRDbG9zZXN0VmFsaWREYXRlIGFzIEEsIGdlbmVyYXRlTW9udGhzIGFzIEIsIGdldE51bURheXNJbk1vbnRoIGFzIEMsIGdldENvbWJpbmVkRGF0ZUNvbHVtbkRhdGEgYXMgRCwgZ2V0TW9udGhDb2x1bW5EYXRhIGFzIEUsIGdldERheUNvbHVtbkRhdGEgYXMgRiwgZ2V0WWVhckNvbHVtbkRhdGEgYXMgRywgaXNNb250aEZpcnN0TG9jYWxlIGFzIEgsIGdldFRpbWVDb2x1bW5zRGF0YSBhcyBJLCBpc0xvY2FsZURheVBlcmlvZFJUTCBhcyBKLCBjYWxjdWxhdGVIb3VyRnJvbUFNUE0gYXMgSywgZ2V0RGF5c09mV2VlayBhcyBMLCBnZXRNb250aEFuZFllYXIgYXMgTSwgZ2V0RGF5c09mTW9udGggYXMgTiwgZ2V0SG91ckN5Y2xlIGFzIE8sIGdldExvY2FsaXplZFRpbWUgYXMgUCwgZ2V0TG9jYWxpemVkRGF0ZVRpbWUgYXMgUSwgZm9ybWF0VmFsdWUgYXMgUiwgaXNBZnRlciBhcyBhLCBnZXROZXh0TW9udGggYXMgYiwgaXNTYW1lRGF5IGFzIGMsIGdldERheSBhcyBkLCBnZW5lcmF0ZURheUFyaWFMYWJlbCBhcyBlLCBnZXRQYXJ0c0Zyb21DYWxlbmRhckRheSBhcyBmLCBnZXRQcmV2aW91c01vbnRoIGFzIGcsIGdldE5leHRZZWFyIGFzIGgsIGlzQmVmb3JlIGFzIGksIGdldFByZXZpb3VzWWVhciBhcyBqLCBnZXRFbmRPZldlZWsgYXMgaywgZ2V0U3RhcnRPZldlZWsgYXMgbCwgZ2V0UHJldmlvdXNEYXkgYXMgbSwgZ2V0TmV4dERheSBhcyBuLCBnZXRQcmV2aW91c1dlZWsgYXMgbywgZ2V0TmV4dFdlZWsgYXMgcCwgcGFyc2VNaW5QYXJ0cyBhcyBxLCBwYXJzZU1heFBhcnRzIGFzIHIsIHBhcnNlRGF0ZSBhcyBzLCBwYXJzZUFtUG0gYXMgdCwgY2xhbXBEYXRlIGFzIHUsIHZhbGlkYXRlUGFydHMgYXMgdiwgd2FybklmVmFsdWVPdXRPZkJvdW5kcyBhcyB3LCBjb252ZXJ0VG9BcnJheU9mTnVtYmVycyBhcyB4LCBjb252ZXJ0RGF0YVRvSVNPIGFzIHksIGdldFRvZGF5IGFzIHogfTtcbiJdLCJuYW1lcyI6WyJtIiwicHJpbnRJb25XYXJuaW5nIiwiaXNTYW1lRGF5IiwiYmFzZVBhcnRzIiwiY29tcGFyZVBhcnRzIiwibW9udGgiLCJkYXkiLCJ5ZWFyIiwiaXNCZWZvcmUiLCJpc0FmdGVyIiwid2FybklmVmFsdWVPdXRPZkJvdW5kcyIsInZhbHVlIiwibWluIiwibWF4IiwidmFsdWVBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsInZhbCIsInVuZGVmaW5lZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpc0xlYXBZZWFyIiwiZ2V0SG91ckN5Y2xlIiwibG9jYWxlIiwiaG91ckN5Y2xlIiwiZm9ybWF0dGVkIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiaG91ciIsIm9wdGlvbnMiLCJyZXNvbHZlZE9wdGlvbnMiLCJkYXRlIiwiRGF0ZSIsInBhcnRzIiwiZm9ybWF0VG9QYXJ0cyIsImZpbmQiLCJwIiwidHlwZSIsIkVycm9yIiwiaXMyNEhvdXIiLCJnZXROdW1EYXlzSW5Nb250aCIsImlzTW9udGhGaXJzdExvY2FsZSIsImZvcm1hdE9wdGlvbnMiLCJpc0xvY2FsZURheVBlcmlvZFJUTCIsIklTT184NjAxX1JFR0VYUCIsIlRJTUVfUkVHRVhQIiwiY29udmVydFRvQXJyYXlPZk51bWJlcnMiLCJpbnB1dCIsInByb2Nlc3NlZElucHV0IiwicmVwbGFjZSIsInNwbGl0IiwidmFsdWVzIiwibWFwIiwibnVtIiwicGFyc2VJbnQiLCJmaWx0ZXIiLCJpc0Zpbml0ZSIsImdldFBhcnRzRnJvbUNhbGVuZGFyRGF5IiwiZWwiLCJnZXRBdHRyaWJ1dGUiLCJkYXlPZldlZWsiLCJwYXJzZURhdGUiLCJwYXJzZWRBcnJheSIsInZhbFN0ciIsInBhcnNlZFZhbCIsInB1c2giLCJwYXJzZSIsImV4ZWMiLCJ1bnNoaWZ0IiwiaSIsIm1pbnV0ZSIsImFtcG0iLCJjbGFtcERhdGUiLCJkYXRlUGFydHMiLCJtaW5QYXJ0cyIsIm1heFBhcnRzIiwicGFyc2VBbVBtIiwicGFyc2VNYXhQYXJ0cyIsInRvZGF5UGFydHMiLCJyZXN1bHQiLCJ5ZWFyVmFsdWUiLCJtb250aFZhbHVlIiwicGFyc2VNaW5QYXJ0cyIsInR3b0RpZ2l0IiwiTWF0aCIsImFicyIsInNsaWNlIiwiZm91ckRpZ2l0IiwiY29udmVydERhdGFUb0lTTyIsImRhdGEiLCJydG4iLCJjb252ZXJ0MTJIb3VyVG8yNEhvdXIiLCJnZXRTdGFydE9mV2VlayIsInJlZlBhcnRzIiwic3VidHJhY3REYXlzIiwiZ2V0RW5kT2ZXZWVrIiwiYWRkRGF5cyIsImdldE5leHREYXkiLCJnZXRQcmV2aW91c0RheSIsImdldFByZXZpb3VzV2VlayIsImdldE5leHRXZWVrIiwibnVtRGF5cyIsIndvcmtpbmdQYXJ0cyIsImRheXNJbk1vbnRoIiwiZ2V0UHJldmlvdXNNb250aCIsIm51bURheXNJbk1vbnRoIiwiZ2V0TmV4dE1vbnRoIiwiY2hhbmdlWWVhciIsInllYXJEZWx0YSIsImdldFByZXZpb3VzWWVhciIsImdldE5leHRZZWFyIiwiZ2V0SW50ZXJuYWxIb3VyVmFsdWUiLCJ1c2UyNEhvdXIiLCJjYWxjdWxhdGVIb3VyRnJvbUFNUE0iLCJjdXJyZW50UGFydHMiLCJuZXdBTVBNIiwiY3VycmVudEFNUE0iLCJuZXdIb3VyIiwidmFsaWRhdGVQYXJ0cyIsInBhcnRzQ29weSIsIk9iamVjdCIsImFzc2lnbiIsImdldENsb3Nlc3RWYWxpZERhdGUiLCJtb250aFZhbHVlcyIsImRheVZhbHVlcyIsInllYXJWYWx1ZXMiLCJob3VyVmFsdWVzIiwibWludXRlVmFsdWVzIiwiY29weVBhcnRzIiwiZmlsdGVyZWRZZWFycyIsImZpbmRDbG9zZXN0VmFsdWUiLCJmaWx0ZXJlZE1vbnRocyIsImZpbHRlcmVkRGF5cyIsImZpbHRlcmVkSG91cnMiLCJmaWx0ZXJlZE1pbnV0ZXMiLCJyZWZlcmVuY2UiLCJjbG9zZXN0VmFsdWUiLCJyYW5rIiwibGVuZ3RoIiwidmFsdWVSYW5rIiwiZ2V0Rm9ybWF0dGVkRGF5UGVyaW9kIiwiZGF5UGVyaW9kIiwidG9VcHBlckNhc2UiLCJzdHJpcFRpbWVab25lIiwidGltZVpvbmUiLCJ0aW1lWm9uZU5hbWUiLCJnZXRMb2NhbGl6ZWRUaW1lIiwidGltZVBhcnRzIiwiZm9ybWF0IiwiYWRkVGltZVBhZGRpbmciLCJ2YWx1ZVRvU3RyaW5nIiwidG9TdHJpbmciLCJnZXRGb3JtYXR0ZWRIb3VyIiwiZ2VuZXJhdGVEYXlBcmlhTGFiZWwiLCJ0b2RheSIsImdldE5vcm1hbGl6ZWREYXRlIiwibGFiZWxTdHJpbmciLCJ3ZWVrZGF5IiwiZ2V0TW9udGhBbmRZZWFyIiwiZ2V0RGF5IiwiZ2V0TG9jYWxpemVkRGF0ZVRpbWVQYXJ0cyIsIm9iaiIsImdldFllYXIiLCJnZXRMb2NhbGl6ZWREYXRlVGltZSIsIl9hIiwiX2IiLCJfYyIsInRpbWVTdHJpbmciLCJnZXREYXRlVGltZUZvcm1hdCIsImdldFRvZGF5TGFiZWwiLCJsYWJlbCIsIlJlbGF0aXZlVGltZUZvcm1hdCIsIm51bWVyaWMiLCJjaGFyQXQiLCJyZW1vdmVEYXRlVHpPZmZzZXQiLCJ0ek9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0TWludXRlcyIsImdldE1pbnV0ZXMiLCJEQVRFX0FNIiwiREFURV9QTSIsImdldExvY2FsaXplZERheVBlcmlvZCIsImxvY2FsaXplZERheVBlcmlvZCIsInBhcnQiLCJmb3JtYXRWYWx1ZSIsImpvaW4iLCJnZXRUb2RheSIsInRvSVNPU3RyaW5nIiwibWludXRlcyIsImhvdXIxMSIsImhvdXIxMiIsImhvdXIyMyIsImhvdXIyNCIsImdldERheXNPZldlZWsiLCJtb2RlIiwiZmlyc3REYXlPZldlZWsiLCJ3ZWVrZGF5Rm9ybWF0IiwiaW50bCIsInN0YXJ0RGF0ZSIsImRheXNPZldlZWsiLCJjdXJyZW50RGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwiZ2V0RGF5c09mTW9udGgiLCJzaG93QWRqYWNlbnREYXlzIiwicHJldmlvdXNOdW1EYXlzIiwiZmlyc3RPZk1vbnRoIiwib2Zmc2V0IiwiZGF5cyIsImlzQWRqYWNlbnREYXkiLCJwb3NpdGl2ZU9mZnNldCIsImdldEhvdXJEYXRhIiwiZ2VuZXJhdGVUaW1lIiwiY29tcHV0ZWRIb3VyQ3ljbGUiLCJwcm9jZXNzZWRIb3VycyIsInByb2Nlc3NlZE1pbnV0ZXMiLCJpc0FNQWxsb3dlZCIsImlzUE1BbGxvd2VkIiwiaW5jbHVkZXMiLCJjb252ZXJ0ZWRIb3VyIiwiaXNQYXN0TWluSG91ciIsImhvdXJzIiwiYW0iLCJwbSIsImdlbmVyYXRlTW9udGhzIiwiZm9yY2VkRGF0ZSIsImN1cnJlbnQiLCJmb3JjZWQiLCJmb3JjZWRNb250aElzQmVmb3JlIiwiZ2V0TW9udGhDb2x1bW5EYXRhIiwibW9udGhzIiwicHJvY2Vzc2VkTW9udGhzIiwiZm9yRWFjaCIsInByb2Nlc3NlZE1vbnRoIiwibW9udGhTdHJpbmciLCJ0ZXh0IiwibWF4TW9udGgiLCJtaW5Nb250aCIsImdldERheUNvbHVtbkRhdGEiLCJtYXhEYXkiLCJtaW5EYXkiLCJwcm9jZXNzZWREYXlzIiwicHJvY2Vzc2VkRGF5IiwiZGF5U3RyaW5nIiwiZ2V0WWVhckNvbHVtbkRhdGEiLCJwcm9jZXNzZWRZZWFycyIsIm1heFllYXIiLCJtaW5ZZWFyIiwiZ2V0QWxsTW9udGhzSW5SYW5nZSIsImdldENvbWJpbmVkRGF0ZUNvbHVtbkRhdGEiLCJpdGVtcyIsIm1vbnRoT2JqZWN0IiwicmVmZXJlbmNlTW9udGgiLCJtb250aERheXMiLCJkYXRlQ29sdW1uSXRlbXMiLCJkYXlPYmplY3QiLCJpc1RvZGF5IiwiZ2V0VGltZUNvbHVtbnNEYXRhIiwiYWxsb3dlZEhvdXJWYWx1ZXMiLCJhbGxvd2VkTWludXRlVmFsdWVzIiwiaG91cnNJdGVtcyIsIm1pbnV0ZXNJdGVtcyIsImRheVBlcmlvZEl0ZW1zIiwibWludXRlc0RhdGEiLCJob3Vyc0RhdGEiLCJkYXlQZXJpb2REYXRhIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJqIiwiayIsImwiLCJuIiwibyIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiXSwic291cmNlUm9vdCI6IndlYnBhY2s6Ly8vIiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzBdfQ==